
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model BairroPrioridades
 * 
 */
export type BairroPrioridades = $Result.DefaultSelection<Prisma.$BairroPrioridadesPayload>
/**
 * Model Carteiras
 * 
 */
export type Carteiras = $Result.DefaultSelection<Prisma.$CarteirasPayload>
/**
 * Model CodigoIndicacaos
 * 
 */
export type CodigoIndicacaos = $Result.DefaultSelection<Prisma.$CodigoIndicacaosPayload>
/**
 * Model CorridaAgendadas
 * 
 */
export type CorridaAgendadas = $Result.DefaultSelection<Prisma.$CorridaAgendadasPayload>
/**
 * Model Corridas
 * 
 */
export type Corridas = $Result.DefaultSelection<Prisma.$CorridasPayload>
/**
 * Model Denuncia
 * 
 */
export type Denuncia = $Result.DefaultSelection<Prisma.$DenunciaPayload>
/**
 * Model Documentos
 * 
 */
export type Documentos = $Result.DefaultSelection<Prisma.$DocumentosPayload>
/**
 * Model EmailEnviados
 * 
 */
export type EmailEnviados = $Result.DefaultSelection<Prisma.$EmailEnviadosPayload>
/**
 * Model HistoricoIndicacaos
 * 
 */
export type HistoricoIndicacaos = $Result.DefaultSelection<Prisma.$HistoricoIndicacaosPayload>
/**
 * Model HistoricoSelfies
 * 
 */
export type HistoricoSelfies = $Result.DefaultSelection<Prisma.$HistoricoSelfiesPayload>
/**
 * Model Identidades
 * 
 */
export type Identidades = $Result.DefaultSelection<Prisma.$IdentidadesPayload>
/**
 * Model Indicacaos
 * 
 */
export type Indicacaos = $Result.DefaultSelection<Prisma.$IndicacaosPayload>
/**
 * Model LogAcessos
 * 
 */
export type LogAcessos = $Result.DefaultSelection<Prisma.$LogAcessosPayload>
/**
 * Model MensagemSuportes
 * 
 */
export type MensagemSuportes = $Result.DefaultSelection<Prisma.$MensagemSuportesPayload>
/**
 * Model Recompensas
 * 
 */
export type Recompensas = $Result.DefaultSelection<Prisma.$RecompensasPayload>
/**
 * Model Saques
 * 
 */
export type Saques = $Result.DefaultSelection<Prisma.$SaquesPayload>
/**
 * Model Transacaos
 * 
 */
export type Transacaos = $Result.DefaultSelection<Prisma.$TransacaosPayload>
/**
 * Model Usuarios
 * 
 */
export type Usuarios = $Result.DefaultSelection<Prisma.$UsuariosPayload>
/**
 * Model Veiculos
 * 
 */
export type Veiculos = $Result.DefaultSelection<Prisma.$VeiculosPayload>
/**
 * Model agenda_corridas
 * 
 */
export type agenda_corridas = $Result.DefaultSelection<Prisma.$agenda_corridasPayload>
/**
 * Model avaliacoes
 * 
 */
export type avaliacoes = $Result.DefaultSelection<Prisma.$avaliacoesPayload>
/**
 * Model bairros_prioridade
 * 
 */
export type bairros_prioridade = $Result.DefaultSelection<Prisma.$bairros_prioridadePayload>
/**
 * Model carteiras
 * 
 */
export type carteiras = $Result.DefaultSelection<Prisma.$carteirasPayload>
/**
 * Model corridas
 * 
 */
export type corridas = $Result.DefaultSelection<Prisma.$corridasPayload>
/**
 * Model denuncias
 * 
 */
export type denuncias = $Result.DefaultSelection<Prisma.$denunciasPayload>
/**
 * Model documentos
 * 
 */
export type documentos = $Result.DefaultSelection<Prisma.$documentosPayload>
/**
 * Model emails_enviados
 * 
 */
export type emails_enviados = $Result.DefaultSelection<Prisma.$emails_enviadosPayload>
/**
 * Model historico_indicacoes
 * 
 */
export type historico_indicacoes = $Result.DefaultSelection<Prisma.$historico_indicacoesPayload>
/**
 * Model historico_selfies
 * 
 */
export type historico_selfies = $Result.DefaultSelection<Prisma.$historico_selfiesPayload>
/**
 * Model logs_acesso
 * 
 */
export type logs_acesso = $Result.DefaultSelection<Prisma.$logs_acessoPayload>
/**
 * Model mensagens_suporte
 * 
 */
export type mensagens_suporte = $Result.DefaultSelection<Prisma.$mensagens_suportePayload>
/**
 * Model pagamentos_pessoais
 * 
 */
export type pagamentos_pessoais = $Result.DefaultSelection<Prisma.$pagamentos_pessoaisPayload>
/**
 * Model paradas
 * 
 */
export type paradas = $Result.DefaultSelection<Prisma.$paradasPayload>
/**
 * Model recompensas
 * 
 */
export type recompensas = $Result.DefaultSelection<Prisma.$recompensasPayload>
/**
 * Model saques
 * 
 */
export type saques = $Result.DefaultSelection<Prisma.$saquesPayload>
/**
 * Model transacoes
 * 
 */
export type transacoes = $Result.DefaultSelection<Prisma.$transacoesPayload>
/**
 * Model usuarios
 * 
 */
export type usuarios = $Result.DefaultSelection<Prisma.$usuariosPayload>
/**
 * Model veiculos
 * 
 */
export type veiculos = $Result.DefaultSelection<Prisma.$veiculosPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const enum_BairroPrioridades_tipo_prioridade: {
  bonus: 'bonus',
  bloqueio: 'bloqueio',
  teste: 'teste'
};

export type enum_BairroPrioridades_tipo_prioridade = (typeof enum_BairroPrioridades_tipo_prioridade)[keyof typeof enum_BairroPrioridades_tipo_prioridade]


export const enum_Corridas_tipo: {
  imediata: 'imediata',
  agendada: 'agendada',
  personalizada: 'personalizada'
};

export type enum_Corridas_tipo = (typeof enum_Corridas_tipo)[keyof typeof enum_Corridas_tipo]


export const enum_Denuncia_tipo_alvo: {
  motorista: 'motorista',
  passageiro: 'passageiro'
};

export type enum_Denuncia_tipo_alvo = (typeof enum_Denuncia_tipo_alvo)[keyof typeof enum_Denuncia_tipo_alvo]


export const enum_Documentos_tipo_documento: {
  rg: 'rg',
  cnh: 'cnh',
  comprovante_residencia: 'comprovante_residencia',
  outro: 'outro'
};

export type enum_Documentos_tipo_documento = (typeof enum_Documentos_tipo_documento)[keyof typeof enum_Documentos_tipo_documento]


export const enum_EmailEnviados_tipo: {
  cadastro: 'cadastro',
  recuperacao_senha: 'recuperacao_senha',
  recompensa: 'recompensa',
  outro: 'outro'
};

export type enum_EmailEnviados_tipo = (typeof enum_EmailEnviados_tipo)[keyof typeof enum_EmailEnviados_tipo]


export const enum_HistoricoIndicacaos_tipo: {
  motorista: 'motorista',
  passageiro: 'passageiro'
};

export type enum_HistoricoIndicacaos_tipo = (typeof enum_HistoricoIndicacaos_tipo)[keyof typeof enum_HistoricoIndicacaos_tipo]


export const enum_HistoricoSelfies_tipo: {
  motorista: 'motorista',
  passageiro: 'passageiro'
};

export type enum_HistoricoSelfies_tipo = (typeof enum_HistoricoSelfies_tipo)[keyof typeof enum_HistoricoSelfies_tipo]


export const enum_LogAcessos_tipo_usuario: {
  motorista: 'motorista',
  passageiro: 'passageiro'
};

export type enum_LogAcessos_tipo_usuario = (typeof enum_LogAcessos_tipo_usuario)[keyof typeof enum_LogAcessos_tipo_usuario]


export const enum_MensagemSuportes_tipo_usuario: {
  motorista: 'motorista',
  passageiro: 'passageiro'
};

export type enum_MensagemSuportes_tipo_usuario = (typeof enum_MensagemSuportes_tipo_usuario)[keyof typeof enum_MensagemSuportes_tipo_usuario]


export const enum_Recompensas_status: {
  disponivel: 'disponivel',
  resgatado: 'resgatado'
};

export type enum_Recompensas_status = (typeof enum_Recompensas_status)[keyof typeof enum_Recompensas_status]


export const enum_Saques_status: {
  pendente: 'pendente',
  processado: 'processado',
  recusado: 'recusado'
};

export type enum_Saques_status = (typeof enum_Saques_status)[keyof typeof enum_Saques_status]


export const enum_Saques_tipo: {
  recompensa: 'recompensa',
  corrida: 'corrida'
};

export type enum_Saques_tipo = (typeof enum_Saques_tipo)[keyof typeof enum_Saques_tipo]


export const enum_Transacaos_tipo: {
  corrida: 'corrida',
  recompensa: 'recompensa',
  saque: 'saque',
  ajuste: 'ajuste',
  bonus: 'bonus'
};

export type enum_Transacaos_tipo = (typeof enum_Transacaos_tipo)[keyof typeof enum_Transacaos_tipo]


export const enum_Veiculos_categoria: {
  alpha: 'alpha',
  delta: 'delta',
  omega: 'omega',
  mala: 'mala',
  entrega: 'entrega',
  arca: 'arca'
};

export type enum_Veiculos_categoria = (typeof enum_Veiculos_categoria)[keyof typeof enum_Veiculos_categoria]


export const enum_agenda_corridas_categoria: {
  alpha: 'alpha',
  delta: 'delta',
  omega: 'omega',
  mala: 'mala',
  entrega: 'entrega',
  arca: 'arca'
};

export type enum_agenda_corridas_categoria = (typeof enum_agenda_corridas_categoria)[keyof typeof enum_agenda_corridas_categoria]


export const enum_agenda_corridas_status: {
  pendente: 'pendente',
  atribuida: 'atribuida',
  cancelada: 'cancelada',
  concluida: 'concluida'
};

export type enum_agenda_corridas_status = (typeof enum_agenda_corridas_status)[keyof typeof enum_agenda_corridas_status]


export const enum_avaliacoes_tipo: {
  motorista: 'motorista',
  passageiro: 'passageiro'
};

export type enum_avaliacoes_tipo = (typeof enum_avaliacoes_tipo)[keyof typeof enum_avaliacoes_tipo]


export const enum_bairros_prioridade_tipo_prioridade: {
  bonus: 'bonus',
  bloqueio: 'bloqueio',
  teste: 'teste'
};

export type enum_bairros_prioridade_tipo_prioridade = (typeof enum_bairros_prioridade_tipo_prioridade)[keyof typeof enum_bairros_prioridade_tipo_prioridade]


export const enum_carteiras_tipo: {
  motorista: 'motorista',
  passageiro: 'passageiro'
};

export type enum_carteiras_tipo = (typeof enum_carteiras_tipo)[keyof typeof enum_carteiras_tipo]


export const enum_corridas_forma_pagamento: {
  dinheiro: 'dinheiro',
  pix: 'pix',
  cartao: 'cartao'
};

export type enum_corridas_forma_pagamento = (typeof enum_corridas_forma_pagamento)[keyof typeof enum_corridas_forma_pagamento]


export const enum_corridas_status: {
  pendente: 'pendente',
  aceita: 'aceita',
  concluida: 'concluida',
  cancelada: 'cancelada'
};

export type enum_corridas_status = (typeof enum_corridas_status)[keyof typeof enum_corridas_status]


export const enum_denuncias_status: {
  pendente: 'pendente',
  em_analise: 'em_analise',
  resolvida: 'resolvida'
};

export type enum_denuncias_status = (typeof enum_denuncias_status)[keyof typeof enum_denuncias_status]


export const enum_denuncias_tipo_alvo: {
  motorista: 'motorista',
  passageiro: 'passageiro'
};

export type enum_denuncias_tipo_alvo = (typeof enum_denuncias_tipo_alvo)[keyof typeof enum_denuncias_tipo_alvo]


export const enum_documentos_status: {
  pendente: 'pendente',
  validado: 'validado',
  rejeitado: 'rejeitado'
};

export type enum_documentos_status = (typeof enum_documentos_status)[keyof typeof enum_documentos_status]


export const enum_documentos_tipo_documento: {
  rg: 'rg',
  cnh: 'cnh',
  comprovante_residencia: 'comprovante_residencia',
  outro: 'outro'
};

export type enum_documentos_tipo_documento = (typeof enum_documentos_tipo_documento)[keyof typeof enum_documentos_tipo_documento]


export const enum_emails_enviados_status_envio: {
  enviado: 'enviado',
  erro: 'erro',
  pendente: 'pendente'
};

export type enum_emails_enviados_status_envio = (typeof enum_emails_enviados_status_envio)[keyof typeof enum_emails_enviados_status_envio]


export const enum_emails_enviados_tipo: {
  cadastro: 'cadastro',
  recuperacao_senha: 'recuperacao_senha',
  recompensa: 'recompensa',
  outro: 'outro'
};

export type enum_emails_enviados_tipo = (typeof enum_emails_enviados_tipo)[keyof typeof enum_emails_enviados_tipo]


export const enum_historico_indicacoes_tipo: {
  motorista: 'motorista',
  passageiro: 'passageiro'
};

export type enum_historico_indicacoes_tipo = (typeof enum_historico_indicacoes_tipo)[keyof typeof enum_historico_indicacoes_tipo]


export const enum_historico_selfies_resultado: {
  validada: 'validada',
  rejeitada: 'rejeitada',
  pendente: 'pendente'
};

export type enum_historico_selfies_resultado = (typeof enum_historico_selfies_resultado)[keyof typeof enum_historico_selfies_resultado]


export const enum_historico_selfies_tipo: {
  motorista: 'motorista',
  passageiro: 'passageiro'
};

export type enum_historico_selfies_tipo = (typeof enum_historico_selfies_tipo)[keyof typeof enum_historico_selfies_tipo]


export const enum_logs_acesso_tipo_usuario: {
  motorista: 'motorista',
  passageiro: 'passageiro'
};

export type enum_logs_acesso_tipo_usuario = (typeof enum_logs_acesso_tipo_usuario)[keyof typeof enum_logs_acesso_tipo_usuario]


export const enum_mensagens_suporte_status: {
  aberto: 'aberto',
  em_analise: 'em_analise',
  resolvido: 'resolvido'
};

export type enum_mensagens_suporte_status = (typeof enum_mensagens_suporte_status)[keyof typeof enum_mensagens_suporte_status]


export const enum_mensagens_suporte_tipo_usuario: {
  motorista: 'motorista',
  passageiro: 'passageiro'
};

export type enum_mensagens_suporte_tipo_usuario = (typeof enum_mensagens_suporte_tipo_usuario)[keyof typeof enum_mensagens_suporte_tipo_usuario]


export const enum_recompensas_status: {
  pendente: 'pendente',
  liberada: 'liberada',
  paga: 'paga'
};

export type enum_recompensas_status = (typeof enum_recompensas_status)[keyof typeof enum_recompensas_status]


export const enum_recompensas_tipo: {
  motorista: 'motorista',
  passageiro: 'passageiro'
};

export type enum_recompensas_tipo = (typeof enum_recompensas_tipo)[keyof typeof enum_recompensas_tipo]


export const enum_saques_status: {
  pendente: 'pendente',
  aprovado: 'aprovado',
  recusado: 'recusado',
  pago: 'pago'
};

export type enum_saques_status = (typeof enum_saques_status)[keyof typeof enum_saques_status]


export const enum_saques_tipo: {
  corrida: 'corrida',
  recompensa: 'recompensa',
  ambos: 'ambos'
};

export type enum_saques_tipo = (typeof enum_saques_tipo)[keyof typeof enum_saques_tipo]


export const enum_transacoes_origem: {
  sistema: 'sistema',
  admin: 'admin',
  indicacao: 'indicacao',
  corrida: 'corrida',
  outro: 'outro'
};

export type enum_transacoes_origem = (typeof enum_transacoes_origem)[keyof typeof enum_transacoes_origem]


export const enum_transacoes_tipo: {
  corrida: 'corrida',
  recompensa: 'recompensa',
  saque: 'saque',
  ajuste: 'ajuste',
  bonus: 'bonus'
};

export type enum_transacoes_tipo = (typeof enum_transacoes_tipo)[keyof typeof enum_transacoes_tipo]


export const enum_usuarios_tipo: {
  motorista: 'motorista',
  passageiro: 'passageiro'
};

export type enum_usuarios_tipo = (typeof enum_usuarios_tipo)[keyof typeof enum_usuarios_tipo]


export const enum_veiculos_categoria: {
  alpha: 'alpha',
  delta: 'delta',
  omega: 'omega',
  mala: 'mala',
  entrega: 'entrega',
  arca: 'arca'
};

export type enum_veiculos_categoria = (typeof enum_veiculos_categoria)[keyof typeof enum_veiculos_categoria]


export const enum_veiculos_status: {
  ativo: 'ativo',
  pendente: 'pendente',
  reprovado: 'reprovado'
};

export type enum_veiculos_status = (typeof enum_veiculos_status)[keyof typeof enum_veiculos_status]

}

export type enum_BairroPrioridades_tipo_prioridade = $Enums.enum_BairroPrioridades_tipo_prioridade

export const enum_BairroPrioridades_tipo_prioridade: typeof $Enums.enum_BairroPrioridades_tipo_prioridade

export type enum_Corridas_tipo = $Enums.enum_Corridas_tipo

export const enum_Corridas_tipo: typeof $Enums.enum_Corridas_tipo

export type enum_Denuncia_tipo_alvo = $Enums.enum_Denuncia_tipo_alvo

export const enum_Denuncia_tipo_alvo: typeof $Enums.enum_Denuncia_tipo_alvo

export type enum_Documentos_tipo_documento = $Enums.enum_Documentos_tipo_documento

export const enum_Documentos_tipo_documento: typeof $Enums.enum_Documentos_tipo_documento

export type enum_EmailEnviados_tipo = $Enums.enum_EmailEnviados_tipo

export const enum_EmailEnviados_tipo: typeof $Enums.enum_EmailEnviados_tipo

export type enum_HistoricoIndicacaos_tipo = $Enums.enum_HistoricoIndicacaos_tipo

export const enum_HistoricoIndicacaos_tipo: typeof $Enums.enum_HistoricoIndicacaos_tipo

export type enum_HistoricoSelfies_tipo = $Enums.enum_HistoricoSelfies_tipo

export const enum_HistoricoSelfies_tipo: typeof $Enums.enum_HistoricoSelfies_tipo

export type enum_LogAcessos_tipo_usuario = $Enums.enum_LogAcessos_tipo_usuario

export const enum_LogAcessos_tipo_usuario: typeof $Enums.enum_LogAcessos_tipo_usuario

export type enum_MensagemSuportes_tipo_usuario = $Enums.enum_MensagemSuportes_tipo_usuario

export const enum_MensagemSuportes_tipo_usuario: typeof $Enums.enum_MensagemSuportes_tipo_usuario

export type enum_Recompensas_status = $Enums.enum_Recompensas_status

export const enum_Recompensas_status: typeof $Enums.enum_Recompensas_status

export type enum_Saques_status = $Enums.enum_Saques_status

export const enum_Saques_status: typeof $Enums.enum_Saques_status

export type enum_Saques_tipo = $Enums.enum_Saques_tipo

export const enum_Saques_tipo: typeof $Enums.enum_Saques_tipo

export type enum_Transacaos_tipo = $Enums.enum_Transacaos_tipo

export const enum_Transacaos_tipo: typeof $Enums.enum_Transacaos_tipo

export type enum_Veiculos_categoria = $Enums.enum_Veiculos_categoria

export const enum_Veiculos_categoria: typeof $Enums.enum_Veiculos_categoria

export type enum_agenda_corridas_categoria = $Enums.enum_agenda_corridas_categoria

export const enum_agenda_corridas_categoria: typeof $Enums.enum_agenda_corridas_categoria

export type enum_agenda_corridas_status = $Enums.enum_agenda_corridas_status

export const enum_agenda_corridas_status: typeof $Enums.enum_agenda_corridas_status

export type enum_avaliacoes_tipo = $Enums.enum_avaliacoes_tipo

export const enum_avaliacoes_tipo: typeof $Enums.enum_avaliacoes_tipo

export type enum_bairros_prioridade_tipo_prioridade = $Enums.enum_bairros_prioridade_tipo_prioridade

export const enum_bairros_prioridade_tipo_prioridade: typeof $Enums.enum_bairros_prioridade_tipo_prioridade

export type enum_carteiras_tipo = $Enums.enum_carteiras_tipo

export const enum_carteiras_tipo: typeof $Enums.enum_carteiras_tipo

export type enum_corridas_forma_pagamento = $Enums.enum_corridas_forma_pagamento

export const enum_corridas_forma_pagamento: typeof $Enums.enum_corridas_forma_pagamento

export type enum_corridas_status = $Enums.enum_corridas_status

export const enum_corridas_status: typeof $Enums.enum_corridas_status

export type enum_denuncias_status = $Enums.enum_denuncias_status

export const enum_denuncias_status: typeof $Enums.enum_denuncias_status

export type enum_denuncias_tipo_alvo = $Enums.enum_denuncias_tipo_alvo

export const enum_denuncias_tipo_alvo: typeof $Enums.enum_denuncias_tipo_alvo

export type enum_documentos_status = $Enums.enum_documentos_status

export const enum_documentos_status: typeof $Enums.enum_documentos_status

export type enum_documentos_tipo_documento = $Enums.enum_documentos_tipo_documento

export const enum_documentos_tipo_documento: typeof $Enums.enum_documentos_tipo_documento

export type enum_emails_enviados_status_envio = $Enums.enum_emails_enviados_status_envio

export const enum_emails_enviados_status_envio: typeof $Enums.enum_emails_enviados_status_envio

export type enum_emails_enviados_tipo = $Enums.enum_emails_enviados_tipo

export const enum_emails_enviados_tipo: typeof $Enums.enum_emails_enviados_tipo

export type enum_historico_indicacoes_tipo = $Enums.enum_historico_indicacoes_tipo

export const enum_historico_indicacoes_tipo: typeof $Enums.enum_historico_indicacoes_tipo

export type enum_historico_selfies_resultado = $Enums.enum_historico_selfies_resultado

export const enum_historico_selfies_resultado: typeof $Enums.enum_historico_selfies_resultado

export type enum_historico_selfies_tipo = $Enums.enum_historico_selfies_tipo

export const enum_historico_selfies_tipo: typeof $Enums.enum_historico_selfies_tipo

export type enum_logs_acesso_tipo_usuario = $Enums.enum_logs_acesso_tipo_usuario

export const enum_logs_acesso_tipo_usuario: typeof $Enums.enum_logs_acesso_tipo_usuario

export type enum_mensagens_suporte_status = $Enums.enum_mensagens_suporte_status

export const enum_mensagens_suporte_status: typeof $Enums.enum_mensagens_suporte_status

export type enum_mensagens_suporte_tipo_usuario = $Enums.enum_mensagens_suporte_tipo_usuario

export const enum_mensagens_suporte_tipo_usuario: typeof $Enums.enum_mensagens_suporte_tipo_usuario

export type enum_recompensas_status = $Enums.enum_recompensas_status

export const enum_recompensas_status: typeof $Enums.enum_recompensas_status

export type enum_recompensas_tipo = $Enums.enum_recompensas_tipo

export const enum_recompensas_tipo: typeof $Enums.enum_recompensas_tipo

export type enum_saques_status = $Enums.enum_saques_status

export const enum_saques_status: typeof $Enums.enum_saques_status

export type enum_saques_tipo = $Enums.enum_saques_tipo

export const enum_saques_tipo: typeof $Enums.enum_saques_tipo

export type enum_transacoes_origem = $Enums.enum_transacoes_origem

export const enum_transacoes_origem: typeof $Enums.enum_transacoes_origem

export type enum_transacoes_tipo = $Enums.enum_transacoes_tipo

export const enum_transacoes_tipo: typeof $Enums.enum_transacoes_tipo

export type enum_usuarios_tipo = $Enums.enum_usuarios_tipo

export const enum_usuarios_tipo: typeof $Enums.enum_usuarios_tipo

export type enum_veiculos_categoria = $Enums.enum_veiculos_categoria

export const enum_veiculos_categoria: typeof $Enums.enum_veiculos_categoria

export type enum_veiculos_status = $Enums.enum_veiculos_status

export const enum_veiculos_status: typeof $Enums.enum_veiculos_status

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more BairroPrioridades
 * const bairroPrioridades = await prisma.bairroPrioridades.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more BairroPrioridades
   * const bairroPrioridades = await prisma.bairroPrioridades.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.bairroPrioridades`: Exposes CRUD operations for the **BairroPrioridades** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BairroPrioridades
    * const bairroPrioridades = await prisma.bairroPrioridades.findMany()
    * ```
    */
  get bairroPrioridades(): Prisma.BairroPrioridadesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.carteiras`: Exposes CRUD operations for the **Carteiras** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Carteiras
    * const carteiras = await prisma.carteiras.findMany()
    * ```
    */
  get carteiras(): Prisma.CarteirasDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.codigoIndicacaos`: Exposes CRUD operations for the **CodigoIndicacaos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CodigoIndicacaos
    * const codigoIndicacaos = await prisma.codigoIndicacaos.findMany()
    * ```
    */
  get codigoIndicacaos(): Prisma.CodigoIndicacaosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.corridaAgendadas`: Exposes CRUD operations for the **CorridaAgendadas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CorridaAgendadas
    * const corridaAgendadas = await prisma.corridaAgendadas.findMany()
    * ```
    */
  get corridaAgendadas(): Prisma.CorridaAgendadasDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.corridas`: Exposes CRUD operations for the **Corridas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Corridas
    * const corridas = await prisma.corridas.findMany()
    * ```
    */
  get corridas(): Prisma.CorridasDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.denuncia`: Exposes CRUD operations for the **Denuncia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Denuncias
    * const denuncias = await prisma.denuncia.findMany()
    * ```
    */
  get denuncia(): Prisma.DenunciaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.documentos`: Exposes CRUD operations for the **Documentos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documentos
    * const documentos = await prisma.documentos.findMany()
    * ```
    */
  get documentos(): Prisma.DocumentosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailEnviados`: Exposes CRUD operations for the **EmailEnviados** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailEnviados
    * const emailEnviados = await prisma.emailEnviados.findMany()
    * ```
    */
  get emailEnviados(): Prisma.EmailEnviadosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.historicoIndicacaos`: Exposes CRUD operations for the **HistoricoIndicacaos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HistoricoIndicacaos
    * const historicoIndicacaos = await prisma.historicoIndicacaos.findMany()
    * ```
    */
  get historicoIndicacaos(): Prisma.HistoricoIndicacaosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.historicoSelfies`: Exposes CRUD operations for the **HistoricoSelfies** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HistoricoSelfies
    * const historicoSelfies = await prisma.historicoSelfies.findMany()
    * ```
    */
  get historicoSelfies(): Prisma.HistoricoSelfiesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.identidades`: Exposes CRUD operations for the **Identidades** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Identidades
    * const identidades = await prisma.identidades.findMany()
    * ```
    */
  get identidades(): Prisma.IdentidadesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.indicacaos`: Exposes CRUD operations for the **Indicacaos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Indicacaos
    * const indicacaos = await prisma.indicacaos.findMany()
    * ```
    */
  get indicacaos(): Prisma.IndicacaosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.logAcessos`: Exposes CRUD operations for the **LogAcessos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LogAcessos
    * const logAcessos = await prisma.logAcessos.findMany()
    * ```
    */
  get logAcessos(): Prisma.LogAcessosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mensagemSuportes`: Exposes CRUD operations for the **MensagemSuportes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MensagemSuportes
    * const mensagemSuportes = await prisma.mensagemSuportes.findMany()
    * ```
    */
  get mensagemSuportes(): Prisma.MensagemSuportesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.recompensas`: Exposes CRUD operations for the **Recompensas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Recompensas
    * const recompensas = await prisma.recompensas.findMany()
    * ```
    */
  get recompensas(): Prisma.RecompensasDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.saques`: Exposes CRUD operations for the **Saques** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Saques
    * const saques = await prisma.saques.findMany()
    * ```
    */
  get saques(): Prisma.SaquesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transacaos`: Exposes CRUD operations for the **Transacaos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transacaos
    * const transacaos = await prisma.transacaos.findMany()
    * ```
    */
  get transacaos(): Prisma.TransacaosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.usuarios`: Exposes CRUD operations for the **Usuarios** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuarios.findMany()
    * ```
    */
  get usuarios(): Prisma.UsuariosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.veiculos`: Exposes CRUD operations for the **Veiculos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Veiculos
    * const veiculos = await prisma.veiculos.findMany()
    * ```
    */
  get veiculos(): Prisma.VeiculosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agenda_corridas`: Exposes CRUD operations for the **agenda_corridas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Agenda_corridas
    * const agenda_corridas = await prisma.agenda_corridas.findMany()
    * ```
    */
  get agenda_corridas(): Prisma.agenda_corridasDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.avaliacoes`: Exposes CRUD operations for the **avaliacoes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Avaliacoes
    * const avaliacoes = await prisma.avaliacoes.findMany()
    * ```
    */
  get avaliacoes(): Prisma.avaliacoesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bairros_prioridade`: Exposes CRUD operations for the **bairros_prioridade** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bairros_prioridades
    * const bairros_prioridades = await prisma.bairros_prioridade.findMany()
    * ```
    */
  get bairros_prioridade(): Prisma.bairros_prioridadeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.carteiras`: Exposes CRUD operations for the **carteiras** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Carteiras
    * const carteiras = await prisma.carteiras.findMany()
    * ```
    */
  get carteiras(): Prisma.carteirasDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.corridas`: Exposes CRUD operations for the **corridas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Corridas
    * const corridas = await prisma.corridas.findMany()
    * ```
    */
  get corridas(): Prisma.corridasDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.denuncias`: Exposes CRUD operations for the **denuncias** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Denuncias
    * const denuncias = await prisma.denuncias.findMany()
    * ```
    */
  get denuncias(): Prisma.denunciasDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.documentos`: Exposes CRUD operations for the **documentos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documentos
    * const documentos = await prisma.documentos.findMany()
    * ```
    */
  get documentos(): Prisma.documentosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emails_enviados`: Exposes CRUD operations for the **emails_enviados** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Emails_enviados
    * const emails_enviados = await prisma.emails_enviados.findMany()
    * ```
    */
  get emails_enviados(): Prisma.emails_enviadosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.historico_indicacoes`: Exposes CRUD operations for the **historico_indicacoes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Historico_indicacoes
    * const historico_indicacoes = await prisma.historico_indicacoes.findMany()
    * ```
    */
  get historico_indicacoes(): Prisma.historico_indicacoesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.historico_selfies`: Exposes CRUD operations for the **historico_selfies** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Historico_selfies
    * const historico_selfies = await prisma.historico_selfies.findMany()
    * ```
    */
  get historico_selfies(): Prisma.historico_selfiesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.logs_acesso`: Exposes CRUD operations for the **logs_acesso** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Logs_acessos
    * const logs_acessos = await prisma.logs_acesso.findMany()
    * ```
    */
  get logs_acesso(): Prisma.logs_acessoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mensagens_suporte`: Exposes CRUD operations for the **mensagens_suporte** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mensagens_suportes
    * const mensagens_suportes = await prisma.mensagens_suporte.findMany()
    * ```
    */
  get mensagens_suporte(): Prisma.mensagens_suporteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pagamentos_pessoais`: Exposes CRUD operations for the **pagamentos_pessoais** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pagamentos_pessoais
    * const pagamentos_pessoais = await prisma.pagamentos_pessoais.findMany()
    * ```
    */
  get pagamentos_pessoais(): Prisma.pagamentos_pessoaisDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paradas`: Exposes CRUD operations for the **paradas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Paradas
    * const paradas = await prisma.paradas.findMany()
    * ```
    */
  get paradas(): Prisma.paradasDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.recompensas`: Exposes CRUD operations for the **recompensas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Recompensas
    * const recompensas = await prisma.recompensas.findMany()
    * ```
    */
  get recompensas(): Prisma.recompensasDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.saques`: Exposes CRUD operations for the **saques** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Saques
    * const saques = await prisma.saques.findMany()
    * ```
    */
  get saques(): Prisma.saquesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transacoes`: Exposes CRUD operations for the **transacoes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transacoes
    * const transacoes = await prisma.transacoes.findMany()
    * ```
    */
  get transacoes(): Prisma.transacoesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.usuarios`: Exposes CRUD operations for the **usuarios** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuarios.findMany()
    * ```
    */
  get usuarios(): Prisma.usuariosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.veiculos`: Exposes CRUD operations for the **veiculos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Veiculos
    * const veiculos = await prisma.veiculos.findMany()
    * ```
    */
  get veiculos(): Prisma.veiculosDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.12.0
   * Query Engine version: 8047c96bbd92db98a2abc7c9323ce77c02c89dbc
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    BairroPrioridades: 'BairroPrioridades',
    Carteiras: 'Carteiras',
    CodigoIndicacaos: 'CodigoIndicacaos',
    CorridaAgendadas: 'CorridaAgendadas',
    Corridas: 'Corridas',
    Denuncia: 'Denuncia',
    Documentos: 'Documentos',
    EmailEnviados: 'EmailEnviados',
    HistoricoIndicacaos: 'HistoricoIndicacaos',
    HistoricoSelfies: 'HistoricoSelfies',
    Identidades: 'Identidades',
    Indicacaos: 'Indicacaos',
    LogAcessos: 'LogAcessos',
    MensagemSuportes: 'MensagemSuportes',
    Recompensas: 'Recompensas',
    Saques: 'Saques',
    Transacaos: 'Transacaos',
    Usuarios: 'Usuarios',
    Veiculos: 'Veiculos',
    agenda_corridas: 'agenda_corridas',
    avaliacoes: 'avaliacoes',
    bairros_prioridade: 'bairros_prioridade',
    carteiras: 'carteiras',
    corridas: 'corridas',
    denuncias: 'denuncias',
    documentos: 'documentos',
    emails_enviados: 'emails_enviados',
    historico_indicacoes: 'historico_indicacoes',
    historico_selfies: 'historico_selfies',
    logs_acesso: 'logs_acesso',
    mensagens_suporte: 'mensagens_suporte',
    pagamentos_pessoais: 'pagamentos_pessoais',
    paradas: 'paradas',
    recompensas: 'recompensas',
    saques: 'saques',
    transacoes: 'transacoes',
    usuarios: 'usuarios',
    veiculos: 'veiculos'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "bairroPrioridades" | "carteiras" | "codigoIndicacaos" | "corridaAgendadas" | "corridas" | "denuncia" | "documentos" | "emailEnviados" | "historicoIndicacaos" | "historicoSelfies" | "identidades" | "indicacaos" | "logAcessos" | "mensagemSuportes" | "recompensas" | "saques" | "transacaos" | "usuarios" | "veiculos" | "agenda_corridas" | "avaliacoes" | "bairros_prioridade" | "carteiras" | "corridas" | "denuncias" | "documentos" | "emails_enviados" | "historico_indicacoes" | "historico_selfies" | "logs_acesso" | "mensagens_suporte" | "pagamentos_pessoais" | "paradas" | "recompensas" | "saques" | "transacoes" | "usuarios" | "veiculos"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      BairroPrioridades: {
        payload: Prisma.$BairroPrioridadesPayload<ExtArgs>
        fields: Prisma.BairroPrioridadesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BairroPrioridadesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BairroPrioridadesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BairroPrioridadesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BairroPrioridadesPayload>
          }
          findFirst: {
            args: Prisma.BairroPrioridadesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BairroPrioridadesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BairroPrioridadesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BairroPrioridadesPayload>
          }
          findMany: {
            args: Prisma.BairroPrioridadesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BairroPrioridadesPayload>[]
          }
          create: {
            args: Prisma.BairroPrioridadesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BairroPrioridadesPayload>
          }
          createMany: {
            args: Prisma.BairroPrioridadesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BairroPrioridadesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BairroPrioridadesPayload>[]
          }
          delete: {
            args: Prisma.BairroPrioridadesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BairroPrioridadesPayload>
          }
          update: {
            args: Prisma.BairroPrioridadesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BairroPrioridadesPayload>
          }
          deleteMany: {
            args: Prisma.BairroPrioridadesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BairroPrioridadesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BairroPrioridadesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BairroPrioridadesPayload>[]
          }
          upsert: {
            args: Prisma.BairroPrioridadesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BairroPrioridadesPayload>
          }
          aggregate: {
            args: Prisma.BairroPrioridadesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBairroPrioridades>
          }
          groupBy: {
            args: Prisma.BairroPrioridadesGroupByArgs<ExtArgs>
            result: $Utils.Optional<BairroPrioridadesGroupByOutputType>[]
          }
          count: {
            args: Prisma.BairroPrioridadesCountArgs<ExtArgs>
            result: $Utils.Optional<BairroPrioridadesCountAggregateOutputType> | number
          }
        }
      }
      Carteiras: {
        payload: Prisma.$CarteirasPayload<ExtArgs>
        fields: Prisma.CarteirasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CarteirasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarteirasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CarteirasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarteirasPayload>
          }
          findFirst: {
            args: Prisma.CarteirasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarteirasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CarteirasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarteirasPayload>
          }
          findMany: {
            args: Prisma.CarteirasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarteirasPayload>[]
          }
          create: {
            args: Prisma.CarteirasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarteirasPayload>
          }
          createMany: {
            args: Prisma.CarteirasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CarteirasCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarteirasPayload>[]
          }
          delete: {
            args: Prisma.CarteirasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarteirasPayload>
          }
          update: {
            args: Prisma.CarteirasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarteirasPayload>
          }
          deleteMany: {
            args: Prisma.CarteirasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CarteirasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CarteirasUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarteirasPayload>[]
          }
          upsert: {
            args: Prisma.CarteirasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarteirasPayload>
          }
          aggregate: {
            args: Prisma.CarteirasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCarteiras>
          }
          groupBy: {
            args: Prisma.CarteirasGroupByArgs<ExtArgs>
            result: $Utils.Optional<CarteirasGroupByOutputType>[]
          }
          count: {
            args: Prisma.CarteirasCountArgs<ExtArgs>
            result: $Utils.Optional<CarteirasCountAggregateOutputType> | number
          }
        }
      }
      CodigoIndicacaos: {
        payload: Prisma.$CodigoIndicacaosPayload<ExtArgs>
        fields: Prisma.CodigoIndicacaosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CodigoIndicacaosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodigoIndicacaosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CodigoIndicacaosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodigoIndicacaosPayload>
          }
          findFirst: {
            args: Prisma.CodigoIndicacaosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodigoIndicacaosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CodigoIndicacaosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodigoIndicacaosPayload>
          }
          findMany: {
            args: Prisma.CodigoIndicacaosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodigoIndicacaosPayload>[]
          }
          create: {
            args: Prisma.CodigoIndicacaosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodigoIndicacaosPayload>
          }
          createMany: {
            args: Prisma.CodigoIndicacaosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CodigoIndicacaosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodigoIndicacaosPayload>[]
          }
          delete: {
            args: Prisma.CodigoIndicacaosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodigoIndicacaosPayload>
          }
          update: {
            args: Prisma.CodigoIndicacaosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodigoIndicacaosPayload>
          }
          deleteMany: {
            args: Prisma.CodigoIndicacaosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CodigoIndicacaosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CodigoIndicacaosUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodigoIndicacaosPayload>[]
          }
          upsert: {
            args: Prisma.CodigoIndicacaosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodigoIndicacaosPayload>
          }
          aggregate: {
            args: Prisma.CodigoIndicacaosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCodigoIndicacaos>
          }
          groupBy: {
            args: Prisma.CodigoIndicacaosGroupByArgs<ExtArgs>
            result: $Utils.Optional<CodigoIndicacaosGroupByOutputType>[]
          }
          count: {
            args: Prisma.CodigoIndicacaosCountArgs<ExtArgs>
            result: $Utils.Optional<CodigoIndicacaosCountAggregateOutputType> | number
          }
        }
      }
      CorridaAgendadas: {
        payload: Prisma.$CorridaAgendadasPayload<ExtArgs>
        fields: Prisma.CorridaAgendadasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CorridaAgendadasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorridaAgendadasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CorridaAgendadasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorridaAgendadasPayload>
          }
          findFirst: {
            args: Prisma.CorridaAgendadasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorridaAgendadasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CorridaAgendadasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorridaAgendadasPayload>
          }
          findMany: {
            args: Prisma.CorridaAgendadasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorridaAgendadasPayload>[]
          }
          create: {
            args: Prisma.CorridaAgendadasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorridaAgendadasPayload>
          }
          createMany: {
            args: Prisma.CorridaAgendadasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CorridaAgendadasCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorridaAgendadasPayload>[]
          }
          delete: {
            args: Prisma.CorridaAgendadasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorridaAgendadasPayload>
          }
          update: {
            args: Prisma.CorridaAgendadasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorridaAgendadasPayload>
          }
          deleteMany: {
            args: Prisma.CorridaAgendadasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CorridaAgendadasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CorridaAgendadasUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorridaAgendadasPayload>[]
          }
          upsert: {
            args: Prisma.CorridaAgendadasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorridaAgendadasPayload>
          }
          aggregate: {
            args: Prisma.CorridaAgendadasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCorridaAgendadas>
          }
          groupBy: {
            args: Prisma.CorridaAgendadasGroupByArgs<ExtArgs>
            result: $Utils.Optional<CorridaAgendadasGroupByOutputType>[]
          }
          count: {
            args: Prisma.CorridaAgendadasCountArgs<ExtArgs>
            result: $Utils.Optional<CorridaAgendadasCountAggregateOutputType> | number
          }
        }
      }
      Corridas: {
        payload: Prisma.$CorridasPayload<ExtArgs>
        fields: Prisma.CorridasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CorridasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorridasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CorridasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorridasPayload>
          }
          findFirst: {
            args: Prisma.CorridasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorridasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CorridasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorridasPayload>
          }
          findMany: {
            args: Prisma.CorridasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorridasPayload>[]
          }
          create: {
            args: Prisma.CorridasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorridasPayload>
          }
          createMany: {
            args: Prisma.CorridasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CorridasCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorridasPayload>[]
          }
          delete: {
            args: Prisma.CorridasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorridasPayload>
          }
          update: {
            args: Prisma.CorridasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorridasPayload>
          }
          deleteMany: {
            args: Prisma.CorridasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CorridasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CorridasUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorridasPayload>[]
          }
          upsert: {
            args: Prisma.CorridasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorridasPayload>
          }
          aggregate: {
            args: Prisma.CorridasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCorridas>
          }
          groupBy: {
            args: Prisma.CorridasGroupByArgs<ExtArgs>
            result: $Utils.Optional<CorridasGroupByOutputType>[]
          }
          count: {
            args: Prisma.CorridasCountArgs<ExtArgs>
            result: $Utils.Optional<CorridasCountAggregateOutputType> | number
          }
        }
      }
      Denuncia: {
        payload: Prisma.$DenunciaPayload<ExtArgs>
        fields: Prisma.DenunciaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DenunciaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DenunciaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DenunciaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DenunciaPayload>
          }
          findFirst: {
            args: Prisma.DenunciaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DenunciaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DenunciaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DenunciaPayload>
          }
          findMany: {
            args: Prisma.DenunciaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DenunciaPayload>[]
          }
          create: {
            args: Prisma.DenunciaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DenunciaPayload>
          }
          createMany: {
            args: Prisma.DenunciaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DenunciaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DenunciaPayload>[]
          }
          delete: {
            args: Prisma.DenunciaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DenunciaPayload>
          }
          update: {
            args: Prisma.DenunciaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DenunciaPayload>
          }
          deleteMany: {
            args: Prisma.DenunciaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DenunciaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DenunciaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DenunciaPayload>[]
          }
          upsert: {
            args: Prisma.DenunciaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DenunciaPayload>
          }
          aggregate: {
            args: Prisma.DenunciaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDenuncia>
          }
          groupBy: {
            args: Prisma.DenunciaGroupByArgs<ExtArgs>
            result: $Utils.Optional<DenunciaGroupByOutputType>[]
          }
          count: {
            args: Prisma.DenunciaCountArgs<ExtArgs>
            result: $Utils.Optional<DenunciaCountAggregateOutputType> | number
          }
        }
      }
      Documentos: {
        payload: Prisma.$DocumentosPayload<ExtArgs>
        fields: Prisma.DocumentosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentosPayload>
          }
          findFirst: {
            args: Prisma.DocumentosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentosPayload>
          }
          findMany: {
            args: Prisma.DocumentosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentosPayload>[]
          }
          create: {
            args: Prisma.DocumentosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentosPayload>
          }
          createMany: {
            args: Prisma.DocumentosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentosPayload>[]
          }
          delete: {
            args: Prisma.DocumentosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentosPayload>
          }
          update: {
            args: Prisma.DocumentosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentosPayload>
          }
          deleteMany: {
            args: Prisma.DocumentosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentosUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentosPayload>[]
          }
          upsert: {
            args: Prisma.DocumentosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentosPayload>
          }
          aggregate: {
            args: Prisma.DocumentosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocumentos>
          }
          groupBy: {
            args: Prisma.DocumentosGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentosGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentosCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentosCountAggregateOutputType> | number
          }
        }
      }
      EmailEnviados: {
        payload: Prisma.$EmailEnviadosPayload<ExtArgs>
        fields: Prisma.EmailEnviadosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailEnviadosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailEnviadosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailEnviadosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailEnviadosPayload>
          }
          findFirst: {
            args: Prisma.EmailEnviadosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailEnviadosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailEnviadosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailEnviadosPayload>
          }
          findMany: {
            args: Prisma.EmailEnviadosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailEnviadosPayload>[]
          }
          create: {
            args: Prisma.EmailEnviadosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailEnviadosPayload>
          }
          createMany: {
            args: Prisma.EmailEnviadosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailEnviadosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailEnviadosPayload>[]
          }
          delete: {
            args: Prisma.EmailEnviadosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailEnviadosPayload>
          }
          update: {
            args: Prisma.EmailEnviadosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailEnviadosPayload>
          }
          deleteMany: {
            args: Prisma.EmailEnviadosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailEnviadosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailEnviadosUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailEnviadosPayload>[]
          }
          upsert: {
            args: Prisma.EmailEnviadosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailEnviadosPayload>
          }
          aggregate: {
            args: Prisma.EmailEnviadosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailEnviados>
          }
          groupBy: {
            args: Prisma.EmailEnviadosGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailEnviadosGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailEnviadosCountArgs<ExtArgs>
            result: $Utils.Optional<EmailEnviadosCountAggregateOutputType> | number
          }
        }
      }
      HistoricoIndicacaos: {
        payload: Prisma.$HistoricoIndicacaosPayload<ExtArgs>
        fields: Prisma.HistoricoIndicacaosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HistoricoIndicacaosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoricoIndicacaosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HistoricoIndicacaosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoricoIndicacaosPayload>
          }
          findFirst: {
            args: Prisma.HistoricoIndicacaosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoricoIndicacaosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HistoricoIndicacaosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoricoIndicacaosPayload>
          }
          findMany: {
            args: Prisma.HistoricoIndicacaosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoricoIndicacaosPayload>[]
          }
          create: {
            args: Prisma.HistoricoIndicacaosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoricoIndicacaosPayload>
          }
          createMany: {
            args: Prisma.HistoricoIndicacaosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HistoricoIndicacaosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoricoIndicacaosPayload>[]
          }
          delete: {
            args: Prisma.HistoricoIndicacaosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoricoIndicacaosPayload>
          }
          update: {
            args: Prisma.HistoricoIndicacaosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoricoIndicacaosPayload>
          }
          deleteMany: {
            args: Prisma.HistoricoIndicacaosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HistoricoIndicacaosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HistoricoIndicacaosUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoricoIndicacaosPayload>[]
          }
          upsert: {
            args: Prisma.HistoricoIndicacaosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoricoIndicacaosPayload>
          }
          aggregate: {
            args: Prisma.HistoricoIndicacaosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHistoricoIndicacaos>
          }
          groupBy: {
            args: Prisma.HistoricoIndicacaosGroupByArgs<ExtArgs>
            result: $Utils.Optional<HistoricoIndicacaosGroupByOutputType>[]
          }
          count: {
            args: Prisma.HistoricoIndicacaosCountArgs<ExtArgs>
            result: $Utils.Optional<HistoricoIndicacaosCountAggregateOutputType> | number
          }
        }
      }
      HistoricoSelfies: {
        payload: Prisma.$HistoricoSelfiesPayload<ExtArgs>
        fields: Prisma.HistoricoSelfiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HistoricoSelfiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoricoSelfiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HistoricoSelfiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoricoSelfiesPayload>
          }
          findFirst: {
            args: Prisma.HistoricoSelfiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoricoSelfiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HistoricoSelfiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoricoSelfiesPayload>
          }
          findMany: {
            args: Prisma.HistoricoSelfiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoricoSelfiesPayload>[]
          }
          create: {
            args: Prisma.HistoricoSelfiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoricoSelfiesPayload>
          }
          createMany: {
            args: Prisma.HistoricoSelfiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HistoricoSelfiesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoricoSelfiesPayload>[]
          }
          delete: {
            args: Prisma.HistoricoSelfiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoricoSelfiesPayload>
          }
          update: {
            args: Prisma.HistoricoSelfiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoricoSelfiesPayload>
          }
          deleteMany: {
            args: Prisma.HistoricoSelfiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HistoricoSelfiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HistoricoSelfiesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoricoSelfiesPayload>[]
          }
          upsert: {
            args: Prisma.HistoricoSelfiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoricoSelfiesPayload>
          }
          aggregate: {
            args: Prisma.HistoricoSelfiesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHistoricoSelfies>
          }
          groupBy: {
            args: Prisma.HistoricoSelfiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<HistoricoSelfiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.HistoricoSelfiesCountArgs<ExtArgs>
            result: $Utils.Optional<HistoricoSelfiesCountAggregateOutputType> | number
          }
        }
      }
      Identidades: {
        payload: Prisma.$IdentidadesPayload<ExtArgs>
        fields: Prisma.IdentidadesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IdentidadesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentidadesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IdentidadesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentidadesPayload>
          }
          findFirst: {
            args: Prisma.IdentidadesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentidadesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IdentidadesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentidadesPayload>
          }
          findMany: {
            args: Prisma.IdentidadesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentidadesPayload>[]
          }
          create: {
            args: Prisma.IdentidadesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentidadesPayload>
          }
          createMany: {
            args: Prisma.IdentidadesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IdentidadesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentidadesPayload>[]
          }
          delete: {
            args: Prisma.IdentidadesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentidadesPayload>
          }
          update: {
            args: Prisma.IdentidadesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentidadesPayload>
          }
          deleteMany: {
            args: Prisma.IdentidadesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IdentidadesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IdentidadesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentidadesPayload>[]
          }
          upsert: {
            args: Prisma.IdentidadesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentidadesPayload>
          }
          aggregate: {
            args: Prisma.IdentidadesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIdentidades>
          }
          groupBy: {
            args: Prisma.IdentidadesGroupByArgs<ExtArgs>
            result: $Utils.Optional<IdentidadesGroupByOutputType>[]
          }
          count: {
            args: Prisma.IdentidadesCountArgs<ExtArgs>
            result: $Utils.Optional<IdentidadesCountAggregateOutputType> | number
          }
        }
      }
      Indicacaos: {
        payload: Prisma.$IndicacaosPayload<ExtArgs>
        fields: Prisma.IndicacaosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IndicacaosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicacaosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IndicacaosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicacaosPayload>
          }
          findFirst: {
            args: Prisma.IndicacaosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicacaosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IndicacaosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicacaosPayload>
          }
          findMany: {
            args: Prisma.IndicacaosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicacaosPayload>[]
          }
          create: {
            args: Prisma.IndicacaosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicacaosPayload>
          }
          createMany: {
            args: Prisma.IndicacaosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IndicacaosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicacaosPayload>[]
          }
          delete: {
            args: Prisma.IndicacaosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicacaosPayload>
          }
          update: {
            args: Prisma.IndicacaosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicacaosPayload>
          }
          deleteMany: {
            args: Prisma.IndicacaosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IndicacaosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IndicacaosUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicacaosPayload>[]
          }
          upsert: {
            args: Prisma.IndicacaosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicacaosPayload>
          }
          aggregate: {
            args: Prisma.IndicacaosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIndicacaos>
          }
          groupBy: {
            args: Prisma.IndicacaosGroupByArgs<ExtArgs>
            result: $Utils.Optional<IndicacaosGroupByOutputType>[]
          }
          count: {
            args: Prisma.IndicacaosCountArgs<ExtArgs>
            result: $Utils.Optional<IndicacaosCountAggregateOutputType> | number
          }
        }
      }
      LogAcessos: {
        payload: Prisma.$LogAcessosPayload<ExtArgs>
        fields: Prisma.LogAcessosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogAcessosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogAcessosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogAcessosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogAcessosPayload>
          }
          findFirst: {
            args: Prisma.LogAcessosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogAcessosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogAcessosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogAcessosPayload>
          }
          findMany: {
            args: Prisma.LogAcessosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogAcessosPayload>[]
          }
          create: {
            args: Prisma.LogAcessosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogAcessosPayload>
          }
          createMany: {
            args: Prisma.LogAcessosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LogAcessosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogAcessosPayload>[]
          }
          delete: {
            args: Prisma.LogAcessosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogAcessosPayload>
          }
          update: {
            args: Prisma.LogAcessosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogAcessosPayload>
          }
          deleteMany: {
            args: Prisma.LogAcessosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LogAcessosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LogAcessosUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogAcessosPayload>[]
          }
          upsert: {
            args: Prisma.LogAcessosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogAcessosPayload>
          }
          aggregate: {
            args: Prisma.LogAcessosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLogAcessos>
          }
          groupBy: {
            args: Prisma.LogAcessosGroupByArgs<ExtArgs>
            result: $Utils.Optional<LogAcessosGroupByOutputType>[]
          }
          count: {
            args: Prisma.LogAcessosCountArgs<ExtArgs>
            result: $Utils.Optional<LogAcessosCountAggregateOutputType> | number
          }
        }
      }
      MensagemSuportes: {
        payload: Prisma.$MensagemSuportesPayload<ExtArgs>
        fields: Prisma.MensagemSuportesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MensagemSuportesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MensagemSuportesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MensagemSuportesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MensagemSuportesPayload>
          }
          findFirst: {
            args: Prisma.MensagemSuportesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MensagemSuportesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MensagemSuportesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MensagemSuportesPayload>
          }
          findMany: {
            args: Prisma.MensagemSuportesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MensagemSuportesPayload>[]
          }
          create: {
            args: Prisma.MensagemSuportesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MensagemSuportesPayload>
          }
          createMany: {
            args: Prisma.MensagemSuportesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MensagemSuportesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MensagemSuportesPayload>[]
          }
          delete: {
            args: Prisma.MensagemSuportesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MensagemSuportesPayload>
          }
          update: {
            args: Prisma.MensagemSuportesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MensagemSuportesPayload>
          }
          deleteMany: {
            args: Prisma.MensagemSuportesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MensagemSuportesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MensagemSuportesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MensagemSuportesPayload>[]
          }
          upsert: {
            args: Prisma.MensagemSuportesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MensagemSuportesPayload>
          }
          aggregate: {
            args: Prisma.MensagemSuportesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMensagemSuportes>
          }
          groupBy: {
            args: Prisma.MensagemSuportesGroupByArgs<ExtArgs>
            result: $Utils.Optional<MensagemSuportesGroupByOutputType>[]
          }
          count: {
            args: Prisma.MensagemSuportesCountArgs<ExtArgs>
            result: $Utils.Optional<MensagemSuportesCountAggregateOutputType> | number
          }
        }
      }
      Recompensas: {
        payload: Prisma.$RecompensasPayload<ExtArgs>
        fields: Prisma.RecompensasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecompensasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecompensasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecompensasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecompensasPayload>
          }
          findFirst: {
            args: Prisma.RecompensasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecompensasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecompensasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecompensasPayload>
          }
          findMany: {
            args: Prisma.RecompensasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecompensasPayload>[]
          }
          create: {
            args: Prisma.RecompensasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecompensasPayload>
          }
          createMany: {
            args: Prisma.RecompensasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecompensasCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecompensasPayload>[]
          }
          delete: {
            args: Prisma.RecompensasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecompensasPayload>
          }
          update: {
            args: Prisma.RecompensasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecompensasPayload>
          }
          deleteMany: {
            args: Prisma.RecompensasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecompensasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RecompensasUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecompensasPayload>[]
          }
          upsert: {
            args: Prisma.RecompensasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecompensasPayload>
          }
          aggregate: {
            args: Prisma.RecompensasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecompensas>
          }
          groupBy: {
            args: Prisma.RecompensasGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecompensasGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecompensasCountArgs<ExtArgs>
            result: $Utils.Optional<RecompensasCountAggregateOutputType> | number
          }
        }
      }
      Saques: {
        payload: Prisma.$SaquesPayload<ExtArgs>
        fields: Prisma.SaquesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SaquesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaquesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SaquesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaquesPayload>
          }
          findFirst: {
            args: Prisma.SaquesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaquesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SaquesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaquesPayload>
          }
          findMany: {
            args: Prisma.SaquesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaquesPayload>[]
          }
          create: {
            args: Prisma.SaquesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaquesPayload>
          }
          createMany: {
            args: Prisma.SaquesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SaquesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaquesPayload>[]
          }
          delete: {
            args: Prisma.SaquesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaquesPayload>
          }
          update: {
            args: Prisma.SaquesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaquesPayload>
          }
          deleteMany: {
            args: Prisma.SaquesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SaquesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SaquesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaquesPayload>[]
          }
          upsert: {
            args: Prisma.SaquesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaquesPayload>
          }
          aggregate: {
            args: Prisma.SaquesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSaques>
          }
          groupBy: {
            args: Prisma.SaquesGroupByArgs<ExtArgs>
            result: $Utils.Optional<SaquesGroupByOutputType>[]
          }
          count: {
            args: Prisma.SaquesCountArgs<ExtArgs>
            result: $Utils.Optional<SaquesCountAggregateOutputType> | number
          }
        }
      }
      Transacaos: {
        payload: Prisma.$TransacaosPayload<ExtArgs>
        fields: Prisma.TransacaosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransacaosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransacaosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransacaosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransacaosPayload>
          }
          findFirst: {
            args: Prisma.TransacaosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransacaosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransacaosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransacaosPayload>
          }
          findMany: {
            args: Prisma.TransacaosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransacaosPayload>[]
          }
          create: {
            args: Prisma.TransacaosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransacaosPayload>
          }
          createMany: {
            args: Prisma.TransacaosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransacaosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransacaosPayload>[]
          }
          delete: {
            args: Prisma.TransacaosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransacaosPayload>
          }
          update: {
            args: Prisma.TransacaosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransacaosPayload>
          }
          deleteMany: {
            args: Prisma.TransacaosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransacaosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransacaosUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransacaosPayload>[]
          }
          upsert: {
            args: Prisma.TransacaosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransacaosPayload>
          }
          aggregate: {
            args: Prisma.TransacaosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransacaos>
          }
          groupBy: {
            args: Prisma.TransacaosGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransacaosGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransacaosCountArgs<ExtArgs>
            result: $Utils.Optional<TransacaosCountAggregateOutputType> | number
          }
        }
      }
      Usuarios: {
        payload: Prisma.$UsuariosPayload<ExtArgs>
        fields: Prisma.UsuariosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsuariosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsuariosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload>
          }
          findFirst: {
            args: Prisma.UsuariosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsuariosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload>
          }
          findMany: {
            args: Prisma.UsuariosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload>[]
          }
          create: {
            args: Prisma.UsuariosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload>
          }
          createMany: {
            args: Prisma.UsuariosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsuariosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload>[]
          }
          delete: {
            args: Prisma.UsuariosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload>
          }
          update: {
            args: Prisma.UsuariosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload>
          }
          deleteMany: {
            args: Prisma.UsuariosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsuariosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UsuariosUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload>[]
          }
          upsert: {
            args: Prisma.UsuariosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload>
          }
          aggregate: {
            args: Prisma.UsuariosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuarios>
          }
          groupBy: {
            args: Prisma.UsuariosGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuariosGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsuariosCountArgs<ExtArgs>
            result: $Utils.Optional<UsuariosCountAggregateOutputType> | number
          }
        }
      }
      Veiculos: {
        payload: Prisma.$VeiculosPayload<ExtArgs>
        fields: Prisma.VeiculosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VeiculosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VeiculosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VeiculosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VeiculosPayload>
          }
          findFirst: {
            args: Prisma.VeiculosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VeiculosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VeiculosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VeiculosPayload>
          }
          findMany: {
            args: Prisma.VeiculosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VeiculosPayload>[]
          }
          create: {
            args: Prisma.VeiculosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VeiculosPayload>
          }
          createMany: {
            args: Prisma.VeiculosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VeiculosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VeiculosPayload>[]
          }
          delete: {
            args: Prisma.VeiculosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VeiculosPayload>
          }
          update: {
            args: Prisma.VeiculosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VeiculosPayload>
          }
          deleteMany: {
            args: Prisma.VeiculosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VeiculosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VeiculosUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VeiculosPayload>[]
          }
          upsert: {
            args: Prisma.VeiculosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VeiculosPayload>
          }
          aggregate: {
            args: Prisma.VeiculosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVeiculos>
          }
          groupBy: {
            args: Prisma.VeiculosGroupByArgs<ExtArgs>
            result: $Utils.Optional<VeiculosGroupByOutputType>[]
          }
          count: {
            args: Prisma.VeiculosCountArgs<ExtArgs>
            result: $Utils.Optional<VeiculosCountAggregateOutputType> | number
          }
        }
      }
      agenda_corridas: {
        payload: Prisma.$agenda_corridasPayload<ExtArgs>
        fields: Prisma.agenda_corridasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.agenda_corridasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agenda_corridasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.agenda_corridasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agenda_corridasPayload>
          }
          findFirst: {
            args: Prisma.agenda_corridasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agenda_corridasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.agenda_corridasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agenda_corridasPayload>
          }
          findMany: {
            args: Prisma.agenda_corridasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agenda_corridasPayload>[]
          }
          create: {
            args: Prisma.agenda_corridasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agenda_corridasPayload>
          }
          createMany: {
            args: Prisma.agenda_corridasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.agenda_corridasCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agenda_corridasPayload>[]
          }
          delete: {
            args: Prisma.agenda_corridasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agenda_corridasPayload>
          }
          update: {
            args: Prisma.agenda_corridasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agenda_corridasPayload>
          }
          deleteMany: {
            args: Prisma.agenda_corridasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.agenda_corridasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.agenda_corridasUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agenda_corridasPayload>[]
          }
          upsert: {
            args: Prisma.agenda_corridasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agenda_corridasPayload>
          }
          aggregate: {
            args: Prisma.Agenda_corridasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgenda_corridas>
          }
          groupBy: {
            args: Prisma.agenda_corridasGroupByArgs<ExtArgs>
            result: $Utils.Optional<Agenda_corridasGroupByOutputType>[]
          }
          count: {
            args: Prisma.agenda_corridasCountArgs<ExtArgs>
            result: $Utils.Optional<Agenda_corridasCountAggregateOutputType> | number
          }
        }
      }
      avaliacoes: {
        payload: Prisma.$avaliacoesPayload<ExtArgs>
        fields: Prisma.avaliacoesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.avaliacoesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$avaliacoesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.avaliacoesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$avaliacoesPayload>
          }
          findFirst: {
            args: Prisma.avaliacoesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$avaliacoesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.avaliacoesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$avaliacoesPayload>
          }
          findMany: {
            args: Prisma.avaliacoesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$avaliacoesPayload>[]
          }
          create: {
            args: Prisma.avaliacoesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$avaliacoesPayload>
          }
          createMany: {
            args: Prisma.avaliacoesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.avaliacoesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$avaliacoesPayload>[]
          }
          delete: {
            args: Prisma.avaliacoesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$avaliacoesPayload>
          }
          update: {
            args: Prisma.avaliacoesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$avaliacoesPayload>
          }
          deleteMany: {
            args: Prisma.avaliacoesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.avaliacoesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.avaliacoesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$avaliacoesPayload>[]
          }
          upsert: {
            args: Prisma.avaliacoesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$avaliacoesPayload>
          }
          aggregate: {
            args: Prisma.AvaliacoesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAvaliacoes>
          }
          groupBy: {
            args: Prisma.avaliacoesGroupByArgs<ExtArgs>
            result: $Utils.Optional<AvaliacoesGroupByOutputType>[]
          }
          count: {
            args: Prisma.avaliacoesCountArgs<ExtArgs>
            result: $Utils.Optional<AvaliacoesCountAggregateOutputType> | number
          }
        }
      }
      bairros_prioridade: {
        payload: Prisma.$bairros_prioridadePayload<ExtArgs>
        fields: Prisma.bairros_prioridadeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bairros_prioridadeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bairros_prioridadePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bairros_prioridadeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bairros_prioridadePayload>
          }
          findFirst: {
            args: Prisma.bairros_prioridadeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bairros_prioridadePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bairros_prioridadeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bairros_prioridadePayload>
          }
          findMany: {
            args: Prisma.bairros_prioridadeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bairros_prioridadePayload>[]
          }
          create: {
            args: Prisma.bairros_prioridadeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bairros_prioridadePayload>
          }
          createMany: {
            args: Prisma.bairros_prioridadeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.bairros_prioridadeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bairros_prioridadePayload>[]
          }
          delete: {
            args: Prisma.bairros_prioridadeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bairros_prioridadePayload>
          }
          update: {
            args: Prisma.bairros_prioridadeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bairros_prioridadePayload>
          }
          deleteMany: {
            args: Prisma.bairros_prioridadeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.bairros_prioridadeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.bairros_prioridadeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bairros_prioridadePayload>[]
          }
          upsert: {
            args: Prisma.bairros_prioridadeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bairros_prioridadePayload>
          }
          aggregate: {
            args: Prisma.Bairros_prioridadeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBairros_prioridade>
          }
          groupBy: {
            args: Prisma.bairros_prioridadeGroupByArgs<ExtArgs>
            result: $Utils.Optional<Bairros_prioridadeGroupByOutputType>[]
          }
          count: {
            args: Prisma.bairros_prioridadeCountArgs<ExtArgs>
            result: $Utils.Optional<Bairros_prioridadeCountAggregateOutputType> | number
          }
        }
      }
      carteiras: {
        payload: Prisma.$carteirasPayload<ExtArgs>
        fields: Prisma.carteirasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.carteirasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$carteirasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.carteirasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$carteirasPayload>
          }
          findFirst: {
            args: Prisma.carteirasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$carteirasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.carteirasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$carteirasPayload>
          }
          findMany: {
            args: Prisma.carteirasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$carteirasPayload>[]
          }
          create: {
            args: Prisma.carteirasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$carteirasPayload>
          }
          createMany: {
            args: Prisma.carteirasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.carteirasCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$carteirasPayload>[]
          }
          delete: {
            args: Prisma.carteirasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$carteirasPayload>
          }
          update: {
            args: Prisma.carteirasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$carteirasPayload>
          }
          deleteMany: {
            args: Prisma.carteirasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.carteirasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.carteirasUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$carteirasPayload>[]
          }
          upsert: {
            args: Prisma.carteirasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$carteirasPayload>
          }
          aggregate: {
            args: Prisma.CarteirasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCarteiras>
          }
          groupBy: {
            args: Prisma.carteirasGroupByArgs<ExtArgs>
            result: $Utils.Optional<CarteirasGroupByOutputType>[]
          }
          count: {
            args: Prisma.carteirasCountArgs<ExtArgs>
            result: $Utils.Optional<CarteirasCountAggregateOutputType> | number
          }
        }
      }
      corridas: {
        payload: Prisma.$corridasPayload<ExtArgs>
        fields: Prisma.corridasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.corridasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$corridasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.corridasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$corridasPayload>
          }
          findFirst: {
            args: Prisma.corridasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$corridasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.corridasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$corridasPayload>
          }
          findMany: {
            args: Prisma.corridasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$corridasPayload>[]
          }
          create: {
            args: Prisma.corridasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$corridasPayload>
          }
          createMany: {
            args: Prisma.corridasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.corridasCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$corridasPayload>[]
          }
          delete: {
            args: Prisma.corridasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$corridasPayload>
          }
          update: {
            args: Prisma.corridasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$corridasPayload>
          }
          deleteMany: {
            args: Prisma.corridasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.corridasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.corridasUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$corridasPayload>[]
          }
          upsert: {
            args: Prisma.corridasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$corridasPayload>
          }
          aggregate: {
            args: Prisma.CorridasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCorridas>
          }
          groupBy: {
            args: Prisma.corridasGroupByArgs<ExtArgs>
            result: $Utils.Optional<CorridasGroupByOutputType>[]
          }
          count: {
            args: Prisma.corridasCountArgs<ExtArgs>
            result: $Utils.Optional<CorridasCountAggregateOutputType> | number
          }
        }
      }
      denuncias: {
        payload: Prisma.$denunciasPayload<ExtArgs>
        fields: Prisma.denunciasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.denunciasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$denunciasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.denunciasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$denunciasPayload>
          }
          findFirst: {
            args: Prisma.denunciasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$denunciasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.denunciasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$denunciasPayload>
          }
          findMany: {
            args: Prisma.denunciasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$denunciasPayload>[]
          }
          create: {
            args: Prisma.denunciasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$denunciasPayload>
          }
          createMany: {
            args: Prisma.denunciasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.denunciasCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$denunciasPayload>[]
          }
          delete: {
            args: Prisma.denunciasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$denunciasPayload>
          }
          update: {
            args: Prisma.denunciasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$denunciasPayload>
          }
          deleteMany: {
            args: Prisma.denunciasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.denunciasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.denunciasUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$denunciasPayload>[]
          }
          upsert: {
            args: Prisma.denunciasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$denunciasPayload>
          }
          aggregate: {
            args: Prisma.DenunciasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDenuncias>
          }
          groupBy: {
            args: Prisma.denunciasGroupByArgs<ExtArgs>
            result: $Utils.Optional<DenunciasGroupByOutputType>[]
          }
          count: {
            args: Prisma.denunciasCountArgs<ExtArgs>
            result: $Utils.Optional<DenunciasCountAggregateOutputType> | number
          }
        }
      }
      documentos: {
        payload: Prisma.$documentosPayload<ExtArgs>
        fields: Prisma.documentosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.documentosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.documentosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentosPayload>
          }
          findFirst: {
            args: Prisma.documentosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.documentosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentosPayload>
          }
          findMany: {
            args: Prisma.documentosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentosPayload>[]
          }
          create: {
            args: Prisma.documentosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentosPayload>
          }
          createMany: {
            args: Prisma.documentosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.documentosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentosPayload>[]
          }
          delete: {
            args: Prisma.documentosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentosPayload>
          }
          update: {
            args: Prisma.documentosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentosPayload>
          }
          deleteMany: {
            args: Prisma.documentosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.documentosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.documentosUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentosPayload>[]
          }
          upsert: {
            args: Prisma.documentosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentosPayload>
          }
          aggregate: {
            args: Prisma.DocumentosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocumentos>
          }
          groupBy: {
            args: Prisma.documentosGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentosGroupByOutputType>[]
          }
          count: {
            args: Prisma.documentosCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentosCountAggregateOutputType> | number
          }
        }
      }
      emails_enviados: {
        payload: Prisma.$emails_enviadosPayload<ExtArgs>
        fields: Prisma.emails_enviadosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.emails_enviadosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$emails_enviadosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.emails_enviadosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$emails_enviadosPayload>
          }
          findFirst: {
            args: Prisma.emails_enviadosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$emails_enviadosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.emails_enviadosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$emails_enviadosPayload>
          }
          findMany: {
            args: Prisma.emails_enviadosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$emails_enviadosPayload>[]
          }
          create: {
            args: Prisma.emails_enviadosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$emails_enviadosPayload>
          }
          createMany: {
            args: Prisma.emails_enviadosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.emails_enviadosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$emails_enviadosPayload>[]
          }
          delete: {
            args: Prisma.emails_enviadosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$emails_enviadosPayload>
          }
          update: {
            args: Prisma.emails_enviadosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$emails_enviadosPayload>
          }
          deleteMany: {
            args: Prisma.emails_enviadosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.emails_enviadosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.emails_enviadosUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$emails_enviadosPayload>[]
          }
          upsert: {
            args: Prisma.emails_enviadosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$emails_enviadosPayload>
          }
          aggregate: {
            args: Prisma.Emails_enviadosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmails_enviados>
          }
          groupBy: {
            args: Prisma.emails_enviadosGroupByArgs<ExtArgs>
            result: $Utils.Optional<Emails_enviadosGroupByOutputType>[]
          }
          count: {
            args: Prisma.emails_enviadosCountArgs<ExtArgs>
            result: $Utils.Optional<Emails_enviadosCountAggregateOutputType> | number
          }
        }
      }
      historico_indicacoes: {
        payload: Prisma.$historico_indicacoesPayload<ExtArgs>
        fields: Prisma.historico_indicacoesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.historico_indicacoesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historico_indicacoesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.historico_indicacoesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historico_indicacoesPayload>
          }
          findFirst: {
            args: Prisma.historico_indicacoesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historico_indicacoesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.historico_indicacoesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historico_indicacoesPayload>
          }
          findMany: {
            args: Prisma.historico_indicacoesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historico_indicacoesPayload>[]
          }
          create: {
            args: Prisma.historico_indicacoesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historico_indicacoesPayload>
          }
          createMany: {
            args: Prisma.historico_indicacoesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.historico_indicacoesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historico_indicacoesPayload>[]
          }
          delete: {
            args: Prisma.historico_indicacoesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historico_indicacoesPayload>
          }
          update: {
            args: Prisma.historico_indicacoesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historico_indicacoesPayload>
          }
          deleteMany: {
            args: Prisma.historico_indicacoesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.historico_indicacoesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.historico_indicacoesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historico_indicacoesPayload>[]
          }
          upsert: {
            args: Prisma.historico_indicacoesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historico_indicacoesPayload>
          }
          aggregate: {
            args: Prisma.Historico_indicacoesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHistorico_indicacoes>
          }
          groupBy: {
            args: Prisma.historico_indicacoesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Historico_indicacoesGroupByOutputType>[]
          }
          count: {
            args: Prisma.historico_indicacoesCountArgs<ExtArgs>
            result: $Utils.Optional<Historico_indicacoesCountAggregateOutputType> | number
          }
        }
      }
      historico_selfies: {
        payload: Prisma.$historico_selfiesPayload<ExtArgs>
        fields: Prisma.historico_selfiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.historico_selfiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historico_selfiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.historico_selfiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historico_selfiesPayload>
          }
          findFirst: {
            args: Prisma.historico_selfiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historico_selfiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.historico_selfiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historico_selfiesPayload>
          }
          findMany: {
            args: Prisma.historico_selfiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historico_selfiesPayload>[]
          }
          create: {
            args: Prisma.historico_selfiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historico_selfiesPayload>
          }
          createMany: {
            args: Prisma.historico_selfiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.historico_selfiesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historico_selfiesPayload>[]
          }
          delete: {
            args: Prisma.historico_selfiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historico_selfiesPayload>
          }
          update: {
            args: Prisma.historico_selfiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historico_selfiesPayload>
          }
          deleteMany: {
            args: Prisma.historico_selfiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.historico_selfiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.historico_selfiesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historico_selfiesPayload>[]
          }
          upsert: {
            args: Prisma.historico_selfiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historico_selfiesPayload>
          }
          aggregate: {
            args: Prisma.Historico_selfiesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHistorico_selfies>
          }
          groupBy: {
            args: Prisma.historico_selfiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Historico_selfiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.historico_selfiesCountArgs<ExtArgs>
            result: $Utils.Optional<Historico_selfiesCountAggregateOutputType> | number
          }
        }
      }
      logs_acesso: {
        payload: Prisma.$logs_acessoPayload<ExtArgs>
        fields: Prisma.logs_acessoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.logs_acessoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logs_acessoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.logs_acessoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logs_acessoPayload>
          }
          findFirst: {
            args: Prisma.logs_acessoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logs_acessoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.logs_acessoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logs_acessoPayload>
          }
          findMany: {
            args: Prisma.logs_acessoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logs_acessoPayload>[]
          }
          create: {
            args: Prisma.logs_acessoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logs_acessoPayload>
          }
          createMany: {
            args: Prisma.logs_acessoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.logs_acessoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logs_acessoPayload>[]
          }
          delete: {
            args: Prisma.logs_acessoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logs_acessoPayload>
          }
          update: {
            args: Prisma.logs_acessoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logs_acessoPayload>
          }
          deleteMany: {
            args: Prisma.logs_acessoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.logs_acessoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.logs_acessoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logs_acessoPayload>[]
          }
          upsert: {
            args: Prisma.logs_acessoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logs_acessoPayload>
          }
          aggregate: {
            args: Prisma.Logs_acessoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLogs_acesso>
          }
          groupBy: {
            args: Prisma.logs_acessoGroupByArgs<ExtArgs>
            result: $Utils.Optional<Logs_acessoGroupByOutputType>[]
          }
          count: {
            args: Prisma.logs_acessoCountArgs<ExtArgs>
            result: $Utils.Optional<Logs_acessoCountAggregateOutputType> | number
          }
        }
      }
      mensagens_suporte: {
        payload: Prisma.$mensagens_suportePayload<ExtArgs>
        fields: Prisma.mensagens_suporteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.mensagens_suporteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mensagens_suportePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.mensagens_suporteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mensagens_suportePayload>
          }
          findFirst: {
            args: Prisma.mensagens_suporteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mensagens_suportePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.mensagens_suporteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mensagens_suportePayload>
          }
          findMany: {
            args: Prisma.mensagens_suporteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mensagens_suportePayload>[]
          }
          create: {
            args: Prisma.mensagens_suporteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mensagens_suportePayload>
          }
          createMany: {
            args: Prisma.mensagens_suporteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.mensagens_suporteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mensagens_suportePayload>[]
          }
          delete: {
            args: Prisma.mensagens_suporteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mensagens_suportePayload>
          }
          update: {
            args: Prisma.mensagens_suporteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mensagens_suportePayload>
          }
          deleteMany: {
            args: Prisma.mensagens_suporteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.mensagens_suporteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.mensagens_suporteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mensagens_suportePayload>[]
          }
          upsert: {
            args: Prisma.mensagens_suporteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mensagens_suportePayload>
          }
          aggregate: {
            args: Prisma.Mensagens_suporteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMensagens_suporte>
          }
          groupBy: {
            args: Prisma.mensagens_suporteGroupByArgs<ExtArgs>
            result: $Utils.Optional<Mensagens_suporteGroupByOutputType>[]
          }
          count: {
            args: Prisma.mensagens_suporteCountArgs<ExtArgs>
            result: $Utils.Optional<Mensagens_suporteCountAggregateOutputType> | number
          }
        }
      }
      pagamentos_pessoais: {
        payload: Prisma.$pagamentos_pessoaisPayload<ExtArgs>
        fields: Prisma.pagamentos_pessoaisFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pagamentos_pessoaisFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagamentos_pessoaisPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pagamentos_pessoaisFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagamentos_pessoaisPayload>
          }
          findFirst: {
            args: Prisma.pagamentos_pessoaisFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagamentos_pessoaisPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pagamentos_pessoaisFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagamentos_pessoaisPayload>
          }
          findMany: {
            args: Prisma.pagamentos_pessoaisFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagamentos_pessoaisPayload>[]
          }
          create: {
            args: Prisma.pagamentos_pessoaisCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagamentos_pessoaisPayload>
          }
          createMany: {
            args: Prisma.pagamentos_pessoaisCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.pagamentos_pessoaisCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagamentos_pessoaisPayload>[]
          }
          delete: {
            args: Prisma.pagamentos_pessoaisDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagamentos_pessoaisPayload>
          }
          update: {
            args: Prisma.pagamentos_pessoaisUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagamentos_pessoaisPayload>
          }
          deleteMany: {
            args: Prisma.pagamentos_pessoaisDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pagamentos_pessoaisUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.pagamentos_pessoaisUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagamentos_pessoaisPayload>[]
          }
          upsert: {
            args: Prisma.pagamentos_pessoaisUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagamentos_pessoaisPayload>
          }
          aggregate: {
            args: Prisma.Pagamentos_pessoaisAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePagamentos_pessoais>
          }
          groupBy: {
            args: Prisma.pagamentos_pessoaisGroupByArgs<ExtArgs>
            result: $Utils.Optional<Pagamentos_pessoaisGroupByOutputType>[]
          }
          count: {
            args: Prisma.pagamentos_pessoaisCountArgs<ExtArgs>
            result: $Utils.Optional<Pagamentos_pessoaisCountAggregateOutputType> | number
          }
        }
      }
      paradas: {
        payload: Prisma.$paradasPayload<ExtArgs>
        fields: Prisma.paradasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.paradasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paradasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.paradasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paradasPayload>
          }
          findFirst: {
            args: Prisma.paradasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paradasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.paradasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paradasPayload>
          }
          findMany: {
            args: Prisma.paradasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paradasPayload>[]
          }
          create: {
            args: Prisma.paradasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paradasPayload>
          }
          createMany: {
            args: Prisma.paradasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.paradasCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paradasPayload>[]
          }
          delete: {
            args: Prisma.paradasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paradasPayload>
          }
          update: {
            args: Prisma.paradasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paradasPayload>
          }
          deleteMany: {
            args: Prisma.paradasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.paradasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.paradasUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paradasPayload>[]
          }
          upsert: {
            args: Prisma.paradasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paradasPayload>
          }
          aggregate: {
            args: Prisma.ParadasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParadas>
          }
          groupBy: {
            args: Prisma.paradasGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParadasGroupByOutputType>[]
          }
          count: {
            args: Prisma.paradasCountArgs<ExtArgs>
            result: $Utils.Optional<ParadasCountAggregateOutputType> | number
          }
        }
      }
      recompensas: {
        payload: Prisma.$recompensasPayload<ExtArgs>
        fields: Prisma.recompensasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.recompensasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recompensasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.recompensasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recompensasPayload>
          }
          findFirst: {
            args: Prisma.recompensasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recompensasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.recompensasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recompensasPayload>
          }
          findMany: {
            args: Prisma.recompensasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recompensasPayload>[]
          }
          create: {
            args: Prisma.recompensasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recompensasPayload>
          }
          createMany: {
            args: Prisma.recompensasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.recompensasCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recompensasPayload>[]
          }
          delete: {
            args: Prisma.recompensasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recompensasPayload>
          }
          update: {
            args: Prisma.recompensasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recompensasPayload>
          }
          deleteMany: {
            args: Prisma.recompensasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.recompensasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.recompensasUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recompensasPayload>[]
          }
          upsert: {
            args: Prisma.recompensasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recompensasPayload>
          }
          aggregate: {
            args: Prisma.RecompensasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecompensas>
          }
          groupBy: {
            args: Prisma.recompensasGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecompensasGroupByOutputType>[]
          }
          count: {
            args: Prisma.recompensasCountArgs<ExtArgs>
            result: $Utils.Optional<RecompensasCountAggregateOutputType> | number
          }
        }
      }
      saques: {
        payload: Prisma.$saquesPayload<ExtArgs>
        fields: Prisma.saquesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.saquesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saquesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.saquesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saquesPayload>
          }
          findFirst: {
            args: Prisma.saquesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saquesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.saquesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saquesPayload>
          }
          findMany: {
            args: Prisma.saquesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saquesPayload>[]
          }
          create: {
            args: Prisma.saquesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saquesPayload>
          }
          createMany: {
            args: Prisma.saquesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.saquesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saquesPayload>[]
          }
          delete: {
            args: Prisma.saquesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saquesPayload>
          }
          update: {
            args: Prisma.saquesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saquesPayload>
          }
          deleteMany: {
            args: Prisma.saquesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.saquesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.saquesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saquesPayload>[]
          }
          upsert: {
            args: Prisma.saquesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saquesPayload>
          }
          aggregate: {
            args: Prisma.SaquesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSaques>
          }
          groupBy: {
            args: Prisma.saquesGroupByArgs<ExtArgs>
            result: $Utils.Optional<SaquesGroupByOutputType>[]
          }
          count: {
            args: Prisma.saquesCountArgs<ExtArgs>
            result: $Utils.Optional<SaquesCountAggregateOutputType> | number
          }
        }
      }
      transacoes: {
        payload: Prisma.$transacoesPayload<ExtArgs>
        fields: Prisma.transacoesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.transacoesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transacoesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.transacoesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transacoesPayload>
          }
          findFirst: {
            args: Prisma.transacoesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transacoesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.transacoesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transacoesPayload>
          }
          findMany: {
            args: Prisma.transacoesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transacoesPayload>[]
          }
          create: {
            args: Prisma.transacoesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transacoesPayload>
          }
          createMany: {
            args: Prisma.transacoesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.transacoesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transacoesPayload>[]
          }
          delete: {
            args: Prisma.transacoesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transacoesPayload>
          }
          update: {
            args: Prisma.transacoesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transacoesPayload>
          }
          deleteMany: {
            args: Prisma.transacoesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.transacoesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.transacoesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transacoesPayload>[]
          }
          upsert: {
            args: Prisma.transacoesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transacoesPayload>
          }
          aggregate: {
            args: Prisma.TransacoesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransacoes>
          }
          groupBy: {
            args: Prisma.transacoesGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransacoesGroupByOutputType>[]
          }
          count: {
            args: Prisma.transacoesCountArgs<ExtArgs>
            result: $Utils.Optional<TransacoesCountAggregateOutputType> | number
          }
        }
      }
      usuarios: {
        payload: Prisma.$usuariosPayload<ExtArgs>
        fields: Prisma.usuariosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usuariosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usuariosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosPayload>
          }
          findFirst: {
            args: Prisma.usuariosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usuariosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosPayload>
          }
          findMany: {
            args: Prisma.usuariosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosPayload>[]
          }
          create: {
            args: Prisma.usuariosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosPayload>
          }
          createMany: {
            args: Prisma.usuariosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usuariosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosPayload>[]
          }
          delete: {
            args: Prisma.usuariosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosPayload>
          }
          update: {
            args: Prisma.usuariosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosPayload>
          }
          deleteMany: {
            args: Prisma.usuariosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usuariosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.usuariosUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosPayload>[]
          }
          upsert: {
            args: Prisma.usuariosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosPayload>
          }
          aggregate: {
            args: Prisma.UsuariosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuarios>
          }
          groupBy: {
            args: Prisma.usuariosGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuariosGroupByOutputType>[]
          }
          count: {
            args: Prisma.usuariosCountArgs<ExtArgs>
            result: $Utils.Optional<UsuariosCountAggregateOutputType> | number
          }
        }
      }
      veiculos: {
        payload: Prisma.$veiculosPayload<ExtArgs>
        fields: Prisma.veiculosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.veiculosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$veiculosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.veiculosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$veiculosPayload>
          }
          findFirst: {
            args: Prisma.veiculosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$veiculosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.veiculosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$veiculosPayload>
          }
          findMany: {
            args: Prisma.veiculosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$veiculosPayload>[]
          }
          create: {
            args: Prisma.veiculosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$veiculosPayload>
          }
          createMany: {
            args: Prisma.veiculosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.veiculosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$veiculosPayload>[]
          }
          delete: {
            args: Prisma.veiculosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$veiculosPayload>
          }
          update: {
            args: Prisma.veiculosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$veiculosPayload>
          }
          deleteMany: {
            args: Prisma.veiculosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.veiculosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.veiculosUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$veiculosPayload>[]
          }
          upsert: {
            args: Prisma.veiculosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$veiculosPayload>
          }
          aggregate: {
            args: Prisma.VeiculosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVeiculos>
          }
          groupBy: {
            args: Prisma.veiculosGroupByArgs<ExtArgs>
            result: $Utils.Optional<VeiculosGroupByOutputType>[]
          }
          count: {
            args: Prisma.veiculosCountArgs<ExtArgs>
            result: $Utils.Optional<VeiculosCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    bairroPrioridades?: BairroPrioridadesOmit
    carteiras?: CarteirasOmit
    codigoIndicacaos?: CodigoIndicacaosOmit
    corridaAgendadas?: CorridaAgendadasOmit
    corridas?: CorridasOmit
    denuncia?: DenunciaOmit
    documentos?: DocumentosOmit
    emailEnviados?: EmailEnviadosOmit
    historicoIndicacaos?: HistoricoIndicacaosOmit
    historicoSelfies?: HistoricoSelfiesOmit
    identidades?: IdentidadesOmit
    indicacaos?: IndicacaosOmit
    logAcessos?: LogAcessosOmit
    mensagemSuportes?: MensagemSuportesOmit
    recompensas?: RecompensasOmit
    saques?: SaquesOmit
    transacaos?: TransacaosOmit
    usuarios?: UsuariosOmit
    veiculos?: VeiculosOmit
    agenda_corridas?: agenda_corridasOmit
    avaliacoes?: avaliacoesOmit
    bairros_prioridade?: bairros_prioridadeOmit
    carteiras?: carteirasOmit
    corridas?: corridasOmit
    denuncias?: denunciasOmit
    documentos?: documentosOmit
    emails_enviados?: emails_enviadosOmit
    historico_indicacoes?: historico_indicacoesOmit
    historico_selfies?: historico_selfiesOmit
    logs_acesso?: logs_acessoOmit
    mensagens_suporte?: mensagens_suporteOmit
    pagamentos_pessoais?: pagamentos_pessoaisOmit
    paradas?: paradasOmit
    recompensas?: recompensasOmit
    saques?: saquesOmit
    transacoes?: transacoesOmit
    usuarios?: usuariosOmit
    veiculos?: veiculosOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UsuariosCountOutputType
   */

  export type UsuariosCountOutputType = {
    Indicacaos_Indicacaos_indicadoIdToUsuarios: number
    Indicacaos_Indicacaos_indicanteIdToUsuarios: number
    Recompensas: number
    Saques: number
    Transacaos: number
  }

  export type UsuariosCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Indicacaos_Indicacaos_indicadoIdToUsuarios?: boolean | UsuariosCountOutputTypeCountIndicacaos_Indicacaos_indicadoIdToUsuariosArgs
    Indicacaos_Indicacaos_indicanteIdToUsuarios?: boolean | UsuariosCountOutputTypeCountIndicacaos_Indicacaos_indicanteIdToUsuariosArgs
    Recompensas?: boolean | UsuariosCountOutputTypeCountRecompensasArgs
    Saques?: boolean | UsuariosCountOutputTypeCountSaquesArgs
    Transacaos?: boolean | UsuariosCountOutputTypeCountTransacaosArgs
  }

  // Custom InputTypes
  /**
   * UsuariosCountOutputType without action
   */
  export type UsuariosCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuariosCountOutputType
     */
    select?: UsuariosCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsuariosCountOutputType without action
   */
  export type UsuariosCountOutputTypeCountIndicacaos_Indicacaos_indicadoIdToUsuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IndicacaosWhereInput
  }

  /**
   * UsuariosCountOutputType without action
   */
  export type UsuariosCountOutputTypeCountIndicacaos_Indicacaos_indicanteIdToUsuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IndicacaosWhereInput
  }

  /**
   * UsuariosCountOutputType without action
   */
  export type UsuariosCountOutputTypeCountRecompensasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecompensasWhereInput
  }

  /**
   * UsuariosCountOutputType without action
   */
  export type UsuariosCountOutputTypeCountSaquesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaquesWhereInput
  }

  /**
   * UsuariosCountOutputType without action
   */
  export type UsuariosCountOutputTypeCountTransacaosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransacaosWhereInput
  }


  /**
   * Models
   */

  /**
   * Model BairroPrioridades
   */

  export type AggregateBairroPrioridades = {
    _count: BairroPrioridadesCountAggregateOutputType | null
    _avg: BairroPrioridadesAvgAggregateOutputType | null
    _sum: BairroPrioridadesSumAggregateOutputType | null
    _min: BairroPrioridadesMinAggregateOutputType | null
    _max: BairroPrioridadesMaxAggregateOutputType | null
  }

  export type BairroPrioridadesAvgAggregateOutputType = {
    id: number | null
  }

  export type BairroPrioridadesSumAggregateOutputType = {
    id: number | null
  }

  export type BairroPrioridadesMinAggregateOutputType = {
    id: number | null
    nome: string | null
    cidade: string | null
    estado: string | null
    ativo: boolean | null
    tipo_prioridade: $Enums.enum_BairroPrioridades_tipo_prioridade | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BairroPrioridadesMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    cidade: string | null
    estado: string | null
    ativo: boolean | null
    tipo_prioridade: $Enums.enum_BairroPrioridades_tipo_prioridade | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BairroPrioridadesCountAggregateOutputType = {
    id: number
    nome: number
    cidade: number
    estado: number
    ativo: number
    tipo_prioridade: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BairroPrioridadesAvgAggregateInputType = {
    id?: true
  }

  export type BairroPrioridadesSumAggregateInputType = {
    id?: true
  }

  export type BairroPrioridadesMinAggregateInputType = {
    id?: true
    nome?: true
    cidade?: true
    estado?: true
    ativo?: true
    tipo_prioridade?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BairroPrioridadesMaxAggregateInputType = {
    id?: true
    nome?: true
    cidade?: true
    estado?: true
    ativo?: true
    tipo_prioridade?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BairroPrioridadesCountAggregateInputType = {
    id?: true
    nome?: true
    cidade?: true
    estado?: true
    ativo?: true
    tipo_prioridade?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BairroPrioridadesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BairroPrioridades to aggregate.
     */
    where?: BairroPrioridadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BairroPrioridades to fetch.
     */
    orderBy?: BairroPrioridadesOrderByWithRelationInput | BairroPrioridadesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BairroPrioridadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BairroPrioridades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BairroPrioridades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BairroPrioridades
    **/
    _count?: true | BairroPrioridadesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BairroPrioridadesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BairroPrioridadesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BairroPrioridadesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BairroPrioridadesMaxAggregateInputType
  }

  export type GetBairroPrioridadesAggregateType<T extends BairroPrioridadesAggregateArgs> = {
        [P in keyof T & keyof AggregateBairroPrioridades]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBairroPrioridades[P]>
      : GetScalarType<T[P], AggregateBairroPrioridades[P]>
  }




  export type BairroPrioridadesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BairroPrioridadesWhereInput
    orderBy?: BairroPrioridadesOrderByWithAggregationInput | BairroPrioridadesOrderByWithAggregationInput[]
    by: BairroPrioridadesScalarFieldEnum[] | BairroPrioridadesScalarFieldEnum
    having?: BairroPrioridadesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BairroPrioridadesCountAggregateInputType | true
    _avg?: BairroPrioridadesAvgAggregateInputType
    _sum?: BairroPrioridadesSumAggregateInputType
    _min?: BairroPrioridadesMinAggregateInputType
    _max?: BairroPrioridadesMaxAggregateInputType
  }

  export type BairroPrioridadesGroupByOutputType = {
    id: number
    nome: string
    cidade: string
    estado: string
    ativo: boolean | null
    tipo_prioridade: $Enums.enum_BairroPrioridades_tipo_prioridade | null
    createdAt: Date
    updatedAt: Date
    _count: BairroPrioridadesCountAggregateOutputType | null
    _avg: BairroPrioridadesAvgAggregateOutputType | null
    _sum: BairroPrioridadesSumAggregateOutputType | null
    _min: BairroPrioridadesMinAggregateOutputType | null
    _max: BairroPrioridadesMaxAggregateOutputType | null
  }

  type GetBairroPrioridadesGroupByPayload<T extends BairroPrioridadesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BairroPrioridadesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BairroPrioridadesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BairroPrioridadesGroupByOutputType[P]>
            : GetScalarType<T[P], BairroPrioridadesGroupByOutputType[P]>
        }
      >
    >


  export type BairroPrioridadesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    cidade?: boolean
    estado?: boolean
    ativo?: boolean
    tipo_prioridade?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["bairroPrioridades"]>

  export type BairroPrioridadesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    cidade?: boolean
    estado?: boolean
    ativo?: boolean
    tipo_prioridade?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["bairroPrioridades"]>

  export type BairroPrioridadesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    cidade?: boolean
    estado?: boolean
    ativo?: boolean
    tipo_prioridade?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["bairroPrioridades"]>

  export type BairroPrioridadesSelectScalar = {
    id?: boolean
    nome?: boolean
    cidade?: boolean
    estado?: boolean
    ativo?: boolean
    tipo_prioridade?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BairroPrioridadesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nome" | "cidade" | "estado" | "ativo" | "tipo_prioridade" | "createdAt" | "updatedAt", ExtArgs["result"]["bairroPrioridades"]>

  export type $BairroPrioridadesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BairroPrioridades"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      cidade: string
      estado: string
      ativo: boolean | null
      tipo_prioridade: $Enums.enum_BairroPrioridades_tipo_prioridade | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bairroPrioridades"]>
    composites: {}
  }

  type BairroPrioridadesGetPayload<S extends boolean | null | undefined | BairroPrioridadesDefaultArgs> = $Result.GetResult<Prisma.$BairroPrioridadesPayload, S>

  type BairroPrioridadesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BairroPrioridadesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BairroPrioridadesCountAggregateInputType | true
    }

  export interface BairroPrioridadesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BairroPrioridades'], meta: { name: 'BairroPrioridades' } }
    /**
     * Find zero or one BairroPrioridades that matches the filter.
     * @param {BairroPrioridadesFindUniqueArgs} args - Arguments to find a BairroPrioridades
     * @example
     * // Get one BairroPrioridades
     * const bairroPrioridades = await prisma.bairroPrioridades.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BairroPrioridadesFindUniqueArgs>(args: SelectSubset<T, BairroPrioridadesFindUniqueArgs<ExtArgs>>): Prisma__BairroPrioridadesClient<$Result.GetResult<Prisma.$BairroPrioridadesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BairroPrioridades that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BairroPrioridadesFindUniqueOrThrowArgs} args - Arguments to find a BairroPrioridades
     * @example
     * // Get one BairroPrioridades
     * const bairroPrioridades = await prisma.bairroPrioridades.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BairroPrioridadesFindUniqueOrThrowArgs>(args: SelectSubset<T, BairroPrioridadesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BairroPrioridadesClient<$Result.GetResult<Prisma.$BairroPrioridadesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BairroPrioridades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BairroPrioridadesFindFirstArgs} args - Arguments to find a BairroPrioridades
     * @example
     * // Get one BairroPrioridades
     * const bairroPrioridades = await prisma.bairroPrioridades.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BairroPrioridadesFindFirstArgs>(args?: SelectSubset<T, BairroPrioridadesFindFirstArgs<ExtArgs>>): Prisma__BairroPrioridadesClient<$Result.GetResult<Prisma.$BairroPrioridadesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BairroPrioridades that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BairroPrioridadesFindFirstOrThrowArgs} args - Arguments to find a BairroPrioridades
     * @example
     * // Get one BairroPrioridades
     * const bairroPrioridades = await prisma.bairroPrioridades.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BairroPrioridadesFindFirstOrThrowArgs>(args?: SelectSubset<T, BairroPrioridadesFindFirstOrThrowArgs<ExtArgs>>): Prisma__BairroPrioridadesClient<$Result.GetResult<Prisma.$BairroPrioridadesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BairroPrioridades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BairroPrioridadesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BairroPrioridades
     * const bairroPrioridades = await prisma.bairroPrioridades.findMany()
     * 
     * // Get first 10 BairroPrioridades
     * const bairroPrioridades = await prisma.bairroPrioridades.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bairroPrioridadesWithIdOnly = await prisma.bairroPrioridades.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BairroPrioridadesFindManyArgs>(args?: SelectSubset<T, BairroPrioridadesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BairroPrioridadesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BairroPrioridades.
     * @param {BairroPrioridadesCreateArgs} args - Arguments to create a BairroPrioridades.
     * @example
     * // Create one BairroPrioridades
     * const BairroPrioridades = await prisma.bairroPrioridades.create({
     *   data: {
     *     // ... data to create a BairroPrioridades
     *   }
     * })
     * 
     */
    create<T extends BairroPrioridadesCreateArgs>(args: SelectSubset<T, BairroPrioridadesCreateArgs<ExtArgs>>): Prisma__BairroPrioridadesClient<$Result.GetResult<Prisma.$BairroPrioridadesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BairroPrioridades.
     * @param {BairroPrioridadesCreateManyArgs} args - Arguments to create many BairroPrioridades.
     * @example
     * // Create many BairroPrioridades
     * const bairroPrioridades = await prisma.bairroPrioridades.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BairroPrioridadesCreateManyArgs>(args?: SelectSubset<T, BairroPrioridadesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BairroPrioridades and returns the data saved in the database.
     * @param {BairroPrioridadesCreateManyAndReturnArgs} args - Arguments to create many BairroPrioridades.
     * @example
     * // Create many BairroPrioridades
     * const bairroPrioridades = await prisma.bairroPrioridades.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BairroPrioridades and only return the `id`
     * const bairroPrioridadesWithIdOnly = await prisma.bairroPrioridades.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BairroPrioridadesCreateManyAndReturnArgs>(args?: SelectSubset<T, BairroPrioridadesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BairroPrioridadesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BairroPrioridades.
     * @param {BairroPrioridadesDeleteArgs} args - Arguments to delete one BairroPrioridades.
     * @example
     * // Delete one BairroPrioridades
     * const BairroPrioridades = await prisma.bairroPrioridades.delete({
     *   where: {
     *     // ... filter to delete one BairroPrioridades
     *   }
     * })
     * 
     */
    delete<T extends BairroPrioridadesDeleteArgs>(args: SelectSubset<T, BairroPrioridadesDeleteArgs<ExtArgs>>): Prisma__BairroPrioridadesClient<$Result.GetResult<Prisma.$BairroPrioridadesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BairroPrioridades.
     * @param {BairroPrioridadesUpdateArgs} args - Arguments to update one BairroPrioridades.
     * @example
     * // Update one BairroPrioridades
     * const bairroPrioridades = await prisma.bairroPrioridades.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BairroPrioridadesUpdateArgs>(args: SelectSubset<T, BairroPrioridadesUpdateArgs<ExtArgs>>): Prisma__BairroPrioridadesClient<$Result.GetResult<Prisma.$BairroPrioridadesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BairroPrioridades.
     * @param {BairroPrioridadesDeleteManyArgs} args - Arguments to filter BairroPrioridades to delete.
     * @example
     * // Delete a few BairroPrioridades
     * const { count } = await prisma.bairroPrioridades.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BairroPrioridadesDeleteManyArgs>(args?: SelectSubset<T, BairroPrioridadesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BairroPrioridades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BairroPrioridadesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BairroPrioridades
     * const bairroPrioridades = await prisma.bairroPrioridades.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BairroPrioridadesUpdateManyArgs>(args: SelectSubset<T, BairroPrioridadesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BairroPrioridades and returns the data updated in the database.
     * @param {BairroPrioridadesUpdateManyAndReturnArgs} args - Arguments to update many BairroPrioridades.
     * @example
     * // Update many BairroPrioridades
     * const bairroPrioridades = await prisma.bairroPrioridades.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BairroPrioridades and only return the `id`
     * const bairroPrioridadesWithIdOnly = await prisma.bairroPrioridades.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BairroPrioridadesUpdateManyAndReturnArgs>(args: SelectSubset<T, BairroPrioridadesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BairroPrioridadesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BairroPrioridades.
     * @param {BairroPrioridadesUpsertArgs} args - Arguments to update or create a BairroPrioridades.
     * @example
     * // Update or create a BairroPrioridades
     * const bairroPrioridades = await prisma.bairroPrioridades.upsert({
     *   create: {
     *     // ... data to create a BairroPrioridades
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BairroPrioridades we want to update
     *   }
     * })
     */
    upsert<T extends BairroPrioridadesUpsertArgs>(args: SelectSubset<T, BairroPrioridadesUpsertArgs<ExtArgs>>): Prisma__BairroPrioridadesClient<$Result.GetResult<Prisma.$BairroPrioridadesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BairroPrioridades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BairroPrioridadesCountArgs} args - Arguments to filter BairroPrioridades to count.
     * @example
     * // Count the number of BairroPrioridades
     * const count = await prisma.bairroPrioridades.count({
     *   where: {
     *     // ... the filter for the BairroPrioridades we want to count
     *   }
     * })
    **/
    count<T extends BairroPrioridadesCountArgs>(
      args?: Subset<T, BairroPrioridadesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BairroPrioridadesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BairroPrioridades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BairroPrioridadesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BairroPrioridadesAggregateArgs>(args: Subset<T, BairroPrioridadesAggregateArgs>): Prisma.PrismaPromise<GetBairroPrioridadesAggregateType<T>>

    /**
     * Group by BairroPrioridades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BairroPrioridadesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BairroPrioridadesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BairroPrioridadesGroupByArgs['orderBy'] }
        : { orderBy?: BairroPrioridadesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BairroPrioridadesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBairroPrioridadesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BairroPrioridades model
   */
  readonly fields: BairroPrioridadesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BairroPrioridades.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BairroPrioridadesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BairroPrioridades model
   */
  interface BairroPrioridadesFieldRefs {
    readonly id: FieldRef<"BairroPrioridades", 'Int'>
    readonly nome: FieldRef<"BairroPrioridades", 'String'>
    readonly cidade: FieldRef<"BairroPrioridades", 'String'>
    readonly estado: FieldRef<"BairroPrioridades", 'String'>
    readonly ativo: FieldRef<"BairroPrioridades", 'Boolean'>
    readonly tipo_prioridade: FieldRef<"BairroPrioridades", 'enum_BairroPrioridades_tipo_prioridade'>
    readonly createdAt: FieldRef<"BairroPrioridades", 'DateTime'>
    readonly updatedAt: FieldRef<"BairroPrioridades", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BairroPrioridades findUnique
   */
  export type BairroPrioridadesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BairroPrioridades
     */
    select?: BairroPrioridadesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BairroPrioridades
     */
    omit?: BairroPrioridadesOmit<ExtArgs> | null
    /**
     * Filter, which BairroPrioridades to fetch.
     */
    where: BairroPrioridadesWhereUniqueInput
  }

  /**
   * BairroPrioridades findUniqueOrThrow
   */
  export type BairroPrioridadesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BairroPrioridades
     */
    select?: BairroPrioridadesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BairroPrioridades
     */
    omit?: BairroPrioridadesOmit<ExtArgs> | null
    /**
     * Filter, which BairroPrioridades to fetch.
     */
    where: BairroPrioridadesWhereUniqueInput
  }

  /**
   * BairroPrioridades findFirst
   */
  export type BairroPrioridadesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BairroPrioridades
     */
    select?: BairroPrioridadesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BairroPrioridades
     */
    omit?: BairroPrioridadesOmit<ExtArgs> | null
    /**
     * Filter, which BairroPrioridades to fetch.
     */
    where?: BairroPrioridadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BairroPrioridades to fetch.
     */
    orderBy?: BairroPrioridadesOrderByWithRelationInput | BairroPrioridadesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BairroPrioridades.
     */
    cursor?: BairroPrioridadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BairroPrioridades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BairroPrioridades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BairroPrioridades.
     */
    distinct?: BairroPrioridadesScalarFieldEnum | BairroPrioridadesScalarFieldEnum[]
  }

  /**
   * BairroPrioridades findFirstOrThrow
   */
  export type BairroPrioridadesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BairroPrioridades
     */
    select?: BairroPrioridadesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BairroPrioridades
     */
    omit?: BairroPrioridadesOmit<ExtArgs> | null
    /**
     * Filter, which BairroPrioridades to fetch.
     */
    where?: BairroPrioridadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BairroPrioridades to fetch.
     */
    orderBy?: BairroPrioridadesOrderByWithRelationInput | BairroPrioridadesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BairroPrioridades.
     */
    cursor?: BairroPrioridadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BairroPrioridades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BairroPrioridades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BairroPrioridades.
     */
    distinct?: BairroPrioridadesScalarFieldEnum | BairroPrioridadesScalarFieldEnum[]
  }

  /**
   * BairroPrioridades findMany
   */
  export type BairroPrioridadesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BairroPrioridades
     */
    select?: BairroPrioridadesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BairroPrioridades
     */
    omit?: BairroPrioridadesOmit<ExtArgs> | null
    /**
     * Filter, which BairroPrioridades to fetch.
     */
    where?: BairroPrioridadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BairroPrioridades to fetch.
     */
    orderBy?: BairroPrioridadesOrderByWithRelationInput | BairroPrioridadesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BairroPrioridades.
     */
    cursor?: BairroPrioridadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BairroPrioridades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BairroPrioridades.
     */
    skip?: number
    distinct?: BairroPrioridadesScalarFieldEnum | BairroPrioridadesScalarFieldEnum[]
  }

  /**
   * BairroPrioridades create
   */
  export type BairroPrioridadesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BairroPrioridades
     */
    select?: BairroPrioridadesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BairroPrioridades
     */
    omit?: BairroPrioridadesOmit<ExtArgs> | null
    /**
     * The data needed to create a BairroPrioridades.
     */
    data: XOR<BairroPrioridadesCreateInput, BairroPrioridadesUncheckedCreateInput>
  }

  /**
   * BairroPrioridades createMany
   */
  export type BairroPrioridadesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BairroPrioridades.
     */
    data: BairroPrioridadesCreateManyInput | BairroPrioridadesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BairroPrioridades createManyAndReturn
   */
  export type BairroPrioridadesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BairroPrioridades
     */
    select?: BairroPrioridadesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BairroPrioridades
     */
    omit?: BairroPrioridadesOmit<ExtArgs> | null
    /**
     * The data used to create many BairroPrioridades.
     */
    data: BairroPrioridadesCreateManyInput | BairroPrioridadesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BairroPrioridades update
   */
  export type BairroPrioridadesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BairroPrioridades
     */
    select?: BairroPrioridadesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BairroPrioridades
     */
    omit?: BairroPrioridadesOmit<ExtArgs> | null
    /**
     * The data needed to update a BairroPrioridades.
     */
    data: XOR<BairroPrioridadesUpdateInput, BairroPrioridadesUncheckedUpdateInput>
    /**
     * Choose, which BairroPrioridades to update.
     */
    where: BairroPrioridadesWhereUniqueInput
  }

  /**
   * BairroPrioridades updateMany
   */
  export type BairroPrioridadesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BairroPrioridades.
     */
    data: XOR<BairroPrioridadesUpdateManyMutationInput, BairroPrioridadesUncheckedUpdateManyInput>
    /**
     * Filter which BairroPrioridades to update
     */
    where?: BairroPrioridadesWhereInput
    /**
     * Limit how many BairroPrioridades to update.
     */
    limit?: number
  }

  /**
   * BairroPrioridades updateManyAndReturn
   */
  export type BairroPrioridadesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BairroPrioridades
     */
    select?: BairroPrioridadesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BairroPrioridades
     */
    omit?: BairroPrioridadesOmit<ExtArgs> | null
    /**
     * The data used to update BairroPrioridades.
     */
    data: XOR<BairroPrioridadesUpdateManyMutationInput, BairroPrioridadesUncheckedUpdateManyInput>
    /**
     * Filter which BairroPrioridades to update
     */
    where?: BairroPrioridadesWhereInput
    /**
     * Limit how many BairroPrioridades to update.
     */
    limit?: number
  }

  /**
   * BairroPrioridades upsert
   */
  export type BairroPrioridadesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BairroPrioridades
     */
    select?: BairroPrioridadesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BairroPrioridades
     */
    omit?: BairroPrioridadesOmit<ExtArgs> | null
    /**
     * The filter to search for the BairroPrioridades to update in case it exists.
     */
    where: BairroPrioridadesWhereUniqueInput
    /**
     * In case the BairroPrioridades found by the `where` argument doesn't exist, create a new BairroPrioridades with this data.
     */
    create: XOR<BairroPrioridadesCreateInput, BairroPrioridadesUncheckedCreateInput>
    /**
     * In case the BairroPrioridades was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BairroPrioridadesUpdateInput, BairroPrioridadesUncheckedUpdateInput>
  }

  /**
   * BairroPrioridades delete
   */
  export type BairroPrioridadesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BairroPrioridades
     */
    select?: BairroPrioridadesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BairroPrioridades
     */
    omit?: BairroPrioridadesOmit<ExtArgs> | null
    /**
     * Filter which BairroPrioridades to delete.
     */
    where: BairroPrioridadesWhereUniqueInput
  }

  /**
   * BairroPrioridades deleteMany
   */
  export type BairroPrioridadesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BairroPrioridades to delete
     */
    where?: BairroPrioridadesWhereInput
    /**
     * Limit how many BairroPrioridades to delete.
     */
    limit?: number
  }

  /**
   * BairroPrioridades without action
   */
  export type BairroPrioridadesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BairroPrioridades
     */
    select?: BairroPrioridadesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BairroPrioridades
     */
    omit?: BairroPrioridadesOmit<ExtArgs> | null
  }


  /**
   * Model Carteiras
   */

  export type AggregateCarteiras = {
    _count: CarteirasCountAggregateOutputType | null
    _avg: CarteirasAvgAggregateOutputType | null
    _sum: CarteirasSumAggregateOutputType | null
    _min: CarteirasMinAggregateOutputType | null
    _max: CarteirasMaxAggregateOutputType | null
  }

  export type CarteirasAvgAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    saldo: Decimal | null
  }

  export type CarteirasSumAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    saldo: Decimal | null
  }

  export type CarteirasMinAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    saldo: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CarteirasMaxAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    saldo: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CarteirasCountAggregateOutputType = {
    id: number
    usuarioId: number
    saldo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CarteirasAvgAggregateInputType = {
    id?: true
    usuarioId?: true
    saldo?: true
  }

  export type CarteirasSumAggregateInputType = {
    id?: true
    usuarioId?: true
    saldo?: true
  }

  export type CarteirasMinAggregateInputType = {
    id?: true
    usuarioId?: true
    saldo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CarteirasMaxAggregateInputType = {
    id?: true
    usuarioId?: true
    saldo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CarteirasCountAggregateInputType = {
    id?: true
    usuarioId?: true
    saldo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CarteirasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Carteiras to aggregate.
     */
    where?: CarteirasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carteiras to fetch.
     */
    orderBy?: CarteirasOrderByWithRelationInput | CarteirasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CarteirasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carteiras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carteiras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Carteiras
    **/
    _count?: true | CarteirasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CarteirasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CarteirasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CarteirasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CarteirasMaxAggregateInputType
  }

  export type GetCarteirasAggregateType<T extends CarteirasAggregateArgs> = {
        [P in keyof T & keyof AggregateCarteiras]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCarteiras[P]>
      : GetScalarType<T[P], AggregateCarteiras[P]>
  }




  export type CarteirasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CarteirasWhereInput
    orderBy?: CarteirasOrderByWithAggregationInput | CarteirasOrderByWithAggregationInput[]
    by: CarteirasScalarFieldEnum[] | CarteirasScalarFieldEnum
    having?: CarteirasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CarteirasCountAggregateInputType | true
    _avg?: CarteirasAvgAggregateInputType
    _sum?: CarteirasSumAggregateInputType
    _min?: CarteirasMinAggregateInputType
    _max?: CarteirasMaxAggregateInputType
  }

  export type CarteirasGroupByOutputType = {
    id: number
    usuarioId: number
    saldo: Decimal | null
    createdAt: Date
    updatedAt: Date
    _count: CarteirasCountAggregateOutputType | null
    _avg: CarteirasAvgAggregateOutputType | null
    _sum: CarteirasSumAggregateOutputType | null
    _min: CarteirasMinAggregateOutputType | null
    _max: CarteirasMaxAggregateOutputType | null
  }

  type GetCarteirasGroupByPayload<T extends CarteirasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CarteirasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CarteirasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CarteirasGroupByOutputType[P]>
            : GetScalarType<T[P], CarteirasGroupByOutputType[P]>
        }
      >
    >


  export type CarteirasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    saldo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["carteiras"]>

  export type CarteirasSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    saldo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["carteiras"]>

  export type CarteirasSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    saldo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["carteiras"]>

  export type CarteirasSelectScalar = {
    id?: boolean
    usuarioId?: boolean
    saldo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CarteirasOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "usuarioId" | "saldo" | "createdAt" | "updatedAt", ExtArgs["result"]["carteiras"]>

  export type $CarteirasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Carteiras"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      usuarioId: number
      saldo: Prisma.Decimal | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["carteiras"]>
    composites: {}
  }

  type CarteirasGetPayload<S extends boolean | null | undefined | CarteirasDefaultArgs> = $Result.GetResult<Prisma.$CarteirasPayload, S>

  type CarteirasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CarteirasFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CarteirasCountAggregateInputType | true
    }

  export interface CarteirasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Carteiras'], meta: { name: 'Carteiras' } }
    /**
     * Find zero or one Carteiras that matches the filter.
     * @param {CarteirasFindUniqueArgs} args - Arguments to find a Carteiras
     * @example
     * // Get one Carteiras
     * const carteiras = await prisma.carteiras.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CarteirasFindUniqueArgs>(args: SelectSubset<T, CarteirasFindUniqueArgs<ExtArgs>>): Prisma__CarteirasClient<$Result.GetResult<Prisma.$CarteirasPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Carteiras that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CarteirasFindUniqueOrThrowArgs} args - Arguments to find a Carteiras
     * @example
     * // Get one Carteiras
     * const carteiras = await prisma.carteiras.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CarteirasFindUniqueOrThrowArgs>(args: SelectSubset<T, CarteirasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CarteirasClient<$Result.GetResult<Prisma.$CarteirasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Carteiras that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarteirasFindFirstArgs} args - Arguments to find a Carteiras
     * @example
     * // Get one Carteiras
     * const carteiras = await prisma.carteiras.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CarteirasFindFirstArgs>(args?: SelectSubset<T, CarteirasFindFirstArgs<ExtArgs>>): Prisma__CarteirasClient<$Result.GetResult<Prisma.$CarteirasPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Carteiras that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarteirasFindFirstOrThrowArgs} args - Arguments to find a Carteiras
     * @example
     * // Get one Carteiras
     * const carteiras = await prisma.carteiras.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CarteirasFindFirstOrThrowArgs>(args?: SelectSubset<T, CarteirasFindFirstOrThrowArgs<ExtArgs>>): Prisma__CarteirasClient<$Result.GetResult<Prisma.$CarteirasPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Carteiras that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarteirasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Carteiras
     * const carteiras = await prisma.carteiras.findMany()
     * 
     * // Get first 10 Carteiras
     * const carteiras = await prisma.carteiras.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const carteirasWithIdOnly = await prisma.carteiras.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CarteirasFindManyArgs>(args?: SelectSubset<T, CarteirasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CarteirasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Carteiras.
     * @param {CarteirasCreateArgs} args - Arguments to create a Carteiras.
     * @example
     * // Create one Carteiras
     * const Carteiras = await prisma.carteiras.create({
     *   data: {
     *     // ... data to create a Carteiras
     *   }
     * })
     * 
     */
    create<T extends CarteirasCreateArgs>(args: SelectSubset<T, CarteirasCreateArgs<ExtArgs>>): Prisma__CarteirasClient<$Result.GetResult<Prisma.$CarteirasPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Carteiras.
     * @param {CarteirasCreateManyArgs} args - Arguments to create many Carteiras.
     * @example
     * // Create many Carteiras
     * const carteiras = await prisma.carteiras.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CarteirasCreateManyArgs>(args?: SelectSubset<T, CarteirasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Carteiras and returns the data saved in the database.
     * @param {CarteirasCreateManyAndReturnArgs} args - Arguments to create many Carteiras.
     * @example
     * // Create many Carteiras
     * const carteiras = await prisma.carteiras.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Carteiras and only return the `id`
     * const carteirasWithIdOnly = await prisma.carteiras.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CarteirasCreateManyAndReturnArgs>(args?: SelectSubset<T, CarteirasCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CarteirasPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Carteiras.
     * @param {CarteirasDeleteArgs} args - Arguments to delete one Carteiras.
     * @example
     * // Delete one Carteiras
     * const Carteiras = await prisma.carteiras.delete({
     *   where: {
     *     // ... filter to delete one Carteiras
     *   }
     * })
     * 
     */
    delete<T extends CarteirasDeleteArgs>(args: SelectSubset<T, CarteirasDeleteArgs<ExtArgs>>): Prisma__CarteirasClient<$Result.GetResult<Prisma.$CarteirasPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Carteiras.
     * @param {CarteirasUpdateArgs} args - Arguments to update one Carteiras.
     * @example
     * // Update one Carteiras
     * const carteiras = await prisma.carteiras.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CarteirasUpdateArgs>(args: SelectSubset<T, CarteirasUpdateArgs<ExtArgs>>): Prisma__CarteirasClient<$Result.GetResult<Prisma.$CarteirasPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Carteiras.
     * @param {CarteirasDeleteManyArgs} args - Arguments to filter Carteiras to delete.
     * @example
     * // Delete a few Carteiras
     * const { count } = await prisma.carteiras.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CarteirasDeleteManyArgs>(args?: SelectSubset<T, CarteirasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Carteiras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarteirasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Carteiras
     * const carteiras = await prisma.carteiras.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CarteirasUpdateManyArgs>(args: SelectSubset<T, CarteirasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Carteiras and returns the data updated in the database.
     * @param {CarteirasUpdateManyAndReturnArgs} args - Arguments to update many Carteiras.
     * @example
     * // Update many Carteiras
     * const carteiras = await prisma.carteiras.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Carteiras and only return the `id`
     * const carteirasWithIdOnly = await prisma.carteiras.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CarteirasUpdateManyAndReturnArgs>(args: SelectSubset<T, CarteirasUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CarteirasPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Carteiras.
     * @param {CarteirasUpsertArgs} args - Arguments to update or create a Carteiras.
     * @example
     * // Update or create a Carteiras
     * const carteiras = await prisma.carteiras.upsert({
     *   create: {
     *     // ... data to create a Carteiras
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Carteiras we want to update
     *   }
     * })
     */
    upsert<T extends CarteirasUpsertArgs>(args: SelectSubset<T, CarteirasUpsertArgs<ExtArgs>>): Prisma__CarteirasClient<$Result.GetResult<Prisma.$CarteirasPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Carteiras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarteirasCountArgs} args - Arguments to filter Carteiras to count.
     * @example
     * // Count the number of Carteiras
     * const count = await prisma.carteiras.count({
     *   where: {
     *     // ... the filter for the Carteiras we want to count
     *   }
     * })
    **/
    count<T extends CarteirasCountArgs>(
      args?: Subset<T, CarteirasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CarteirasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Carteiras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarteirasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CarteirasAggregateArgs>(args: Subset<T, CarteirasAggregateArgs>): Prisma.PrismaPromise<GetCarteirasAggregateType<T>>

    /**
     * Group by Carteiras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarteirasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CarteirasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CarteirasGroupByArgs['orderBy'] }
        : { orderBy?: CarteirasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CarteirasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCarteirasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Carteiras model
   */
  readonly fields: CarteirasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Carteiras.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CarteirasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Carteiras model
   */
  interface CarteirasFieldRefs {
    readonly id: FieldRef<"Carteiras", 'Int'>
    readonly usuarioId: FieldRef<"Carteiras", 'Int'>
    readonly saldo: FieldRef<"Carteiras", 'Decimal'>
    readonly createdAt: FieldRef<"Carteiras", 'DateTime'>
    readonly updatedAt: FieldRef<"Carteiras", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Carteiras findUnique
   */
  export type CarteirasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carteiras
     */
    select?: CarteirasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carteiras
     */
    omit?: CarteirasOmit<ExtArgs> | null
    /**
     * Filter, which Carteiras to fetch.
     */
    where: CarteirasWhereUniqueInput
  }

  /**
   * Carteiras findUniqueOrThrow
   */
  export type CarteirasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carteiras
     */
    select?: CarteirasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carteiras
     */
    omit?: CarteirasOmit<ExtArgs> | null
    /**
     * Filter, which Carteiras to fetch.
     */
    where: CarteirasWhereUniqueInput
  }

  /**
   * Carteiras findFirst
   */
  export type CarteirasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carteiras
     */
    select?: CarteirasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carteiras
     */
    omit?: CarteirasOmit<ExtArgs> | null
    /**
     * Filter, which Carteiras to fetch.
     */
    where?: CarteirasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carteiras to fetch.
     */
    orderBy?: CarteirasOrderByWithRelationInput | CarteirasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Carteiras.
     */
    cursor?: CarteirasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carteiras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carteiras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Carteiras.
     */
    distinct?: CarteirasScalarFieldEnum | CarteirasScalarFieldEnum[]
  }

  /**
   * Carteiras findFirstOrThrow
   */
  export type CarteirasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carteiras
     */
    select?: CarteirasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carteiras
     */
    omit?: CarteirasOmit<ExtArgs> | null
    /**
     * Filter, which Carteiras to fetch.
     */
    where?: CarteirasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carteiras to fetch.
     */
    orderBy?: CarteirasOrderByWithRelationInput | CarteirasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Carteiras.
     */
    cursor?: CarteirasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carteiras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carteiras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Carteiras.
     */
    distinct?: CarteirasScalarFieldEnum | CarteirasScalarFieldEnum[]
  }

  /**
   * Carteiras findMany
   */
  export type CarteirasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carteiras
     */
    select?: CarteirasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carteiras
     */
    omit?: CarteirasOmit<ExtArgs> | null
    /**
     * Filter, which Carteiras to fetch.
     */
    where?: CarteirasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carteiras to fetch.
     */
    orderBy?: CarteirasOrderByWithRelationInput | CarteirasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Carteiras.
     */
    cursor?: CarteirasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carteiras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carteiras.
     */
    skip?: number
    distinct?: CarteirasScalarFieldEnum | CarteirasScalarFieldEnum[]
  }

  /**
   * Carteiras create
   */
  export type CarteirasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carteiras
     */
    select?: CarteirasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carteiras
     */
    omit?: CarteirasOmit<ExtArgs> | null
    /**
     * The data needed to create a Carteiras.
     */
    data: XOR<CarteirasCreateInput, CarteirasUncheckedCreateInput>
  }

  /**
   * Carteiras createMany
   */
  export type CarteirasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Carteiras.
     */
    data: CarteirasCreateManyInput | CarteirasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Carteiras createManyAndReturn
   */
  export type CarteirasCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carteiras
     */
    select?: CarteirasSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Carteiras
     */
    omit?: CarteirasOmit<ExtArgs> | null
    /**
     * The data used to create many Carteiras.
     */
    data: CarteirasCreateManyInput | CarteirasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Carteiras update
   */
  export type CarteirasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carteiras
     */
    select?: CarteirasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carteiras
     */
    omit?: CarteirasOmit<ExtArgs> | null
    /**
     * The data needed to update a Carteiras.
     */
    data: XOR<CarteirasUpdateInput, CarteirasUncheckedUpdateInput>
    /**
     * Choose, which Carteiras to update.
     */
    where: CarteirasWhereUniqueInput
  }

  /**
   * Carteiras updateMany
   */
  export type CarteirasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Carteiras.
     */
    data: XOR<CarteirasUpdateManyMutationInput, CarteirasUncheckedUpdateManyInput>
    /**
     * Filter which Carteiras to update
     */
    where?: CarteirasWhereInput
    /**
     * Limit how many Carteiras to update.
     */
    limit?: number
  }

  /**
   * Carteiras updateManyAndReturn
   */
  export type CarteirasUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carteiras
     */
    select?: CarteirasSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Carteiras
     */
    omit?: CarteirasOmit<ExtArgs> | null
    /**
     * The data used to update Carteiras.
     */
    data: XOR<CarteirasUpdateManyMutationInput, CarteirasUncheckedUpdateManyInput>
    /**
     * Filter which Carteiras to update
     */
    where?: CarteirasWhereInput
    /**
     * Limit how many Carteiras to update.
     */
    limit?: number
  }

  /**
   * Carteiras upsert
   */
  export type CarteirasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carteiras
     */
    select?: CarteirasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carteiras
     */
    omit?: CarteirasOmit<ExtArgs> | null
    /**
     * The filter to search for the Carteiras to update in case it exists.
     */
    where: CarteirasWhereUniqueInput
    /**
     * In case the Carteiras found by the `where` argument doesn't exist, create a new Carteiras with this data.
     */
    create: XOR<CarteirasCreateInput, CarteirasUncheckedCreateInput>
    /**
     * In case the Carteiras was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CarteirasUpdateInput, CarteirasUncheckedUpdateInput>
  }

  /**
   * Carteiras delete
   */
  export type CarteirasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carteiras
     */
    select?: CarteirasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carteiras
     */
    omit?: CarteirasOmit<ExtArgs> | null
    /**
     * Filter which Carteiras to delete.
     */
    where: CarteirasWhereUniqueInput
  }

  /**
   * Carteiras deleteMany
   */
  export type CarteirasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Carteiras to delete
     */
    where?: CarteirasWhereInput
    /**
     * Limit how many Carteiras to delete.
     */
    limit?: number
  }

  /**
   * Carteiras without action
   */
  export type CarteirasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carteiras
     */
    select?: CarteirasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carteiras
     */
    omit?: CarteirasOmit<ExtArgs> | null
  }


  /**
   * Model CodigoIndicacaos
   */

  export type AggregateCodigoIndicacaos = {
    _count: CodigoIndicacaosCountAggregateOutputType | null
    _avg: CodigoIndicacaosAvgAggregateOutputType | null
    _sum: CodigoIndicacaosSumAggregateOutputType | null
    _min: CodigoIndicacaosMinAggregateOutputType | null
    _max: CodigoIndicacaosMaxAggregateOutputType | null
  }

  export type CodigoIndicacaosAvgAggregateOutputType = {
    id: number | null
    usuarioId: number | null
  }

  export type CodigoIndicacaosSumAggregateOutputType = {
    id: number | null
    usuarioId: number | null
  }

  export type CodigoIndicacaosMinAggregateOutputType = {
    id: number | null
    codigo: string | null
    usuarioId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CodigoIndicacaosMaxAggregateOutputType = {
    id: number | null
    codigo: string | null
    usuarioId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CodigoIndicacaosCountAggregateOutputType = {
    id: number
    codigo: number
    usuarioId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CodigoIndicacaosAvgAggregateInputType = {
    id?: true
    usuarioId?: true
  }

  export type CodigoIndicacaosSumAggregateInputType = {
    id?: true
    usuarioId?: true
  }

  export type CodigoIndicacaosMinAggregateInputType = {
    id?: true
    codigo?: true
    usuarioId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CodigoIndicacaosMaxAggregateInputType = {
    id?: true
    codigo?: true
    usuarioId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CodigoIndicacaosCountAggregateInputType = {
    id?: true
    codigo?: true
    usuarioId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CodigoIndicacaosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CodigoIndicacaos to aggregate.
     */
    where?: CodigoIndicacaosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodigoIndicacaos to fetch.
     */
    orderBy?: CodigoIndicacaosOrderByWithRelationInput | CodigoIndicacaosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CodigoIndicacaosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodigoIndicacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodigoIndicacaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CodigoIndicacaos
    **/
    _count?: true | CodigoIndicacaosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CodigoIndicacaosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CodigoIndicacaosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CodigoIndicacaosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CodigoIndicacaosMaxAggregateInputType
  }

  export type GetCodigoIndicacaosAggregateType<T extends CodigoIndicacaosAggregateArgs> = {
        [P in keyof T & keyof AggregateCodigoIndicacaos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCodigoIndicacaos[P]>
      : GetScalarType<T[P], AggregateCodigoIndicacaos[P]>
  }




  export type CodigoIndicacaosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CodigoIndicacaosWhereInput
    orderBy?: CodigoIndicacaosOrderByWithAggregationInput | CodigoIndicacaosOrderByWithAggregationInput[]
    by: CodigoIndicacaosScalarFieldEnum[] | CodigoIndicacaosScalarFieldEnum
    having?: CodigoIndicacaosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CodigoIndicacaosCountAggregateInputType | true
    _avg?: CodigoIndicacaosAvgAggregateInputType
    _sum?: CodigoIndicacaosSumAggregateInputType
    _min?: CodigoIndicacaosMinAggregateInputType
    _max?: CodigoIndicacaosMaxAggregateInputType
  }

  export type CodigoIndicacaosGroupByOutputType = {
    id: number
    codigo: string
    usuarioId: number
    createdAt: Date
    updatedAt: Date
    _count: CodigoIndicacaosCountAggregateOutputType | null
    _avg: CodigoIndicacaosAvgAggregateOutputType | null
    _sum: CodigoIndicacaosSumAggregateOutputType | null
    _min: CodigoIndicacaosMinAggregateOutputType | null
    _max: CodigoIndicacaosMaxAggregateOutputType | null
  }

  type GetCodigoIndicacaosGroupByPayload<T extends CodigoIndicacaosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CodigoIndicacaosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CodigoIndicacaosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CodigoIndicacaosGroupByOutputType[P]>
            : GetScalarType<T[P], CodigoIndicacaosGroupByOutputType[P]>
        }
      >
    >


  export type CodigoIndicacaosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigo?: boolean
    usuarioId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["codigoIndicacaos"]>

  export type CodigoIndicacaosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigo?: boolean
    usuarioId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["codigoIndicacaos"]>

  export type CodigoIndicacaosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigo?: boolean
    usuarioId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["codigoIndicacaos"]>

  export type CodigoIndicacaosSelectScalar = {
    id?: boolean
    codigo?: boolean
    usuarioId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CodigoIndicacaosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "codigo" | "usuarioId" | "createdAt" | "updatedAt", ExtArgs["result"]["codigoIndicacaos"]>

  export type $CodigoIndicacaosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CodigoIndicacaos"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      codigo: string
      usuarioId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["codigoIndicacaos"]>
    composites: {}
  }

  type CodigoIndicacaosGetPayload<S extends boolean | null | undefined | CodigoIndicacaosDefaultArgs> = $Result.GetResult<Prisma.$CodigoIndicacaosPayload, S>

  type CodigoIndicacaosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CodigoIndicacaosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CodigoIndicacaosCountAggregateInputType | true
    }

  export interface CodigoIndicacaosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CodigoIndicacaos'], meta: { name: 'CodigoIndicacaos' } }
    /**
     * Find zero or one CodigoIndicacaos that matches the filter.
     * @param {CodigoIndicacaosFindUniqueArgs} args - Arguments to find a CodigoIndicacaos
     * @example
     * // Get one CodigoIndicacaos
     * const codigoIndicacaos = await prisma.codigoIndicacaos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CodigoIndicacaosFindUniqueArgs>(args: SelectSubset<T, CodigoIndicacaosFindUniqueArgs<ExtArgs>>): Prisma__CodigoIndicacaosClient<$Result.GetResult<Prisma.$CodigoIndicacaosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CodigoIndicacaos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CodigoIndicacaosFindUniqueOrThrowArgs} args - Arguments to find a CodigoIndicacaos
     * @example
     * // Get one CodigoIndicacaos
     * const codigoIndicacaos = await prisma.codigoIndicacaos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CodigoIndicacaosFindUniqueOrThrowArgs>(args: SelectSubset<T, CodigoIndicacaosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CodigoIndicacaosClient<$Result.GetResult<Prisma.$CodigoIndicacaosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CodigoIndicacaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodigoIndicacaosFindFirstArgs} args - Arguments to find a CodigoIndicacaos
     * @example
     * // Get one CodigoIndicacaos
     * const codigoIndicacaos = await prisma.codigoIndicacaos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CodigoIndicacaosFindFirstArgs>(args?: SelectSubset<T, CodigoIndicacaosFindFirstArgs<ExtArgs>>): Prisma__CodigoIndicacaosClient<$Result.GetResult<Prisma.$CodigoIndicacaosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CodigoIndicacaos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodigoIndicacaosFindFirstOrThrowArgs} args - Arguments to find a CodigoIndicacaos
     * @example
     * // Get one CodigoIndicacaos
     * const codigoIndicacaos = await prisma.codigoIndicacaos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CodigoIndicacaosFindFirstOrThrowArgs>(args?: SelectSubset<T, CodigoIndicacaosFindFirstOrThrowArgs<ExtArgs>>): Prisma__CodigoIndicacaosClient<$Result.GetResult<Prisma.$CodigoIndicacaosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CodigoIndicacaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodigoIndicacaosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CodigoIndicacaos
     * const codigoIndicacaos = await prisma.codigoIndicacaos.findMany()
     * 
     * // Get first 10 CodigoIndicacaos
     * const codigoIndicacaos = await prisma.codigoIndicacaos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const codigoIndicacaosWithIdOnly = await prisma.codigoIndicacaos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CodigoIndicacaosFindManyArgs>(args?: SelectSubset<T, CodigoIndicacaosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CodigoIndicacaosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CodigoIndicacaos.
     * @param {CodigoIndicacaosCreateArgs} args - Arguments to create a CodigoIndicacaos.
     * @example
     * // Create one CodigoIndicacaos
     * const CodigoIndicacaos = await prisma.codigoIndicacaos.create({
     *   data: {
     *     // ... data to create a CodigoIndicacaos
     *   }
     * })
     * 
     */
    create<T extends CodigoIndicacaosCreateArgs>(args: SelectSubset<T, CodigoIndicacaosCreateArgs<ExtArgs>>): Prisma__CodigoIndicacaosClient<$Result.GetResult<Prisma.$CodigoIndicacaosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CodigoIndicacaos.
     * @param {CodigoIndicacaosCreateManyArgs} args - Arguments to create many CodigoIndicacaos.
     * @example
     * // Create many CodigoIndicacaos
     * const codigoIndicacaos = await prisma.codigoIndicacaos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CodigoIndicacaosCreateManyArgs>(args?: SelectSubset<T, CodigoIndicacaosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CodigoIndicacaos and returns the data saved in the database.
     * @param {CodigoIndicacaosCreateManyAndReturnArgs} args - Arguments to create many CodigoIndicacaos.
     * @example
     * // Create many CodigoIndicacaos
     * const codigoIndicacaos = await prisma.codigoIndicacaos.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CodigoIndicacaos and only return the `id`
     * const codigoIndicacaosWithIdOnly = await prisma.codigoIndicacaos.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CodigoIndicacaosCreateManyAndReturnArgs>(args?: SelectSubset<T, CodigoIndicacaosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CodigoIndicacaosPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CodigoIndicacaos.
     * @param {CodigoIndicacaosDeleteArgs} args - Arguments to delete one CodigoIndicacaos.
     * @example
     * // Delete one CodigoIndicacaos
     * const CodigoIndicacaos = await prisma.codigoIndicacaos.delete({
     *   where: {
     *     // ... filter to delete one CodigoIndicacaos
     *   }
     * })
     * 
     */
    delete<T extends CodigoIndicacaosDeleteArgs>(args: SelectSubset<T, CodigoIndicacaosDeleteArgs<ExtArgs>>): Prisma__CodigoIndicacaosClient<$Result.GetResult<Prisma.$CodigoIndicacaosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CodigoIndicacaos.
     * @param {CodigoIndicacaosUpdateArgs} args - Arguments to update one CodigoIndicacaos.
     * @example
     * // Update one CodigoIndicacaos
     * const codigoIndicacaos = await prisma.codigoIndicacaos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CodigoIndicacaosUpdateArgs>(args: SelectSubset<T, CodigoIndicacaosUpdateArgs<ExtArgs>>): Prisma__CodigoIndicacaosClient<$Result.GetResult<Prisma.$CodigoIndicacaosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CodigoIndicacaos.
     * @param {CodigoIndicacaosDeleteManyArgs} args - Arguments to filter CodigoIndicacaos to delete.
     * @example
     * // Delete a few CodigoIndicacaos
     * const { count } = await prisma.codigoIndicacaos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CodigoIndicacaosDeleteManyArgs>(args?: SelectSubset<T, CodigoIndicacaosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CodigoIndicacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodigoIndicacaosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CodigoIndicacaos
     * const codigoIndicacaos = await prisma.codigoIndicacaos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CodigoIndicacaosUpdateManyArgs>(args: SelectSubset<T, CodigoIndicacaosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CodigoIndicacaos and returns the data updated in the database.
     * @param {CodigoIndicacaosUpdateManyAndReturnArgs} args - Arguments to update many CodigoIndicacaos.
     * @example
     * // Update many CodigoIndicacaos
     * const codigoIndicacaos = await prisma.codigoIndicacaos.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CodigoIndicacaos and only return the `id`
     * const codigoIndicacaosWithIdOnly = await prisma.codigoIndicacaos.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CodigoIndicacaosUpdateManyAndReturnArgs>(args: SelectSubset<T, CodigoIndicacaosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CodigoIndicacaosPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CodigoIndicacaos.
     * @param {CodigoIndicacaosUpsertArgs} args - Arguments to update or create a CodigoIndicacaos.
     * @example
     * // Update or create a CodigoIndicacaos
     * const codigoIndicacaos = await prisma.codigoIndicacaos.upsert({
     *   create: {
     *     // ... data to create a CodigoIndicacaos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CodigoIndicacaos we want to update
     *   }
     * })
     */
    upsert<T extends CodigoIndicacaosUpsertArgs>(args: SelectSubset<T, CodigoIndicacaosUpsertArgs<ExtArgs>>): Prisma__CodigoIndicacaosClient<$Result.GetResult<Prisma.$CodigoIndicacaosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CodigoIndicacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodigoIndicacaosCountArgs} args - Arguments to filter CodigoIndicacaos to count.
     * @example
     * // Count the number of CodigoIndicacaos
     * const count = await prisma.codigoIndicacaos.count({
     *   where: {
     *     // ... the filter for the CodigoIndicacaos we want to count
     *   }
     * })
    **/
    count<T extends CodigoIndicacaosCountArgs>(
      args?: Subset<T, CodigoIndicacaosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CodigoIndicacaosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CodigoIndicacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodigoIndicacaosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CodigoIndicacaosAggregateArgs>(args: Subset<T, CodigoIndicacaosAggregateArgs>): Prisma.PrismaPromise<GetCodigoIndicacaosAggregateType<T>>

    /**
     * Group by CodigoIndicacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodigoIndicacaosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CodigoIndicacaosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CodigoIndicacaosGroupByArgs['orderBy'] }
        : { orderBy?: CodigoIndicacaosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CodigoIndicacaosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCodigoIndicacaosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CodigoIndicacaos model
   */
  readonly fields: CodigoIndicacaosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CodigoIndicacaos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CodigoIndicacaosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CodigoIndicacaos model
   */
  interface CodigoIndicacaosFieldRefs {
    readonly id: FieldRef<"CodigoIndicacaos", 'Int'>
    readonly codigo: FieldRef<"CodigoIndicacaos", 'String'>
    readonly usuarioId: FieldRef<"CodigoIndicacaos", 'Int'>
    readonly createdAt: FieldRef<"CodigoIndicacaos", 'DateTime'>
    readonly updatedAt: FieldRef<"CodigoIndicacaos", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CodigoIndicacaos findUnique
   */
  export type CodigoIndicacaosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodigoIndicacaos
     */
    select?: CodigoIndicacaosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodigoIndicacaos
     */
    omit?: CodigoIndicacaosOmit<ExtArgs> | null
    /**
     * Filter, which CodigoIndicacaos to fetch.
     */
    where: CodigoIndicacaosWhereUniqueInput
  }

  /**
   * CodigoIndicacaos findUniqueOrThrow
   */
  export type CodigoIndicacaosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodigoIndicacaos
     */
    select?: CodigoIndicacaosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodigoIndicacaos
     */
    omit?: CodigoIndicacaosOmit<ExtArgs> | null
    /**
     * Filter, which CodigoIndicacaos to fetch.
     */
    where: CodigoIndicacaosWhereUniqueInput
  }

  /**
   * CodigoIndicacaos findFirst
   */
  export type CodigoIndicacaosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodigoIndicacaos
     */
    select?: CodigoIndicacaosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodigoIndicacaos
     */
    omit?: CodigoIndicacaosOmit<ExtArgs> | null
    /**
     * Filter, which CodigoIndicacaos to fetch.
     */
    where?: CodigoIndicacaosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodigoIndicacaos to fetch.
     */
    orderBy?: CodigoIndicacaosOrderByWithRelationInput | CodigoIndicacaosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CodigoIndicacaos.
     */
    cursor?: CodigoIndicacaosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodigoIndicacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodigoIndicacaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CodigoIndicacaos.
     */
    distinct?: CodigoIndicacaosScalarFieldEnum | CodigoIndicacaosScalarFieldEnum[]
  }

  /**
   * CodigoIndicacaos findFirstOrThrow
   */
  export type CodigoIndicacaosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodigoIndicacaos
     */
    select?: CodigoIndicacaosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodigoIndicacaos
     */
    omit?: CodigoIndicacaosOmit<ExtArgs> | null
    /**
     * Filter, which CodigoIndicacaos to fetch.
     */
    where?: CodigoIndicacaosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodigoIndicacaos to fetch.
     */
    orderBy?: CodigoIndicacaosOrderByWithRelationInput | CodigoIndicacaosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CodigoIndicacaos.
     */
    cursor?: CodigoIndicacaosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodigoIndicacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodigoIndicacaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CodigoIndicacaos.
     */
    distinct?: CodigoIndicacaosScalarFieldEnum | CodigoIndicacaosScalarFieldEnum[]
  }

  /**
   * CodigoIndicacaos findMany
   */
  export type CodigoIndicacaosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodigoIndicacaos
     */
    select?: CodigoIndicacaosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodigoIndicacaos
     */
    omit?: CodigoIndicacaosOmit<ExtArgs> | null
    /**
     * Filter, which CodigoIndicacaos to fetch.
     */
    where?: CodigoIndicacaosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodigoIndicacaos to fetch.
     */
    orderBy?: CodigoIndicacaosOrderByWithRelationInput | CodigoIndicacaosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CodigoIndicacaos.
     */
    cursor?: CodigoIndicacaosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodigoIndicacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodigoIndicacaos.
     */
    skip?: number
    distinct?: CodigoIndicacaosScalarFieldEnum | CodigoIndicacaosScalarFieldEnum[]
  }

  /**
   * CodigoIndicacaos create
   */
  export type CodigoIndicacaosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodigoIndicacaos
     */
    select?: CodigoIndicacaosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodigoIndicacaos
     */
    omit?: CodigoIndicacaosOmit<ExtArgs> | null
    /**
     * The data needed to create a CodigoIndicacaos.
     */
    data: XOR<CodigoIndicacaosCreateInput, CodigoIndicacaosUncheckedCreateInput>
  }

  /**
   * CodigoIndicacaos createMany
   */
  export type CodigoIndicacaosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CodigoIndicacaos.
     */
    data: CodigoIndicacaosCreateManyInput | CodigoIndicacaosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CodigoIndicacaos createManyAndReturn
   */
  export type CodigoIndicacaosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodigoIndicacaos
     */
    select?: CodigoIndicacaosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CodigoIndicacaos
     */
    omit?: CodigoIndicacaosOmit<ExtArgs> | null
    /**
     * The data used to create many CodigoIndicacaos.
     */
    data: CodigoIndicacaosCreateManyInput | CodigoIndicacaosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CodigoIndicacaos update
   */
  export type CodigoIndicacaosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodigoIndicacaos
     */
    select?: CodigoIndicacaosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodigoIndicacaos
     */
    omit?: CodigoIndicacaosOmit<ExtArgs> | null
    /**
     * The data needed to update a CodigoIndicacaos.
     */
    data: XOR<CodigoIndicacaosUpdateInput, CodigoIndicacaosUncheckedUpdateInput>
    /**
     * Choose, which CodigoIndicacaos to update.
     */
    where: CodigoIndicacaosWhereUniqueInput
  }

  /**
   * CodigoIndicacaos updateMany
   */
  export type CodigoIndicacaosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CodigoIndicacaos.
     */
    data: XOR<CodigoIndicacaosUpdateManyMutationInput, CodigoIndicacaosUncheckedUpdateManyInput>
    /**
     * Filter which CodigoIndicacaos to update
     */
    where?: CodigoIndicacaosWhereInput
    /**
     * Limit how many CodigoIndicacaos to update.
     */
    limit?: number
  }

  /**
   * CodigoIndicacaos updateManyAndReturn
   */
  export type CodigoIndicacaosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodigoIndicacaos
     */
    select?: CodigoIndicacaosSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CodigoIndicacaos
     */
    omit?: CodigoIndicacaosOmit<ExtArgs> | null
    /**
     * The data used to update CodigoIndicacaos.
     */
    data: XOR<CodigoIndicacaosUpdateManyMutationInput, CodigoIndicacaosUncheckedUpdateManyInput>
    /**
     * Filter which CodigoIndicacaos to update
     */
    where?: CodigoIndicacaosWhereInput
    /**
     * Limit how many CodigoIndicacaos to update.
     */
    limit?: number
  }

  /**
   * CodigoIndicacaos upsert
   */
  export type CodigoIndicacaosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodigoIndicacaos
     */
    select?: CodigoIndicacaosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodigoIndicacaos
     */
    omit?: CodigoIndicacaosOmit<ExtArgs> | null
    /**
     * The filter to search for the CodigoIndicacaos to update in case it exists.
     */
    where: CodigoIndicacaosWhereUniqueInput
    /**
     * In case the CodigoIndicacaos found by the `where` argument doesn't exist, create a new CodigoIndicacaos with this data.
     */
    create: XOR<CodigoIndicacaosCreateInput, CodigoIndicacaosUncheckedCreateInput>
    /**
     * In case the CodigoIndicacaos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CodigoIndicacaosUpdateInput, CodigoIndicacaosUncheckedUpdateInput>
  }

  /**
   * CodigoIndicacaos delete
   */
  export type CodigoIndicacaosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodigoIndicacaos
     */
    select?: CodigoIndicacaosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodigoIndicacaos
     */
    omit?: CodigoIndicacaosOmit<ExtArgs> | null
    /**
     * Filter which CodigoIndicacaos to delete.
     */
    where: CodigoIndicacaosWhereUniqueInput
  }

  /**
   * CodigoIndicacaos deleteMany
   */
  export type CodigoIndicacaosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CodigoIndicacaos to delete
     */
    where?: CodigoIndicacaosWhereInput
    /**
     * Limit how many CodigoIndicacaos to delete.
     */
    limit?: number
  }

  /**
   * CodigoIndicacaos without action
   */
  export type CodigoIndicacaosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodigoIndicacaos
     */
    select?: CodigoIndicacaosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodigoIndicacaos
     */
    omit?: CodigoIndicacaosOmit<ExtArgs> | null
  }


  /**
   * Model CorridaAgendadas
   */

  export type AggregateCorridaAgendadas = {
    _count: CorridaAgendadasCountAggregateOutputType | null
    _avg: CorridaAgendadasAvgAggregateOutputType | null
    _sum: CorridaAgendadasSumAggregateOutputType | null
    _min: CorridaAgendadasMinAggregateOutputType | null
    _max: CorridaAgendadasMaxAggregateOutputType | null
  }

  export type CorridaAgendadasAvgAggregateOutputType = {
    id: number | null
    valor: number | null
  }

  export type CorridaAgendadasSumAggregateOutputType = {
    id: number | null
    valor: number | null
  }

  export type CorridaAgendadasMinAggregateOutputType = {
    id: number | null
    passageiroCpf: string | null
    motoristaCpf: string | null
    origem: string | null
    destino: string | null
    dataHoraAgendada: Date | null
    status: string | null
    tipo: string | null
    valor: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CorridaAgendadasMaxAggregateOutputType = {
    id: number | null
    passageiroCpf: string | null
    motoristaCpf: string | null
    origem: string | null
    destino: string | null
    dataHoraAgendada: Date | null
    status: string | null
    tipo: string | null
    valor: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CorridaAgendadasCountAggregateOutputType = {
    id: number
    passageiroCpf: number
    motoristaCpf: number
    origem: number
    destino: number
    dataHoraAgendada: number
    status: number
    tipo: number
    valor: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CorridaAgendadasAvgAggregateInputType = {
    id?: true
    valor?: true
  }

  export type CorridaAgendadasSumAggregateInputType = {
    id?: true
    valor?: true
  }

  export type CorridaAgendadasMinAggregateInputType = {
    id?: true
    passageiroCpf?: true
    motoristaCpf?: true
    origem?: true
    destino?: true
    dataHoraAgendada?: true
    status?: true
    tipo?: true
    valor?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CorridaAgendadasMaxAggregateInputType = {
    id?: true
    passageiroCpf?: true
    motoristaCpf?: true
    origem?: true
    destino?: true
    dataHoraAgendada?: true
    status?: true
    tipo?: true
    valor?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CorridaAgendadasCountAggregateInputType = {
    id?: true
    passageiroCpf?: true
    motoristaCpf?: true
    origem?: true
    destino?: true
    dataHoraAgendada?: true
    status?: true
    tipo?: true
    valor?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CorridaAgendadasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CorridaAgendadas to aggregate.
     */
    where?: CorridaAgendadasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CorridaAgendadas to fetch.
     */
    orderBy?: CorridaAgendadasOrderByWithRelationInput | CorridaAgendadasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CorridaAgendadasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CorridaAgendadas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CorridaAgendadas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CorridaAgendadas
    **/
    _count?: true | CorridaAgendadasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CorridaAgendadasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CorridaAgendadasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CorridaAgendadasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CorridaAgendadasMaxAggregateInputType
  }

  export type GetCorridaAgendadasAggregateType<T extends CorridaAgendadasAggregateArgs> = {
        [P in keyof T & keyof AggregateCorridaAgendadas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCorridaAgendadas[P]>
      : GetScalarType<T[P], AggregateCorridaAgendadas[P]>
  }




  export type CorridaAgendadasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CorridaAgendadasWhereInput
    orderBy?: CorridaAgendadasOrderByWithAggregationInput | CorridaAgendadasOrderByWithAggregationInput[]
    by: CorridaAgendadasScalarFieldEnum[] | CorridaAgendadasScalarFieldEnum
    having?: CorridaAgendadasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CorridaAgendadasCountAggregateInputType | true
    _avg?: CorridaAgendadasAvgAggregateInputType
    _sum?: CorridaAgendadasSumAggregateInputType
    _min?: CorridaAgendadasMinAggregateInputType
    _max?: CorridaAgendadasMaxAggregateInputType
  }

  export type CorridaAgendadasGroupByOutputType = {
    id: number
    passageiroCpf: string
    motoristaCpf: string | null
    origem: string
    destino: string
    dataHoraAgendada: Date
    status: string | null
    tipo: string
    valor: number | null
    createdAt: Date
    updatedAt: Date
    _count: CorridaAgendadasCountAggregateOutputType | null
    _avg: CorridaAgendadasAvgAggregateOutputType | null
    _sum: CorridaAgendadasSumAggregateOutputType | null
    _min: CorridaAgendadasMinAggregateOutputType | null
    _max: CorridaAgendadasMaxAggregateOutputType | null
  }

  type GetCorridaAgendadasGroupByPayload<T extends CorridaAgendadasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CorridaAgendadasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CorridaAgendadasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CorridaAgendadasGroupByOutputType[P]>
            : GetScalarType<T[P], CorridaAgendadasGroupByOutputType[P]>
        }
      >
    >


  export type CorridaAgendadasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    passageiroCpf?: boolean
    motoristaCpf?: boolean
    origem?: boolean
    destino?: boolean
    dataHoraAgendada?: boolean
    status?: boolean
    tipo?: boolean
    valor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["corridaAgendadas"]>

  export type CorridaAgendadasSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    passageiroCpf?: boolean
    motoristaCpf?: boolean
    origem?: boolean
    destino?: boolean
    dataHoraAgendada?: boolean
    status?: boolean
    tipo?: boolean
    valor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["corridaAgendadas"]>

  export type CorridaAgendadasSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    passageiroCpf?: boolean
    motoristaCpf?: boolean
    origem?: boolean
    destino?: boolean
    dataHoraAgendada?: boolean
    status?: boolean
    tipo?: boolean
    valor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["corridaAgendadas"]>

  export type CorridaAgendadasSelectScalar = {
    id?: boolean
    passageiroCpf?: boolean
    motoristaCpf?: boolean
    origem?: boolean
    destino?: boolean
    dataHoraAgendada?: boolean
    status?: boolean
    tipo?: boolean
    valor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CorridaAgendadasOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "passageiroCpf" | "motoristaCpf" | "origem" | "destino" | "dataHoraAgendada" | "status" | "tipo" | "valor" | "createdAt" | "updatedAt", ExtArgs["result"]["corridaAgendadas"]>

  export type $CorridaAgendadasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CorridaAgendadas"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      passageiroCpf: string
      motoristaCpf: string | null
      origem: string
      destino: string
      dataHoraAgendada: Date
      status: string | null
      tipo: string
      valor: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["corridaAgendadas"]>
    composites: {}
  }

  type CorridaAgendadasGetPayload<S extends boolean | null | undefined | CorridaAgendadasDefaultArgs> = $Result.GetResult<Prisma.$CorridaAgendadasPayload, S>

  type CorridaAgendadasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CorridaAgendadasFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CorridaAgendadasCountAggregateInputType | true
    }

  export interface CorridaAgendadasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CorridaAgendadas'], meta: { name: 'CorridaAgendadas' } }
    /**
     * Find zero or one CorridaAgendadas that matches the filter.
     * @param {CorridaAgendadasFindUniqueArgs} args - Arguments to find a CorridaAgendadas
     * @example
     * // Get one CorridaAgendadas
     * const corridaAgendadas = await prisma.corridaAgendadas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CorridaAgendadasFindUniqueArgs>(args: SelectSubset<T, CorridaAgendadasFindUniqueArgs<ExtArgs>>): Prisma__CorridaAgendadasClient<$Result.GetResult<Prisma.$CorridaAgendadasPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CorridaAgendadas that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CorridaAgendadasFindUniqueOrThrowArgs} args - Arguments to find a CorridaAgendadas
     * @example
     * // Get one CorridaAgendadas
     * const corridaAgendadas = await prisma.corridaAgendadas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CorridaAgendadasFindUniqueOrThrowArgs>(args: SelectSubset<T, CorridaAgendadasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CorridaAgendadasClient<$Result.GetResult<Prisma.$CorridaAgendadasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CorridaAgendadas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorridaAgendadasFindFirstArgs} args - Arguments to find a CorridaAgendadas
     * @example
     * // Get one CorridaAgendadas
     * const corridaAgendadas = await prisma.corridaAgendadas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CorridaAgendadasFindFirstArgs>(args?: SelectSubset<T, CorridaAgendadasFindFirstArgs<ExtArgs>>): Prisma__CorridaAgendadasClient<$Result.GetResult<Prisma.$CorridaAgendadasPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CorridaAgendadas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorridaAgendadasFindFirstOrThrowArgs} args - Arguments to find a CorridaAgendadas
     * @example
     * // Get one CorridaAgendadas
     * const corridaAgendadas = await prisma.corridaAgendadas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CorridaAgendadasFindFirstOrThrowArgs>(args?: SelectSubset<T, CorridaAgendadasFindFirstOrThrowArgs<ExtArgs>>): Prisma__CorridaAgendadasClient<$Result.GetResult<Prisma.$CorridaAgendadasPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CorridaAgendadas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorridaAgendadasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CorridaAgendadas
     * const corridaAgendadas = await prisma.corridaAgendadas.findMany()
     * 
     * // Get first 10 CorridaAgendadas
     * const corridaAgendadas = await prisma.corridaAgendadas.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const corridaAgendadasWithIdOnly = await prisma.corridaAgendadas.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CorridaAgendadasFindManyArgs>(args?: SelectSubset<T, CorridaAgendadasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CorridaAgendadasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CorridaAgendadas.
     * @param {CorridaAgendadasCreateArgs} args - Arguments to create a CorridaAgendadas.
     * @example
     * // Create one CorridaAgendadas
     * const CorridaAgendadas = await prisma.corridaAgendadas.create({
     *   data: {
     *     // ... data to create a CorridaAgendadas
     *   }
     * })
     * 
     */
    create<T extends CorridaAgendadasCreateArgs>(args: SelectSubset<T, CorridaAgendadasCreateArgs<ExtArgs>>): Prisma__CorridaAgendadasClient<$Result.GetResult<Prisma.$CorridaAgendadasPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CorridaAgendadas.
     * @param {CorridaAgendadasCreateManyArgs} args - Arguments to create many CorridaAgendadas.
     * @example
     * // Create many CorridaAgendadas
     * const corridaAgendadas = await prisma.corridaAgendadas.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CorridaAgendadasCreateManyArgs>(args?: SelectSubset<T, CorridaAgendadasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CorridaAgendadas and returns the data saved in the database.
     * @param {CorridaAgendadasCreateManyAndReturnArgs} args - Arguments to create many CorridaAgendadas.
     * @example
     * // Create many CorridaAgendadas
     * const corridaAgendadas = await prisma.corridaAgendadas.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CorridaAgendadas and only return the `id`
     * const corridaAgendadasWithIdOnly = await prisma.corridaAgendadas.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CorridaAgendadasCreateManyAndReturnArgs>(args?: SelectSubset<T, CorridaAgendadasCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CorridaAgendadasPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CorridaAgendadas.
     * @param {CorridaAgendadasDeleteArgs} args - Arguments to delete one CorridaAgendadas.
     * @example
     * // Delete one CorridaAgendadas
     * const CorridaAgendadas = await prisma.corridaAgendadas.delete({
     *   where: {
     *     // ... filter to delete one CorridaAgendadas
     *   }
     * })
     * 
     */
    delete<T extends CorridaAgendadasDeleteArgs>(args: SelectSubset<T, CorridaAgendadasDeleteArgs<ExtArgs>>): Prisma__CorridaAgendadasClient<$Result.GetResult<Prisma.$CorridaAgendadasPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CorridaAgendadas.
     * @param {CorridaAgendadasUpdateArgs} args - Arguments to update one CorridaAgendadas.
     * @example
     * // Update one CorridaAgendadas
     * const corridaAgendadas = await prisma.corridaAgendadas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CorridaAgendadasUpdateArgs>(args: SelectSubset<T, CorridaAgendadasUpdateArgs<ExtArgs>>): Prisma__CorridaAgendadasClient<$Result.GetResult<Prisma.$CorridaAgendadasPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CorridaAgendadas.
     * @param {CorridaAgendadasDeleteManyArgs} args - Arguments to filter CorridaAgendadas to delete.
     * @example
     * // Delete a few CorridaAgendadas
     * const { count } = await prisma.corridaAgendadas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CorridaAgendadasDeleteManyArgs>(args?: SelectSubset<T, CorridaAgendadasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CorridaAgendadas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorridaAgendadasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CorridaAgendadas
     * const corridaAgendadas = await prisma.corridaAgendadas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CorridaAgendadasUpdateManyArgs>(args: SelectSubset<T, CorridaAgendadasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CorridaAgendadas and returns the data updated in the database.
     * @param {CorridaAgendadasUpdateManyAndReturnArgs} args - Arguments to update many CorridaAgendadas.
     * @example
     * // Update many CorridaAgendadas
     * const corridaAgendadas = await prisma.corridaAgendadas.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CorridaAgendadas and only return the `id`
     * const corridaAgendadasWithIdOnly = await prisma.corridaAgendadas.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CorridaAgendadasUpdateManyAndReturnArgs>(args: SelectSubset<T, CorridaAgendadasUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CorridaAgendadasPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CorridaAgendadas.
     * @param {CorridaAgendadasUpsertArgs} args - Arguments to update or create a CorridaAgendadas.
     * @example
     * // Update or create a CorridaAgendadas
     * const corridaAgendadas = await prisma.corridaAgendadas.upsert({
     *   create: {
     *     // ... data to create a CorridaAgendadas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CorridaAgendadas we want to update
     *   }
     * })
     */
    upsert<T extends CorridaAgendadasUpsertArgs>(args: SelectSubset<T, CorridaAgendadasUpsertArgs<ExtArgs>>): Prisma__CorridaAgendadasClient<$Result.GetResult<Prisma.$CorridaAgendadasPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CorridaAgendadas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorridaAgendadasCountArgs} args - Arguments to filter CorridaAgendadas to count.
     * @example
     * // Count the number of CorridaAgendadas
     * const count = await prisma.corridaAgendadas.count({
     *   where: {
     *     // ... the filter for the CorridaAgendadas we want to count
     *   }
     * })
    **/
    count<T extends CorridaAgendadasCountArgs>(
      args?: Subset<T, CorridaAgendadasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CorridaAgendadasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CorridaAgendadas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorridaAgendadasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CorridaAgendadasAggregateArgs>(args: Subset<T, CorridaAgendadasAggregateArgs>): Prisma.PrismaPromise<GetCorridaAgendadasAggregateType<T>>

    /**
     * Group by CorridaAgendadas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorridaAgendadasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CorridaAgendadasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CorridaAgendadasGroupByArgs['orderBy'] }
        : { orderBy?: CorridaAgendadasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CorridaAgendadasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCorridaAgendadasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CorridaAgendadas model
   */
  readonly fields: CorridaAgendadasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CorridaAgendadas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CorridaAgendadasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CorridaAgendadas model
   */
  interface CorridaAgendadasFieldRefs {
    readonly id: FieldRef<"CorridaAgendadas", 'Int'>
    readonly passageiroCpf: FieldRef<"CorridaAgendadas", 'String'>
    readonly motoristaCpf: FieldRef<"CorridaAgendadas", 'String'>
    readonly origem: FieldRef<"CorridaAgendadas", 'String'>
    readonly destino: FieldRef<"CorridaAgendadas", 'String'>
    readonly dataHoraAgendada: FieldRef<"CorridaAgendadas", 'DateTime'>
    readonly status: FieldRef<"CorridaAgendadas", 'String'>
    readonly tipo: FieldRef<"CorridaAgendadas", 'String'>
    readonly valor: FieldRef<"CorridaAgendadas", 'Float'>
    readonly createdAt: FieldRef<"CorridaAgendadas", 'DateTime'>
    readonly updatedAt: FieldRef<"CorridaAgendadas", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CorridaAgendadas findUnique
   */
  export type CorridaAgendadasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorridaAgendadas
     */
    select?: CorridaAgendadasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CorridaAgendadas
     */
    omit?: CorridaAgendadasOmit<ExtArgs> | null
    /**
     * Filter, which CorridaAgendadas to fetch.
     */
    where: CorridaAgendadasWhereUniqueInput
  }

  /**
   * CorridaAgendadas findUniqueOrThrow
   */
  export type CorridaAgendadasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorridaAgendadas
     */
    select?: CorridaAgendadasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CorridaAgendadas
     */
    omit?: CorridaAgendadasOmit<ExtArgs> | null
    /**
     * Filter, which CorridaAgendadas to fetch.
     */
    where: CorridaAgendadasWhereUniqueInput
  }

  /**
   * CorridaAgendadas findFirst
   */
  export type CorridaAgendadasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorridaAgendadas
     */
    select?: CorridaAgendadasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CorridaAgendadas
     */
    omit?: CorridaAgendadasOmit<ExtArgs> | null
    /**
     * Filter, which CorridaAgendadas to fetch.
     */
    where?: CorridaAgendadasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CorridaAgendadas to fetch.
     */
    orderBy?: CorridaAgendadasOrderByWithRelationInput | CorridaAgendadasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CorridaAgendadas.
     */
    cursor?: CorridaAgendadasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CorridaAgendadas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CorridaAgendadas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CorridaAgendadas.
     */
    distinct?: CorridaAgendadasScalarFieldEnum | CorridaAgendadasScalarFieldEnum[]
  }

  /**
   * CorridaAgendadas findFirstOrThrow
   */
  export type CorridaAgendadasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorridaAgendadas
     */
    select?: CorridaAgendadasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CorridaAgendadas
     */
    omit?: CorridaAgendadasOmit<ExtArgs> | null
    /**
     * Filter, which CorridaAgendadas to fetch.
     */
    where?: CorridaAgendadasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CorridaAgendadas to fetch.
     */
    orderBy?: CorridaAgendadasOrderByWithRelationInput | CorridaAgendadasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CorridaAgendadas.
     */
    cursor?: CorridaAgendadasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CorridaAgendadas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CorridaAgendadas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CorridaAgendadas.
     */
    distinct?: CorridaAgendadasScalarFieldEnum | CorridaAgendadasScalarFieldEnum[]
  }

  /**
   * CorridaAgendadas findMany
   */
  export type CorridaAgendadasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorridaAgendadas
     */
    select?: CorridaAgendadasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CorridaAgendadas
     */
    omit?: CorridaAgendadasOmit<ExtArgs> | null
    /**
     * Filter, which CorridaAgendadas to fetch.
     */
    where?: CorridaAgendadasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CorridaAgendadas to fetch.
     */
    orderBy?: CorridaAgendadasOrderByWithRelationInput | CorridaAgendadasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CorridaAgendadas.
     */
    cursor?: CorridaAgendadasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CorridaAgendadas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CorridaAgendadas.
     */
    skip?: number
    distinct?: CorridaAgendadasScalarFieldEnum | CorridaAgendadasScalarFieldEnum[]
  }

  /**
   * CorridaAgendadas create
   */
  export type CorridaAgendadasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorridaAgendadas
     */
    select?: CorridaAgendadasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CorridaAgendadas
     */
    omit?: CorridaAgendadasOmit<ExtArgs> | null
    /**
     * The data needed to create a CorridaAgendadas.
     */
    data: XOR<CorridaAgendadasCreateInput, CorridaAgendadasUncheckedCreateInput>
  }

  /**
   * CorridaAgendadas createMany
   */
  export type CorridaAgendadasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CorridaAgendadas.
     */
    data: CorridaAgendadasCreateManyInput | CorridaAgendadasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CorridaAgendadas createManyAndReturn
   */
  export type CorridaAgendadasCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorridaAgendadas
     */
    select?: CorridaAgendadasSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CorridaAgendadas
     */
    omit?: CorridaAgendadasOmit<ExtArgs> | null
    /**
     * The data used to create many CorridaAgendadas.
     */
    data: CorridaAgendadasCreateManyInput | CorridaAgendadasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CorridaAgendadas update
   */
  export type CorridaAgendadasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorridaAgendadas
     */
    select?: CorridaAgendadasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CorridaAgendadas
     */
    omit?: CorridaAgendadasOmit<ExtArgs> | null
    /**
     * The data needed to update a CorridaAgendadas.
     */
    data: XOR<CorridaAgendadasUpdateInput, CorridaAgendadasUncheckedUpdateInput>
    /**
     * Choose, which CorridaAgendadas to update.
     */
    where: CorridaAgendadasWhereUniqueInput
  }

  /**
   * CorridaAgendadas updateMany
   */
  export type CorridaAgendadasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CorridaAgendadas.
     */
    data: XOR<CorridaAgendadasUpdateManyMutationInput, CorridaAgendadasUncheckedUpdateManyInput>
    /**
     * Filter which CorridaAgendadas to update
     */
    where?: CorridaAgendadasWhereInput
    /**
     * Limit how many CorridaAgendadas to update.
     */
    limit?: number
  }

  /**
   * CorridaAgendadas updateManyAndReturn
   */
  export type CorridaAgendadasUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorridaAgendadas
     */
    select?: CorridaAgendadasSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CorridaAgendadas
     */
    omit?: CorridaAgendadasOmit<ExtArgs> | null
    /**
     * The data used to update CorridaAgendadas.
     */
    data: XOR<CorridaAgendadasUpdateManyMutationInput, CorridaAgendadasUncheckedUpdateManyInput>
    /**
     * Filter which CorridaAgendadas to update
     */
    where?: CorridaAgendadasWhereInput
    /**
     * Limit how many CorridaAgendadas to update.
     */
    limit?: number
  }

  /**
   * CorridaAgendadas upsert
   */
  export type CorridaAgendadasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorridaAgendadas
     */
    select?: CorridaAgendadasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CorridaAgendadas
     */
    omit?: CorridaAgendadasOmit<ExtArgs> | null
    /**
     * The filter to search for the CorridaAgendadas to update in case it exists.
     */
    where: CorridaAgendadasWhereUniqueInput
    /**
     * In case the CorridaAgendadas found by the `where` argument doesn't exist, create a new CorridaAgendadas with this data.
     */
    create: XOR<CorridaAgendadasCreateInput, CorridaAgendadasUncheckedCreateInput>
    /**
     * In case the CorridaAgendadas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CorridaAgendadasUpdateInput, CorridaAgendadasUncheckedUpdateInput>
  }

  /**
   * CorridaAgendadas delete
   */
  export type CorridaAgendadasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorridaAgendadas
     */
    select?: CorridaAgendadasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CorridaAgendadas
     */
    omit?: CorridaAgendadasOmit<ExtArgs> | null
    /**
     * Filter which CorridaAgendadas to delete.
     */
    where: CorridaAgendadasWhereUniqueInput
  }

  /**
   * CorridaAgendadas deleteMany
   */
  export type CorridaAgendadasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CorridaAgendadas to delete
     */
    where?: CorridaAgendadasWhereInput
    /**
     * Limit how many CorridaAgendadas to delete.
     */
    limit?: number
  }

  /**
   * CorridaAgendadas without action
   */
  export type CorridaAgendadasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorridaAgendadas
     */
    select?: CorridaAgendadasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CorridaAgendadas
     */
    omit?: CorridaAgendadasOmit<ExtArgs> | null
  }


  /**
   * Model Corridas
   */

  export type AggregateCorridas = {
    _count: CorridasCountAggregateOutputType | null
    _avg: CorridasAvgAggregateOutputType | null
    _sum: CorridasSumAggregateOutputType | null
    _min: CorridasMinAggregateOutputType | null
    _max: CorridasMaxAggregateOutputType | null
  }

  export type CorridasAvgAggregateOutputType = {
    id: number | null
    valor: Decimal | null
    usuarioId: number | null
  }

  export type CorridasSumAggregateOutputType = {
    id: number | null
    valor: Decimal | null
    usuarioId: number | null
  }

  export type CorridasMinAggregateOutputType = {
    id: number | null
    origem: string | null
    destino: string | null
    status: string | null
    valor: Decimal | null
    tipo: $Enums.enum_Corridas_tipo | null
    horarioAgendado: Date | null
    usuarioId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CorridasMaxAggregateOutputType = {
    id: number | null
    origem: string | null
    destino: string | null
    status: string | null
    valor: Decimal | null
    tipo: $Enums.enum_Corridas_tipo | null
    horarioAgendado: Date | null
    usuarioId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CorridasCountAggregateOutputType = {
    id: number
    origem: number
    destino: number
    status: number
    valor: number
    tipo: number
    horarioAgendado: number
    usuarioId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CorridasAvgAggregateInputType = {
    id?: true
    valor?: true
    usuarioId?: true
  }

  export type CorridasSumAggregateInputType = {
    id?: true
    valor?: true
    usuarioId?: true
  }

  export type CorridasMinAggregateInputType = {
    id?: true
    origem?: true
    destino?: true
    status?: true
    valor?: true
    tipo?: true
    horarioAgendado?: true
    usuarioId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CorridasMaxAggregateInputType = {
    id?: true
    origem?: true
    destino?: true
    status?: true
    valor?: true
    tipo?: true
    horarioAgendado?: true
    usuarioId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CorridasCountAggregateInputType = {
    id?: true
    origem?: true
    destino?: true
    status?: true
    valor?: true
    tipo?: true
    horarioAgendado?: true
    usuarioId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CorridasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Corridas to aggregate.
     */
    where?: CorridasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Corridas to fetch.
     */
    orderBy?: CorridasOrderByWithRelationInput | CorridasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CorridasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Corridas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Corridas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Corridas
    **/
    _count?: true | CorridasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CorridasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CorridasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CorridasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CorridasMaxAggregateInputType
  }

  export type GetCorridasAggregateType<T extends CorridasAggregateArgs> = {
        [P in keyof T & keyof AggregateCorridas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCorridas[P]>
      : GetScalarType<T[P], AggregateCorridas[P]>
  }




  export type CorridasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CorridasWhereInput
    orderBy?: CorridasOrderByWithAggregationInput | CorridasOrderByWithAggregationInput[]
    by: CorridasScalarFieldEnum[] | CorridasScalarFieldEnum
    having?: CorridasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CorridasCountAggregateInputType | true
    _avg?: CorridasAvgAggregateInputType
    _sum?: CorridasSumAggregateInputType
    _min?: CorridasMinAggregateInputType
    _max?: CorridasMaxAggregateInputType
  }

  export type CorridasGroupByOutputType = {
    id: number
    origem: string | null
    destino: string | null
    status: string | null
    valor: Decimal | null
    tipo: $Enums.enum_Corridas_tipo | null
    horarioAgendado: Date | null
    usuarioId: number | null
    createdAt: Date
    updatedAt: Date
    _count: CorridasCountAggregateOutputType | null
    _avg: CorridasAvgAggregateOutputType | null
    _sum: CorridasSumAggregateOutputType | null
    _min: CorridasMinAggregateOutputType | null
    _max: CorridasMaxAggregateOutputType | null
  }

  type GetCorridasGroupByPayload<T extends CorridasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CorridasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CorridasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CorridasGroupByOutputType[P]>
            : GetScalarType<T[P], CorridasGroupByOutputType[P]>
        }
      >
    >


  export type CorridasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    origem?: boolean
    destino?: boolean
    status?: boolean
    valor?: boolean
    tipo?: boolean
    horarioAgendado?: boolean
    usuarioId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["corridas"]>

  export type CorridasSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    origem?: boolean
    destino?: boolean
    status?: boolean
    valor?: boolean
    tipo?: boolean
    horarioAgendado?: boolean
    usuarioId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["corridas"]>

  export type CorridasSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    origem?: boolean
    destino?: boolean
    status?: boolean
    valor?: boolean
    tipo?: boolean
    horarioAgendado?: boolean
    usuarioId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["corridas"]>

  export type CorridasSelectScalar = {
    id?: boolean
    origem?: boolean
    destino?: boolean
    status?: boolean
    valor?: boolean
    tipo?: boolean
    horarioAgendado?: boolean
    usuarioId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CorridasOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "origem" | "destino" | "status" | "valor" | "tipo" | "horarioAgendado" | "usuarioId" | "createdAt" | "updatedAt", ExtArgs["result"]["corridas"]>

  export type $CorridasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Corridas"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      origem: string | null
      destino: string | null
      status: string | null
      valor: Prisma.Decimal | null
      tipo: $Enums.enum_Corridas_tipo | null
      horarioAgendado: Date | null
      usuarioId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["corridas"]>
    composites: {}
  }

  type CorridasGetPayload<S extends boolean | null | undefined | CorridasDefaultArgs> = $Result.GetResult<Prisma.$CorridasPayload, S>

  type CorridasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CorridasFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CorridasCountAggregateInputType | true
    }

  export interface CorridasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Corridas'], meta: { name: 'Corridas' } }
    /**
     * Find zero or one Corridas that matches the filter.
     * @param {CorridasFindUniqueArgs} args - Arguments to find a Corridas
     * @example
     * // Get one Corridas
     * const corridas = await prisma.corridas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CorridasFindUniqueArgs>(args: SelectSubset<T, CorridasFindUniqueArgs<ExtArgs>>): Prisma__CorridasClient<$Result.GetResult<Prisma.$CorridasPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Corridas that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CorridasFindUniqueOrThrowArgs} args - Arguments to find a Corridas
     * @example
     * // Get one Corridas
     * const corridas = await prisma.corridas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CorridasFindUniqueOrThrowArgs>(args: SelectSubset<T, CorridasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CorridasClient<$Result.GetResult<Prisma.$CorridasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Corridas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorridasFindFirstArgs} args - Arguments to find a Corridas
     * @example
     * // Get one Corridas
     * const corridas = await prisma.corridas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CorridasFindFirstArgs>(args?: SelectSubset<T, CorridasFindFirstArgs<ExtArgs>>): Prisma__CorridasClient<$Result.GetResult<Prisma.$CorridasPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Corridas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorridasFindFirstOrThrowArgs} args - Arguments to find a Corridas
     * @example
     * // Get one Corridas
     * const corridas = await prisma.corridas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CorridasFindFirstOrThrowArgs>(args?: SelectSubset<T, CorridasFindFirstOrThrowArgs<ExtArgs>>): Prisma__CorridasClient<$Result.GetResult<Prisma.$CorridasPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Corridas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorridasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Corridas
     * const corridas = await prisma.corridas.findMany()
     * 
     * // Get first 10 Corridas
     * const corridas = await prisma.corridas.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const corridasWithIdOnly = await prisma.corridas.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CorridasFindManyArgs>(args?: SelectSubset<T, CorridasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CorridasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Corridas.
     * @param {CorridasCreateArgs} args - Arguments to create a Corridas.
     * @example
     * // Create one Corridas
     * const Corridas = await prisma.corridas.create({
     *   data: {
     *     // ... data to create a Corridas
     *   }
     * })
     * 
     */
    create<T extends CorridasCreateArgs>(args: SelectSubset<T, CorridasCreateArgs<ExtArgs>>): Prisma__CorridasClient<$Result.GetResult<Prisma.$CorridasPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Corridas.
     * @param {CorridasCreateManyArgs} args - Arguments to create many Corridas.
     * @example
     * // Create many Corridas
     * const corridas = await prisma.corridas.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CorridasCreateManyArgs>(args?: SelectSubset<T, CorridasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Corridas and returns the data saved in the database.
     * @param {CorridasCreateManyAndReturnArgs} args - Arguments to create many Corridas.
     * @example
     * // Create many Corridas
     * const corridas = await prisma.corridas.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Corridas and only return the `id`
     * const corridasWithIdOnly = await prisma.corridas.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CorridasCreateManyAndReturnArgs>(args?: SelectSubset<T, CorridasCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CorridasPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Corridas.
     * @param {CorridasDeleteArgs} args - Arguments to delete one Corridas.
     * @example
     * // Delete one Corridas
     * const Corridas = await prisma.corridas.delete({
     *   where: {
     *     // ... filter to delete one Corridas
     *   }
     * })
     * 
     */
    delete<T extends CorridasDeleteArgs>(args: SelectSubset<T, CorridasDeleteArgs<ExtArgs>>): Prisma__CorridasClient<$Result.GetResult<Prisma.$CorridasPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Corridas.
     * @param {CorridasUpdateArgs} args - Arguments to update one Corridas.
     * @example
     * // Update one Corridas
     * const corridas = await prisma.corridas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CorridasUpdateArgs>(args: SelectSubset<T, CorridasUpdateArgs<ExtArgs>>): Prisma__CorridasClient<$Result.GetResult<Prisma.$CorridasPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Corridas.
     * @param {CorridasDeleteManyArgs} args - Arguments to filter Corridas to delete.
     * @example
     * // Delete a few Corridas
     * const { count } = await prisma.corridas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CorridasDeleteManyArgs>(args?: SelectSubset<T, CorridasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Corridas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorridasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Corridas
     * const corridas = await prisma.corridas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CorridasUpdateManyArgs>(args: SelectSubset<T, CorridasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Corridas and returns the data updated in the database.
     * @param {CorridasUpdateManyAndReturnArgs} args - Arguments to update many Corridas.
     * @example
     * // Update many Corridas
     * const corridas = await prisma.corridas.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Corridas and only return the `id`
     * const corridasWithIdOnly = await prisma.corridas.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CorridasUpdateManyAndReturnArgs>(args: SelectSubset<T, CorridasUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CorridasPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Corridas.
     * @param {CorridasUpsertArgs} args - Arguments to update or create a Corridas.
     * @example
     * // Update or create a Corridas
     * const corridas = await prisma.corridas.upsert({
     *   create: {
     *     // ... data to create a Corridas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Corridas we want to update
     *   }
     * })
     */
    upsert<T extends CorridasUpsertArgs>(args: SelectSubset<T, CorridasUpsertArgs<ExtArgs>>): Prisma__CorridasClient<$Result.GetResult<Prisma.$CorridasPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Corridas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorridasCountArgs} args - Arguments to filter Corridas to count.
     * @example
     * // Count the number of Corridas
     * const count = await prisma.corridas.count({
     *   where: {
     *     // ... the filter for the Corridas we want to count
     *   }
     * })
    **/
    count<T extends CorridasCountArgs>(
      args?: Subset<T, CorridasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CorridasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Corridas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorridasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CorridasAggregateArgs>(args: Subset<T, CorridasAggregateArgs>): Prisma.PrismaPromise<GetCorridasAggregateType<T>>

    /**
     * Group by Corridas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorridasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CorridasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CorridasGroupByArgs['orderBy'] }
        : { orderBy?: CorridasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CorridasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCorridasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Corridas model
   */
  readonly fields: CorridasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Corridas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CorridasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Corridas model
   */
  interface CorridasFieldRefs {
    readonly id: FieldRef<"Corridas", 'Int'>
    readonly origem: FieldRef<"Corridas", 'String'>
    readonly destino: FieldRef<"Corridas", 'String'>
    readonly status: FieldRef<"Corridas", 'String'>
    readonly valor: FieldRef<"Corridas", 'Decimal'>
    readonly tipo: FieldRef<"Corridas", 'enum_Corridas_tipo'>
    readonly horarioAgendado: FieldRef<"Corridas", 'DateTime'>
    readonly usuarioId: FieldRef<"Corridas", 'Int'>
    readonly createdAt: FieldRef<"Corridas", 'DateTime'>
    readonly updatedAt: FieldRef<"Corridas", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Corridas findUnique
   */
  export type CorridasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Corridas
     */
    select?: CorridasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Corridas
     */
    omit?: CorridasOmit<ExtArgs> | null
    /**
     * Filter, which Corridas to fetch.
     */
    where: CorridasWhereUniqueInput
  }

  /**
   * Corridas findUniqueOrThrow
   */
  export type CorridasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Corridas
     */
    select?: CorridasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Corridas
     */
    omit?: CorridasOmit<ExtArgs> | null
    /**
     * Filter, which Corridas to fetch.
     */
    where: CorridasWhereUniqueInput
  }

  /**
   * Corridas findFirst
   */
  export type CorridasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Corridas
     */
    select?: CorridasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Corridas
     */
    omit?: CorridasOmit<ExtArgs> | null
    /**
     * Filter, which Corridas to fetch.
     */
    where?: CorridasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Corridas to fetch.
     */
    orderBy?: CorridasOrderByWithRelationInput | CorridasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Corridas.
     */
    cursor?: CorridasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Corridas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Corridas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Corridas.
     */
    distinct?: CorridasScalarFieldEnum | CorridasScalarFieldEnum[]
  }

  /**
   * Corridas findFirstOrThrow
   */
  export type CorridasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Corridas
     */
    select?: CorridasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Corridas
     */
    omit?: CorridasOmit<ExtArgs> | null
    /**
     * Filter, which Corridas to fetch.
     */
    where?: CorridasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Corridas to fetch.
     */
    orderBy?: CorridasOrderByWithRelationInput | CorridasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Corridas.
     */
    cursor?: CorridasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Corridas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Corridas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Corridas.
     */
    distinct?: CorridasScalarFieldEnum | CorridasScalarFieldEnum[]
  }

  /**
   * Corridas findMany
   */
  export type CorridasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Corridas
     */
    select?: CorridasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Corridas
     */
    omit?: CorridasOmit<ExtArgs> | null
    /**
     * Filter, which Corridas to fetch.
     */
    where?: CorridasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Corridas to fetch.
     */
    orderBy?: CorridasOrderByWithRelationInput | CorridasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Corridas.
     */
    cursor?: CorridasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Corridas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Corridas.
     */
    skip?: number
    distinct?: CorridasScalarFieldEnum | CorridasScalarFieldEnum[]
  }

  /**
   * Corridas create
   */
  export type CorridasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Corridas
     */
    select?: CorridasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Corridas
     */
    omit?: CorridasOmit<ExtArgs> | null
    /**
     * The data needed to create a Corridas.
     */
    data: XOR<CorridasCreateInput, CorridasUncheckedCreateInput>
  }

  /**
   * Corridas createMany
   */
  export type CorridasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Corridas.
     */
    data: CorridasCreateManyInput | CorridasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Corridas createManyAndReturn
   */
  export type CorridasCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Corridas
     */
    select?: CorridasSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Corridas
     */
    omit?: CorridasOmit<ExtArgs> | null
    /**
     * The data used to create many Corridas.
     */
    data: CorridasCreateManyInput | CorridasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Corridas update
   */
  export type CorridasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Corridas
     */
    select?: CorridasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Corridas
     */
    omit?: CorridasOmit<ExtArgs> | null
    /**
     * The data needed to update a Corridas.
     */
    data: XOR<CorridasUpdateInput, CorridasUncheckedUpdateInput>
    /**
     * Choose, which Corridas to update.
     */
    where: CorridasWhereUniqueInput
  }

  /**
   * Corridas updateMany
   */
  export type CorridasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Corridas.
     */
    data: XOR<CorridasUpdateManyMutationInput, CorridasUncheckedUpdateManyInput>
    /**
     * Filter which Corridas to update
     */
    where?: CorridasWhereInput
    /**
     * Limit how many Corridas to update.
     */
    limit?: number
  }

  /**
   * Corridas updateManyAndReturn
   */
  export type CorridasUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Corridas
     */
    select?: CorridasSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Corridas
     */
    omit?: CorridasOmit<ExtArgs> | null
    /**
     * The data used to update Corridas.
     */
    data: XOR<CorridasUpdateManyMutationInput, CorridasUncheckedUpdateManyInput>
    /**
     * Filter which Corridas to update
     */
    where?: CorridasWhereInput
    /**
     * Limit how many Corridas to update.
     */
    limit?: number
  }

  /**
   * Corridas upsert
   */
  export type CorridasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Corridas
     */
    select?: CorridasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Corridas
     */
    omit?: CorridasOmit<ExtArgs> | null
    /**
     * The filter to search for the Corridas to update in case it exists.
     */
    where: CorridasWhereUniqueInput
    /**
     * In case the Corridas found by the `where` argument doesn't exist, create a new Corridas with this data.
     */
    create: XOR<CorridasCreateInput, CorridasUncheckedCreateInput>
    /**
     * In case the Corridas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CorridasUpdateInput, CorridasUncheckedUpdateInput>
  }

  /**
   * Corridas delete
   */
  export type CorridasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Corridas
     */
    select?: CorridasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Corridas
     */
    omit?: CorridasOmit<ExtArgs> | null
    /**
     * Filter which Corridas to delete.
     */
    where: CorridasWhereUniqueInput
  }

  /**
   * Corridas deleteMany
   */
  export type CorridasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Corridas to delete
     */
    where?: CorridasWhereInput
    /**
     * Limit how many Corridas to delete.
     */
    limit?: number
  }

  /**
   * Corridas without action
   */
  export type CorridasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Corridas
     */
    select?: CorridasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Corridas
     */
    omit?: CorridasOmit<ExtArgs> | null
  }


  /**
   * Model Denuncia
   */

  export type AggregateDenuncia = {
    _count: DenunciaCountAggregateOutputType | null
    _avg: DenunciaAvgAggregateOutputType | null
    _sum: DenunciaSumAggregateOutputType | null
    _min: DenunciaMinAggregateOutputType | null
    _max: DenunciaMaxAggregateOutputType | null
  }

  export type DenunciaAvgAggregateOutputType = {
    id: number | null
    autor_id: number | null
    alvo_id: number | null
  }

  export type DenunciaSumAggregateOutputType = {
    id: number | null
    autor_id: number | null
    alvo_id: number | null
  }

  export type DenunciaMinAggregateOutputType = {
    id: number | null
    autor_id: number | null
    alvo_id: number | null
    tipo_alvo: $Enums.enum_Denuncia_tipo_alvo | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DenunciaMaxAggregateOutputType = {
    id: number | null
    autor_id: number | null
    alvo_id: number | null
    tipo_alvo: $Enums.enum_Denuncia_tipo_alvo | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DenunciaCountAggregateOutputType = {
    id: number
    autor_id: number
    alvo_id: number
    tipo_alvo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DenunciaAvgAggregateInputType = {
    id?: true
    autor_id?: true
    alvo_id?: true
  }

  export type DenunciaSumAggregateInputType = {
    id?: true
    autor_id?: true
    alvo_id?: true
  }

  export type DenunciaMinAggregateInputType = {
    id?: true
    autor_id?: true
    alvo_id?: true
    tipo_alvo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DenunciaMaxAggregateInputType = {
    id?: true
    autor_id?: true
    alvo_id?: true
    tipo_alvo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DenunciaCountAggregateInputType = {
    id?: true
    autor_id?: true
    alvo_id?: true
    tipo_alvo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DenunciaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Denuncia to aggregate.
     */
    where?: DenunciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Denuncias to fetch.
     */
    orderBy?: DenunciaOrderByWithRelationInput | DenunciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DenunciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Denuncias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Denuncias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Denuncias
    **/
    _count?: true | DenunciaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DenunciaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DenunciaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DenunciaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DenunciaMaxAggregateInputType
  }

  export type GetDenunciaAggregateType<T extends DenunciaAggregateArgs> = {
        [P in keyof T & keyof AggregateDenuncia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDenuncia[P]>
      : GetScalarType<T[P], AggregateDenuncia[P]>
  }




  export type DenunciaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DenunciaWhereInput
    orderBy?: DenunciaOrderByWithAggregationInput | DenunciaOrderByWithAggregationInput[]
    by: DenunciaScalarFieldEnum[] | DenunciaScalarFieldEnum
    having?: DenunciaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DenunciaCountAggregateInputType | true
    _avg?: DenunciaAvgAggregateInputType
    _sum?: DenunciaSumAggregateInputType
    _min?: DenunciaMinAggregateInputType
    _max?: DenunciaMaxAggregateInputType
  }

  export type DenunciaGroupByOutputType = {
    id: number
    autor_id: number
    alvo_id: number
    tipo_alvo: $Enums.enum_Denuncia_tipo_alvo
    createdAt: Date
    updatedAt: Date
    _count: DenunciaCountAggregateOutputType | null
    _avg: DenunciaAvgAggregateOutputType | null
    _sum: DenunciaSumAggregateOutputType | null
    _min: DenunciaMinAggregateOutputType | null
    _max: DenunciaMaxAggregateOutputType | null
  }

  type GetDenunciaGroupByPayload<T extends DenunciaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DenunciaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DenunciaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DenunciaGroupByOutputType[P]>
            : GetScalarType<T[P], DenunciaGroupByOutputType[P]>
        }
      >
    >


  export type DenunciaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    autor_id?: boolean
    alvo_id?: boolean
    tipo_alvo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["denuncia"]>

  export type DenunciaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    autor_id?: boolean
    alvo_id?: boolean
    tipo_alvo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["denuncia"]>

  export type DenunciaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    autor_id?: boolean
    alvo_id?: boolean
    tipo_alvo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["denuncia"]>

  export type DenunciaSelectScalar = {
    id?: boolean
    autor_id?: boolean
    alvo_id?: boolean
    tipo_alvo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DenunciaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "autor_id" | "alvo_id" | "tipo_alvo" | "createdAt" | "updatedAt", ExtArgs["result"]["denuncia"]>

  export type $DenunciaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Denuncia"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      autor_id: number
      alvo_id: number
      tipo_alvo: $Enums.enum_Denuncia_tipo_alvo
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["denuncia"]>
    composites: {}
  }

  type DenunciaGetPayload<S extends boolean | null | undefined | DenunciaDefaultArgs> = $Result.GetResult<Prisma.$DenunciaPayload, S>

  type DenunciaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DenunciaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DenunciaCountAggregateInputType | true
    }

  export interface DenunciaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Denuncia'], meta: { name: 'Denuncia' } }
    /**
     * Find zero or one Denuncia that matches the filter.
     * @param {DenunciaFindUniqueArgs} args - Arguments to find a Denuncia
     * @example
     * // Get one Denuncia
     * const denuncia = await prisma.denuncia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DenunciaFindUniqueArgs>(args: SelectSubset<T, DenunciaFindUniqueArgs<ExtArgs>>): Prisma__DenunciaClient<$Result.GetResult<Prisma.$DenunciaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Denuncia that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DenunciaFindUniqueOrThrowArgs} args - Arguments to find a Denuncia
     * @example
     * // Get one Denuncia
     * const denuncia = await prisma.denuncia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DenunciaFindUniqueOrThrowArgs>(args: SelectSubset<T, DenunciaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DenunciaClient<$Result.GetResult<Prisma.$DenunciaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Denuncia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DenunciaFindFirstArgs} args - Arguments to find a Denuncia
     * @example
     * // Get one Denuncia
     * const denuncia = await prisma.denuncia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DenunciaFindFirstArgs>(args?: SelectSubset<T, DenunciaFindFirstArgs<ExtArgs>>): Prisma__DenunciaClient<$Result.GetResult<Prisma.$DenunciaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Denuncia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DenunciaFindFirstOrThrowArgs} args - Arguments to find a Denuncia
     * @example
     * // Get one Denuncia
     * const denuncia = await prisma.denuncia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DenunciaFindFirstOrThrowArgs>(args?: SelectSubset<T, DenunciaFindFirstOrThrowArgs<ExtArgs>>): Prisma__DenunciaClient<$Result.GetResult<Prisma.$DenunciaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Denuncias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DenunciaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Denuncias
     * const denuncias = await prisma.denuncia.findMany()
     * 
     * // Get first 10 Denuncias
     * const denuncias = await prisma.denuncia.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const denunciaWithIdOnly = await prisma.denuncia.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DenunciaFindManyArgs>(args?: SelectSubset<T, DenunciaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DenunciaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Denuncia.
     * @param {DenunciaCreateArgs} args - Arguments to create a Denuncia.
     * @example
     * // Create one Denuncia
     * const Denuncia = await prisma.denuncia.create({
     *   data: {
     *     // ... data to create a Denuncia
     *   }
     * })
     * 
     */
    create<T extends DenunciaCreateArgs>(args: SelectSubset<T, DenunciaCreateArgs<ExtArgs>>): Prisma__DenunciaClient<$Result.GetResult<Prisma.$DenunciaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Denuncias.
     * @param {DenunciaCreateManyArgs} args - Arguments to create many Denuncias.
     * @example
     * // Create many Denuncias
     * const denuncia = await prisma.denuncia.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DenunciaCreateManyArgs>(args?: SelectSubset<T, DenunciaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Denuncias and returns the data saved in the database.
     * @param {DenunciaCreateManyAndReturnArgs} args - Arguments to create many Denuncias.
     * @example
     * // Create many Denuncias
     * const denuncia = await prisma.denuncia.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Denuncias and only return the `id`
     * const denunciaWithIdOnly = await prisma.denuncia.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DenunciaCreateManyAndReturnArgs>(args?: SelectSubset<T, DenunciaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DenunciaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Denuncia.
     * @param {DenunciaDeleteArgs} args - Arguments to delete one Denuncia.
     * @example
     * // Delete one Denuncia
     * const Denuncia = await prisma.denuncia.delete({
     *   where: {
     *     // ... filter to delete one Denuncia
     *   }
     * })
     * 
     */
    delete<T extends DenunciaDeleteArgs>(args: SelectSubset<T, DenunciaDeleteArgs<ExtArgs>>): Prisma__DenunciaClient<$Result.GetResult<Prisma.$DenunciaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Denuncia.
     * @param {DenunciaUpdateArgs} args - Arguments to update one Denuncia.
     * @example
     * // Update one Denuncia
     * const denuncia = await prisma.denuncia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DenunciaUpdateArgs>(args: SelectSubset<T, DenunciaUpdateArgs<ExtArgs>>): Prisma__DenunciaClient<$Result.GetResult<Prisma.$DenunciaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Denuncias.
     * @param {DenunciaDeleteManyArgs} args - Arguments to filter Denuncias to delete.
     * @example
     * // Delete a few Denuncias
     * const { count } = await prisma.denuncia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DenunciaDeleteManyArgs>(args?: SelectSubset<T, DenunciaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Denuncias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DenunciaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Denuncias
     * const denuncia = await prisma.denuncia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DenunciaUpdateManyArgs>(args: SelectSubset<T, DenunciaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Denuncias and returns the data updated in the database.
     * @param {DenunciaUpdateManyAndReturnArgs} args - Arguments to update many Denuncias.
     * @example
     * // Update many Denuncias
     * const denuncia = await prisma.denuncia.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Denuncias and only return the `id`
     * const denunciaWithIdOnly = await prisma.denuncia.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DenunciaUpdateManyAndReturnArgs>(args: SelectSubset<T, DenunciaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DenunciaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Denuncia.
     * @param {DenunciaUpsertArgs} args - Arguments to update or create a Denuncia.
     * @example
     * // Update or create a Denuncia
     * const denuncia = await prisma.denuncia.upsert({
     *   create: {
     *     // ... data to create a Denuncia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Denuncia we want to update
     *   }
     * })
     */
    upsert<T extends DenunciaUpsertArgs>(args: SelectSubset<T, DenunciaUpsertArgs<ExtArgs>>): Prisma__DenunciaClient<$Result.GetResult<Prisma.$DenunciaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Denuncias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DenunciaCountArgs} args - Arguments to filter Denuncias to count.
     * @example
     * // Count the number of Denuncias
     * const count = await prisma.denuncia.count({
     *   where: {
     *     // ... the filter for the Denuncias we want to count
     *   }
     * })
    **/
    count<T extends DenunciaCountArgs>(
      args?: Subset<T, DenunciaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DenunciaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Denuncia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DenunciaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DenunciaAggregateArgs>(args: Subset<T, DenunciaAggregateArgs>): Prisma.PrismaPromise<GetDenunciaAggregateType<T>>

    /**
     * Group by Denuncia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DenunciaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DenunciaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DenunciaGroupByArgs['orderBy'] }
        : { orderBy?: DenunciaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DenunciaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDenunciaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Denuncia model
   */
  readonly fields: DenunciaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Denuncia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DenunciaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Denuncia model
   */
  interface DenunciaFieldRefs {
    readonly id: FieldRef<"Denuncia", 'Int'>
    readonly autor_id: FieldRef<"Denuncia", 'Int'>
    readonly alvo_id: FieldRef<"Denuncia", 'Int'>
    readonly tipo_alvo: FieldRef<"Denuncia", 'enum_Denuncia_tipo_alvo'>
    readonly createdAt: FieldRef<"Denuncia", 'DateTime'>
    readonly updatedAt: FieldRef<"Denuncia", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Denuncia findUnique
   */
  export type DenunciaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Denuncia
     */
    select?: DenunciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Denuncia
     */
    omit?: DenunciaOmit<ExtArgs> | null
    /**
     * Filter, which Denuncia to fetch.
     */
    where: DenunciaWhereUniqueInput
  }

  /**
   * Denuncia findUniqueOrThrow
   */
  export type DenunciaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Denuncia
     */
    select?: DenunciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Denuncia
     */
    omit?: DenunciaOmit<ExtArgs> | null
    /**
     * Filter, which Denuncia to fetch.
     */
    where: DenunciaWhereUniqueInput
  }

  /**
   * Denuncia findFirst
   */
  export type DenunciaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Denuncia
     */
    select?: DenunciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Denuncia
     */
    omit?: DenunciaOmit<ExtArgs> | null
    /**
     * Filter, which Denuncia to fetch.
     */
    where?: DenunciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Denuncias to fetch.
     */
    orderBy?: DenunciaOrderByWithRelationInput | DenunciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Denuncias.
     */
    cursor?: DenunciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Denuncias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Denuncias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Denuncias.
     */
    distinct?: DenunciaScalarFieldEnum | DenunciaScalarFieldEnum[]
  }

  /**
   * Denuncia findFirstOrThrow
   */
  export type DenunciaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Denuncia
     */
    select?: DenunciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Denuncia
     */
    omit?: DenunciaOmit<ExtArgs> | null
    /**
     * Filter, which Denuncia to fetch.
     */
    where?: DenunciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Denuncias to fetch.
     */
    orderBy?: DenunciaOrderByWithRelationInput | DenunciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Denuncias.
     */
    cursor?: DenunciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Denuncias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Denuncias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Denuncias.
     */
    distinct?: DenunciaScalarFieldEnum | DenunciaScalarFieldEnum[]
  }

  /**
   * Denuncia findMany
   */
  export type DenunciaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Denuncia
     */
    select?: DenunciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Denuncia
     */
    omit?: DenunciaOmit<ExtArgs> | null
    /**
     * Filter, which Denuncias to fetch.
     */
    where?: DenunciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Denuncias to fetch.
     */
    orderBy?: DenunciaOrderByWithRelationInput | DenunciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Denuncias.
     */
    cursor?: DenunciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Denuncias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Denuncias.
     */
    skip?: number
    distinct?: DenunciaScalarFieldEnum | DenunciaScalarFieldEnum[]
  }

  /**
   * Denuncia create
   */
  export type DenunciaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Denuncia
     */
    select?: DenunciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Denuncia
     */
    omit?: DenunciaOmit<ExtArgs> | null
    /**
     * The data needed to create a Denuncia.
     */
    data: XOR<DenunciaCreateInput, DenunciaUncheckedCreateInput>
  }

  /**
   * Denuncia createMany
   */
  export type DenunciaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Denuncias.
     */
    data: DenunciaCreateManyInput | DenunciaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Denuncia createManyAndReturn
   */
  export type DenunciaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Denuncia
     */
    select?: DenunciaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Denuncia
     */
    omit?: DenunciaOmit<ExtArgs> | null
    /**
     * The data used to create many Denuncias.
     */
    data: DenunciaCreateManyInput | DenunciaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Denuncia update
   */
  export type DenunciaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Denuncia
     */
    select?: DenunciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Denuncia
     */
    omit?: DenunciaOmit<ExtArgs> | null
    /**
     * The data needed to update a Denuncia.
     */
    data: XOR<DenunciaUpdateInput, DenunciaUncheckedUpdateInput>
    /**
     * Choose, which Denuncia to update.
     */
    where: DenunciaWhereUniqueInput
  }

  /**
   * Denuncia updateMany
   */
  export type DenunciaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Denuncias.
     */
    data: XOR<DenunciaUpdateManyMutationInput, DenunciaUncheckedUpdateManyInput>
    /**
     * Filter which Denuncias to update
     */
    where?: DenunciaWhereInput
    /**
     * Limit how many Denuncias to update.
     */
    limit?: number
  }

  /**
   * Denuncia updateManyAndReturn
   */
  export type DenunciaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Denuncia
     */
    select?: DenunciaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Denuncia
     */
    omit?: DenunciaOmit<ExtArgs> | null
    /**
     * The data used to update Denuncias.
     */
    data: XOR<DenunciaUpdateManyMutationInput, DenunciaUncheckedUpdateManyInput>
    /**
     * Filter which Denuncias to update
     */
    where?: DenunciaWhereInput
    /**
     * Limit how many Denuncias to update.
     */
    limit?: number
  }

  /**
   * Denuncia upsert
   */
  export type DenunciaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Denuncia
     */
    select?: DenunciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Denuncia
     */
    omit?: DenunciaOmit<ExtArgs> | null
    /**
     * The filter to search for the Denuncia to update in case it exists.
     */
    where: DenunciaWhereUniqueInput
    /**
     * In case the Denuncia found by the `where` argument doesn't exist, create a new Denuncia with this data.
     */
    create: XOR<DenunciaCreateInput, DenunciaUncheckedCreateInput>
    /**
     * In case the Denuncia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DenunciaUpdateInput, DenunciaUncheckedUpdateInput>
  }

  /**
   * Denuncia delete
   */
  export type DenunciaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Denuncia
     */
    select?: DenunciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Denuncia
     */
    omit?: DenunciaOmit<ExtArgs> | null
    /**
     * Filter which Denuncia to delete.
     */
    where: DenunciaWhereUniqueInput
  }

  /**
   * Denuncia deleteMany
   */
  export type DenunciaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Denuncias to delete
     */
    where?: DenunciaWhereInput
    /**
     * Limit how many Denuncias to delete.
     */
    limit?: number
  }

  /**
   * Denuncia without action
   */
  export type DenunciaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Denuncia
     */
    select?: DenunciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Denuncia
     */
    omit?: DenunciaOmit<ExtArgs> | null
  }


  /**
   * Model Documentos
   */

  export type AggregateDocumentos = {
    _count: DocumentosCountAggregateOutputType | null
    _avg: DocumentosAvgAggregateOutputType | null
    _sum: DocumentosSumAggregateOutputType | null
    _min: DocumentosMinAggregateOutputType | null
    _max: DocumentosMaxAggregateOutputType | null
  }

  export type DocumentosAvgAggregateOutputType = {
    id: number | null
    usuario_id: number | null
  }

  export type DocumentosSumAggregateOutputType = {
    id: number | null
    usuario_id: number | null
  }

  export type DocumentosMinAggregateOutputType = {
    id: number | null
    usuario_id: number | null
    tipo_documento: $Enums.enum_Documentos_tipo_documento | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentosMaxAggregateOutputType = {
    id: number | null
    usuario_id: number | null
    tipo_documento: $Enums.enum_Documentos_tipo_documento | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentosCountAggregateOutputType = {
    id: number
    usuario_id: number
    tipo_documento: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DocumentosAvgAggregateInputType = {
    id?: true
    usuario_id?: true
  }

  export type DocumentosSumAggregateInputType = {
    id?: true
    usuario_id?: true
  }

  export type DocumentosMinAggregateInputType = {
    id?: true
    usuario_id?: true
    tipo_documento?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentosMaxAggregateInputType = {
    id?: true
    usuario_id?: true
    tipo_documento?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentosCountAggregateInputType = {
    id?: true
    usuario_id?: true
    tipo_documento?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DocumentosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documentos to aggregate.
     */
    where?: DocumentosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documentos to fetch.
     */
    orderBy?: DocumentosOrderByWithRelationInput | DocumentosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documentos
    **/
    _count?: true | DocumentosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentosMaxAggregateInputType
  }

  export type GetDocumentosAggregateType<T extends DocumentosAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumentos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumentos[P]>
      : GetScalarType<T[P], AggregateDocumentos[P]>
  }




  export type DocumentosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentosWhereInput
    orderBy?: DocumentosOrderByWithAggregationInput | DocumentosOrderByWithAggregationInput[]
    by: DocumentosScalarFieldEnum[] | DocumentosScalarFieldEnum
    having?: DocumentosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentosCountAggregateInputType | true
    _avg?: DocumentosAvgAggregateInputType
    _sum?: DocumentosSumAggregateInputType
    _min?: DocumentosMinAggregateInputType
    _max?: DocumentosMaxAggregateInputType
  }

  export type DocumentosGroupByOutputType = {
    id: number
    usuario_id: number
    tipo_documento: $Enums.enum_Documentos_tipo_documento
    createdAt: Date
    updatedAt: Date
    _count: DocumentosCountAggregateOutputType | null
    _avg: DocumentosAvgAggregateOutputType | null
    _sum: DocumentosSumAggregateOutputType | null
    _min: DocumentosMinAggregateOutputType | null
    _max: DocumentosMaxAggregateOutputType | null
  }

  type GetDocumentosGroupByPayload<T extends DocumentosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentosGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentosGroupByOutputType[P]>
        }
      >
    >


  export type DocumentosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    tipo_documento?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["documentos"]>

  export type DocumentosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    tipo_documento?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["documentos"]>

  export type DocumentosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    tipo_documento?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["documentos"]>

  export type DocumentosSelectScalar = {
    id?: boolean
    usuario_id?: boolean
    tipo_documento?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DocumentosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "usuario_id" | "tipo_documento" | "createdAt" | "updatedAt", ExtArgs["result"]["documentos"]>

  export type $DocumentosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Documentos"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      usuario_id: number
      tipo_documento: $Enums.enum_Documentos_tipo_documento
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["documentos"]>
    composites: {}
  }

  type DocumentosGetPayload<S extends boolean | null | undefined | DocumentosDefaultArgs> = $Result.GetResult<Prisma.$DocumentosPayload, S>

  type DocumentosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentosCountAggregateInputType | true
    }

  export interface DocumentosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Documentos'], meta: { name: 'Documentos' } }
    /**
     * Find zero or one Documentos that matches the filter.
     * @param {DocumentosFindUniqueArgs} args - Arguments to find a Documentos
     * @example
     * // Get one Documentos
     * const documentos = await prisma.documentos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentosFindUniqueArgs>(args: SelectSubset<T, DocumentosFindUniqueArgs<ExtArgs>>): Prisma__DocumentosClient<$Result.GetResult<Prisma.$DocumentosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Documentos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentosFindUniqueOrThrowArgs} args - Arguments to find a Documentos
     * @example
     * // Get one Documentos
     * const documentos = await prisma.documentos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentosFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentosClient<$Result.GetResult<Prisma.$DocumentosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Documentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentosFindFirstArgs} args - Arguments to find a Documentos
     * @example
     * // Get one Documentos
     * const documentos = await prisma.documentos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentosFindFirstArgs>(args?: SelectSubset<T, DocumentosFindFirstArgs<ExtArgs>>): Prisma__DocumentosClient<$Result.GetResult<Prisma.$DocumentosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Documentos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentosFindFirstOrThrowArgs} args - Arguments to find a Documentos
     * @example
     * // Get one Documentos
     * const documentos = await prisma.documentos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentosFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentosFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentosClient<$Result.GetResult<Prisma.$DocumentosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Documentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documentos
     * const documentos = await prisma.documentos.findMany()
     * 
     * // Get first 10 Documentos
     * const documentos = await prisma.documentos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentosWithIdOnly = await prisma.documentos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentosFindManyArgs>(args?: SelectSubset<T, DocumentosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Documentos.
     * @param {DocumentosCreateArgs} args - Arguments to create a Documentos.
     * @example
     * // Create one Documentos
     * const Documentos = await prisma.documentos.create({
     *   data: {
     *     // ... data to create a Documentos
     *   }
     * })
     * 
     */
    create<T extends DocumentosCreateArgs>(args: SelectSubset<T, DocumentosCreateArgs<ExtArgs>>): Prisma__DocumentosClient<$Result.GetResult<Prisma.$DocumentosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Documentos.
     * @param {DocumentosCreateManyArgs} args - Arguments to create many Documentos.
     * @example
     * // Create many Documentos
     * const documentos = await prisma.documentos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentosCreateManyArgs>(args?: SelectSubset<T, DocumentosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Documentos and returns the data saved in the database.
     * @param {DocumentosCreateManyAndReturnArgs} args - Arguments to create many Documentos.
     * @example
     * // Create many Documentos
     * const documentos = await prisma.documentos.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Documentos and only return the `id`
     * const documentosWithIdOnly = await prisma.documentos.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentosCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentosPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Documentos.
     * @param {DocumentosDeleteArgs} args - Arguments to delete one Documentos.
     * @example
     * // Delete one Documentos
     * const Documentos = await prisma.documentos.delete({
     *   where: {
     *     // ... filter to delete one Documentos
     *   }
     * })
     * 
     */
    delete<T extends DocumentosDeleteArgs>(args: SelectSubset<T, DocumentosDeleteArgs<ExtArgs>>): Prisma__DocumentosClient<$Result.GetResult<Prisma.$DocumentosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Documentos.
     * @param {DocumentosUpdateArgs} args - Arguments to update one Documentos.
     * @example
     * // Update one Documentos
     * const documentos = await prisma.documentos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentosUpdateArgs>(args: SelectSubset<T, DocumentosUpdateArgs<ExtArgs>>): Prisma__DocumentosClient<$Result.GetResult<Prisma.$DocumentosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Documentos.
     * @param {DocumentosDeleteManyArgs} args - Arguments to filter Documentos to delete.
     * @example
     * // Delete a few Documentos
     * const { count } = await prisma.documentos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentosDeleteManyArgs>(args?: SelectSubset<T, DocumentosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documentos
     * const documentos = await prisma.documentos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentosUpdateManyArgs>(args: SelectSubset<T, DocumentosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documentos and returns the data updated in the database.
     * @param {DocumentosUpdateManyAndReturnArgs} args - Arguments to update many Documentos.
     * @example
     * // Update many Documentos
     * const documentos = await prisma.documentos.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Documentos and only return the `id`
     * const documentosWithIdOnly = await prisma.documentos.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentosUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentosPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Documentos.
     * @param {DocumentosUpsertArgs} args - Arguments to update or create a Documentos.
     * @example
     * // Update or create a Documentos
     * const documentos = await prisma.documentos.upsert({
     *   create: {
     *     // ... data to create a Documentos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Documentos we want to update
     *   }
     * })
     */
    upsert<T extends DocumentosUpsertArgs>(args: SelectSubset<T, DocumentosUpsertArgs<ExtArgs>>): Prisma__DocumentosClient<$Result.GetResult<Prisma.$DocumentosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Documentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentosCountArgs} args - Arguments to filter Documentos to count.
     * @example
     * // Count the number of Documentos
     * const count = await prisma.documentos.count({
     *   where: {
     *     // ... the filter for the Documentos we want to count
     *   }
     * })
    **/
    count<T extends DocumentosCountArgs>(
      args?: Subset<T, DocumentosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Documentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentosAggregateArgs>(args: Subset<T, DocumentosAggregateArgs>): Prisma.PrismaPromise<GetDocumentosAggregateType<T>>

    /**
     * Group by Documentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentosGroupByArgs['orderBy'] }
        : { orderBy?: DocumentosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Documentos model
   */
  readonly fields: DocumentosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Documentos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Documentos model
   */
  interface DocumentosFieldRefs {
    readonly id: FieldRef<"Documentos", 'Int'>
    readonly usuario_id: FieldRef<"Documentos", 'Int'>
    readonly tipo_documento: FieldRef<"Documentos", 'enum_Documentos_tipo_documento'>
    readonly createdAt: FieldRef<"Documentos", 'DateTime'>
    readonly updatedAt: FieldRef<"Documentos", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Documentos findUnique
   */
  export type DocumentosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documentos
     */
    select?: DocumentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Documentos
     */
    omit?: DocumentosOmit<ExtArgs> | null
    /**
     * Filter, which Documentos to fetch.
     */
    where: DocumentosWhereUniqueInput
  }

  /**
   * Documentos findUniqueOrThrow
   */
  export type DocumentosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documentos
     */
    select?: DocumentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Documentos
     */
    omit?: DocumentosOmit<ExtArgs> | null
    /**
     * Filter, which Documentos to fetch.
     */
    where: DocumentosWhereUniqueInput
  }

  /**
   * Documentos findFirst
   */
  export type DocumentosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documentos
     */
    select?: DocumentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Documentos
     */
    omit?: DocumentosOmit<ExtArgs> | null
    /**
     * Filter, which Documentos to fetch.
     */
    where?: DocumentosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documentos to fetch.
     */
    orderBy?: DocumentosOrderByWithRelationInput | DocumentosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documentos.
     */
    cursor?: DocumentosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documentos.
     */
    distinct?: DocumentosScalarFieldEnum | DocumentosScalarFieldEnum[]
  }

  /**
   * Documentos findFirstOrThrow
   */
  export type DocumentosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documentos
     */
    select?: DocumentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Documentos
     */
    omit?: DocumentosOmit<ExtArgs> | null
    /**
     * Filter, which Documentos to fetch.
     */
    where?: DocumentosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documentos to fetch.
     */
    orderBy?: DocumentosOrderByWithRelationInput | DocumentosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documentos.
     */
    cursor?: DocumentosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documentos.
     */
    distinct?: DocumentosScalarFieldEnum | DocumentosScalarFieldEnum[]
  }

  /**
   * Documentos findMany
   */
  export type DocumentosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documentos
     */
    select?: DocumentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Documentos
     */
    omit?: DocumentosOmit<ExtArgs> | null
    /**
     * Filter, which Documentos to fetch.
     */
    where?: DocumentosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documentos to fetch.
     */
    orderBy?: DocumentosOrderByWithRelationInput | DocumentosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documentos.
     */
    cursor?: DocumentosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documentos.
     */
    skip?: number
    distinct?: DocumentosScalarFieldEnum | DocumentosScalarFieldEnum[]
  }

  /**
   * Documentos create
   */
  export type DocumentosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documentos
     */
    select?: DocumentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Documentos
     */
    omit?: DocumentosOmit<ExtArgs> | null
    /**
     * The data needed to create a Documentos.
     */
    data: XOR<DocumentosCreateInput, DocumentosUncheckedCreateInput>
  }

  /**
   * Documentos createMany
   */
  export type DocumentosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documentos.
     */
    data: DocumentosCreateManyInput | DocumentosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Documentos createManyAndReturn
   */
  export type DocumentosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documentos
     */
    select?: DocumentosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Documentos
     */
    omit?: DocumentosOmit<ExtArgs> | null
    /**
     * The data used to create many Documentos.
     */
    data: DocumentosCreateManyInput | DocumentosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Documentos update
   */
  export type DocumentosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documentos
     */
    select?: DocumentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Documentos
     */
    omit?: DocumentosOmit<ExtArgs> | null
    /**
     * The data needed to update a Documentos.
     */
    data: XOR<DocumentosUpdateInput, DocumentosUncheckedUpdateInput>
    /**
     * Choose, which Documentos to update.
     */
    where: DocumentosWhereUniqueInput
  }

  /**
   * Documentos updateMany
   */
  export type DocumentosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documentos.
     */
    data: XOR<DocumentosUpdateManyMutationInput, DocumentosUncheckedUpdateManyInput>
    /**
     * Filter which Documentos to update
     */
    where?: DocumentosWhereInput
    /**
     * Limit how many Documentos to update.
     */
    limit?: number
  }

  /**
   * Documentos updateManyAndReturn
   */
  export type DocumentosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documentos
     */
    select?: DocumentosSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Documentos
     */
    omit?: DocumentosOmit<ExtArgs> | null
    /**
     * The data used to update Documentos.
     */
    data: XOR<DocumentosUpdateManyMutationInput, DocumentosUncheckedUpdateManyInput>
    /**
     * Filter which Documentos to update
     */
    where?: DocumentosWhereInput
    /**
     * Limit how many Documentos to update.
     */
    limit?: number
  }

  /**
   * Documentos upsert
   */
  export type DocumentosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documentos
     */
    select?: DocumentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Documentos
     */
    omit?: DocumentosOmit<ExtArgs> | null
    /**
     * The filter to search for the Documentos to update in case it exists.
     */
    where: DocumentosWhereUniqueInput
    /**
     * In case the Documentos found by the `where` argument doesn't exist, create a new Documentos with this data.
     */
    create: XOR<DocumentosCreateInput, DocumentosUncheckedCreateInput>
    /**
     * In case the Documentos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentosUpdateInput, DocumentosUncheckedUpdateInput>
  }

  /**
   * Documentos delete
   */
  export type DocumentosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documentos
     */
    select?: DocumentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Documentos
     */
    omit?: DocumentosOmit<ExtArgs> | null
    /**
     * Filter which Documentos to delete.
     */
    where: DocumentosWhereUniqueInput
  }

  /**
   * Documentos deleteMany
   */
  export type DocumentosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documentos to delete
     */
    where?: DocumentosWhereInput
    /**
     * Limit how many Documentos to delete.
     */
    limit?: number
  }

  /**
   * Documentos without action
   */
  export type DocumentosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documentos
     */
    select?: DocumentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Documentos
     */
    omit?: DocumentosOmit<ExtArgs> | null
  }


  /**
   * Model EmailEnviados
   */

  export type AggregateEmailEnviados = {
    _count: EmailEnviadosCountAggregateOutputType | null
    _avg: EmailEnviadosAvgAggregateOutputType | null
    _sum: EmailEnviadosSumAggregateOutputType | null
    _min: EmailEnviadosMinAggregateOutputType | null
    _max: EmailEnviadosMaxAggregateOutputType | null
  }

  export type EmailEnviadosAvgAggregateOutputType = {
    id: number | null
    usuario_id: number | null
  }

  export type EmailEnviadosSumAggregateOutputType = {
    id: number | null
    usuario_id: number | null
  }

  export type EmailEnviadosMinAggregateOutputType = {
    id: number | null
    usuario_id: number | null
    email: string | null
    tipo: $Enums.enum_EmailEnviados_tipo | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailEnviadosMaxAggregateOutputType = {
    id: number | null
    usuario_id: number | null
    email: string | null
    tipo: $Enums.enum_EmailEnviados_tipo | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailEnviadosCountAggregateOutputType = {
    id: number
    usuario_id: number
    email: number
    tipo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmailEnviadosAvgAggregateInputType = {
    id?: true
    usuario_id?: true
  }

  export type EmailEnviadosSumAggregateInputType = {
    id?: true
    usuario_id?: true
  }

  export type EmailEnviadosMinAggregateInputType = {
    id?: true
    usuario_id?: true
    email?: true
    tipo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailEnviadosMaxAggregateInputType = {
    id?: true
    usuario_id?: true
    email?: true
    tipo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailEnviadosCountAggregateInputType = {
    id?: true
    usuario_id?: true
    email?: true
    tipo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmailEnviadosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailEnviados to aggregate.
     */
    where?: EmailEnviadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailEnviados to fetch.
     */
    orderBy?: EmailEnviadosOrderByWithRelationInput | EmailEnviadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailEnviadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailEnviados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailEnviados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailEnviados
    **/
    _count?: true | EmailEnviadosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmailEnviadosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmailEnviadosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailEnviadosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailEnviadosMaxAggregateInputType
  }

  export type GetEmailEnviadosAggregateType<T extends EmailEnviadosAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailEnviados]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailEnviados[P]>
      : GetScalarType<T[P], AggregateEmailEnviados[P]>
  }




  export type EmailEnviadosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailEnviadosWhereInput
    orderBy?: EmailEnviadosOrderByWithAggregationInput | EmailEnviadosOrderByWithAggregationInput[]
    by: EmailEnviadosScalarFieldEnum[] | EmailEnviadosScalarFieldEnum
    having?: EmailEnviadosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailEnviadosCountAggregateInputType | true
    _avg?: EmailEnviadosAvgAggregateInputType
    _sum?: EmailEnviadosSumAggregateInputType
    _min?: EmailEnviadosMinAggregateInputType
    _max?: EmailEnviadosMaxAggregateInputType
  }

  export type EmailEnviadosGroupByOutputType = {
    id: number
    usuario_id: number
    email: string
    tipo: $Enums.enum_EmailEnviados_tipo | null
    createdAt: Date
    updatedAt: Date
    _count: EmailEnviadosCountAggregateOutputType | null
    _avg: EmailEnviadosAvgAggregateOutputType | null
    _sum: EmailEnviadosSumAggregateOutputType | null
    _min: EmailEnviadosMinAggregateOutputType | null
    _max: EmailEnviadosMaxAggregateOutputType | null
  }

  type GetEmailEnviadosGroupByPayload<T extends EmailEnviadosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailEnviadosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailEnviadosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailEnviadosGroupByOutputType[P]>
            : GetScalarType<T[P], EmailEnviadosGroupByOutputType[P]>
        }
      >
    >


  export type EmailEnviadosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    email?: boolean
    tipo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["emailEnviados"]>

  export type EmailEnviadosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    email?: boolean
    tipo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["emailEnviados"]>

  export type EmailEnviadosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    email?: boolean
    tipo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["emailEnviados"]>

  export type EmailEnviadosSelectScalar = {
    id?: boolean
    usuario_id?: boolean
    email?: boolean
    tipo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmailEnviadosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "usuario_id" | "email" | "tipo" | "createdAt" | "updatedAt", ExtArgs["result"]["emailEnviados"]>

  export type $EmailEnviadosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailEnviados"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      usuario_id: number
      email: string
      tipo: $Enums.enum_EmailEnviados_tipo | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["emailEnviados"]>
    composites: {}
  }

  type EmailEnviadosGetPayload<S extends boolean | null | undefined | EmailEnviadosDefaultArgs> = $Result.GetResult<Prisma.$EmailEnviadosPayload, S>

  type EmailEnviadosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailEnviadosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailEnviadosCountAggregateInputType | true
    }

  export interface EmailEnviadosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailEnviados'], meta: { name: 'EmailEnviados' } }
    /**
     * Find zero or one EmailEnviados that matches the filter.
     * @param {EmailEnviadosFindUniqueArgs} args - Arguments to find a EmailEnviados
     * @example
     * // Get one EmailEnviados
     * const emailEnviados = await prisma.emailEnviados.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailEnviadosFindUniqueArgs>(args: SelectSubset<T, EmailEnviadosFindUniqueArgs<ExtArgs>>): Prisma__EmailEnviadosClient<$Result.GetResult<Prisma.$EmailEnviadosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailEnviados that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailEnviadosFindUniqueOrThrowArgs} args - Arguments to find a EmailEnviados
     * @example
     * // Get one EmailEnviados
     * const emailEnviados = await prisma.emailEnviados.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailEnviadosFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailEnviadosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailEnviadosClient<$Result.GetResult<Prisma.$EmailEnviadosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailEnviados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailEnviadosFindFirstArgs} args - Arguments to find a EmailEnviados
     * @example
     * // Get one EmailEnviados
     * const emailEnviados = await prisma.emailEnviados.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailEnviadosFindFirstArgs>(args?: SelectSubset<T, EmailEnviadosFindFirstArgs<ExtArgs>>): Prisma__EmailEnviadosClient<$Result.GetResult<Prisma.$EmailEnviadosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailEnviados that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailEnviadosFindFirstOrThrowArgs} args - Arguments to find a EmailEnviados
     * @example
     * // Get one EmailEnviados
     * const emailEnviados = await prisma.emailEnviados.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailEnviadosFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailEnviadosFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailEnviadosClient<$Result.GetResult<Prisma.$EmailEnviadosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailEnviados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailEnviadosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailEnviados
     * const emailEnviados = await prisma.emailEnviados.findMany()
     * 
     * // Get first 10 EmailEnviados
     * const emailEnviados = await prisma.emailEnviados.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailEnviadosWithIdOnly = await prisma.emailEnviados.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailEnviadosFindManyArgs>(args?: SelectSubset<T, EmailEnviadosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailEnviadosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailEnviados.
     * @param {EmailEnviadosCreateArgs} args - Arguments to create a EmailEnviados.
     * @example
     * // Create one EmailEnviados
     * const EmailEnviados = await prisma.emailEnviados.create({
     *   data: {
     *     // ... data to create a EmailEnviados
     *   }
     * })
     * 
     */
    create<T extends EmailEnviadosCreateArgs>(args: SelectSubset<T, EmailEnviadosCreateArgs<ExtArgs>>): Prisma__EmailEnviadosClient<$Result.GetResult<Prisma.$EmailEnviadosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailEnviados.
     * @param {EmailEnviadosCreateManyArgs} args - Arguments to create many EmailEnviados.
     * @example
     * // Create many EmailEnviados
     * const emailEnviados = await prisma.emailEnviados.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailEnviadosCreateManyArgs>(args?: SelectSubset<T, EmailEnviadosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailEnviados and returns the data saved in the database.
     * @param {EmailEnviadosCreateManyAndReturnArgs} args - Arguments to create many EmailEnviados.
     * @example
     * // Create many EmailEnviados
     * const emailEnviados = await prisma.emailEnviados.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailEnviados and only return the `id`
     * const emailEnviadosWithIdOnly = await prisma.emailEnviados.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailEnviadosCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailEnviadosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailEnviadosPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailEnviados.
     * @param {EmailEnviadosDeleteArgs} args - Arguments to delete one EmailEnviados.
     * @example
     * // Delete one EmailEnviados
     * const EmailEnviados = await prisma.emailEnviados.delete({
     *   where: {
     *     // ... filter to delete one EmailEnviados
     *   }
     * })
     * 
     */
    delete<T extends EmailEnviadosDeleteArgs>(args: SelectSubset<T, EmailEnviadosDeleteArgs<ExtArgs>>): Prisma__EmailEnviadosClient<$Result.GetResult<Prisma.$EmailEnviadosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailEnviados.
     * @param {EmailEnviadosUpdateArgs} args - Arguments to update one EmailEnviados.
     * @example
     * // Update one EmailEnviados
     * const emailEnviados = await prisma.emailEnviados.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailEnviadosUpdateArgs>(args: SelectSubset<T, EmailEnviadosUpdateArgs<ExtArgs>>): Prisma__EmailEnviadosClient<$Result.GetResult<Prisma.$EmailEnviadosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailEnviados.
     * @param {EmailEnviadosDeleteManyArgs} args - Arguments to filter EmailEnviados to delete.
     * @example
     * // Delete a few EmailEnviados
     * const { count } = await prisma.emailEnviados.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailEnviadosDeleteManyArgs>(args?: SelectSubset<T, EmailEnviadosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailEnviados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailEnviadosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailEnviados
     * const emailEnviados = await prisma.emailEnviados.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailEnviadosUpdateManyArgs>(args: SelectSubset<T, EmailEnviadosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailEnviados and returns the data updated in the database.
     * @param {EmailEnviadosUpdateManyAndReturnArgs} args - Arguments to update many EmailEnviados.
     * @example
     * // Update many EmailEnviados
     * const emailEnviados = await prisma.emailEnviados.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailEnviados and only return the `id`
     * const emailEnviadosWithIdOnly = await prisma.emailEnviados.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailEnviadosUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailEnviadosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailEnviadosPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailEnviados.
     * @param {EmailEnviadosUpsertArgs} args - Arguments to update or create a EmailEnviados.
     * @example
     * // Update or create a EmailEnviados
     * const emailEnviados = await prisma.emailEnviados.upsert({
     *   create: {
     *     // ... data to create a EmailEnviados
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailEnviados we want to update
     *   }
     * })
     */
    upsert<T extends EmailEnviadosUpsertArgs>(args: SelectSubset<T, EmailEnviadosUpsertArgs<ExtArgs>>): Prisma__EmailEnviadosClient<$Result.GetResult<Prisma.$EmailEnviadosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailEnviados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailEnviadosCountArgs} args - Arguments to filter EmailEnviados to count.
     * @example
     * // Count the number of EmailEnviados
     * const count = await prisma.emailEnviados.count({
     *   where: {
     *     // ... the filter for the EmailEnviados we want to count
     *   }
     * })
    **/
    count<T extends EmailEnviadosCountArgs>(
      args?: Subset<T, EmailEnviadosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailEnviadosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailEnviados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailEnviadosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailEnviadosAggregateArgs>(args: Subset<T, EmailEnviadosAggregateArgs>): Prisma.PrismaPromise<GetEmailEnviadosAggregateType<T>>

    /**
     * Group by EmailEnviados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailEnviadosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailEnviadosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailEnviadosGroupByArgs['orderBy'] }
        : { orderBy?: EmailEnviadosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailEnviadosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailEnviadosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailEnviados model
   */
  readonly fields: EmailEnviadosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailEnviados.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailEnviadosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailEnviados model
   */
  interface EmailEnviadosFieldRefs {
    readonly id: FieldRef<"EmailEnviados", 'Int'>
    readonly usuario_id: FieldRef<"EmailEnviados", 'Int'>
    readonly email: FieldRef<"EmailEnviados", 'String'>
    readonly tipo: FieldRef<"EmailEnviados", 'enum_EmailEnviados_tipo'>
    readonly createdAt: FieldRef<"EmailEnviados", 'DateTime'>
    readonly updatedAt: FieldRef<"EmailEnviados", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailEnviados findUnique
   */
  export type EmailEnviadosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailEnviados
     */
    select?: EmailEnviadosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailEnviados
     */
    omit?: EmailEnviadosOmit<ExtArgs> | null
    /**
     * Filter, which EmailEnviados to fetch.
     */
    where: EmailEnviadosWhereUniqueInput
  }

  /**
   * EmailEnviados findUniqueOrThrow
   */
  export type EmailEnviadosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailEnviados
     */
    select?: EmailEnviadosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailEnviados
     */
    omit?: EmailEnviadosOmit<ExtArgs> | null
    /**
     * Filter, which EmailEnviados to fetch.
     */
    where: EmailEnviadosWhereUniqueInput
  }

  /**
   * EmailEnviados findFirst
   */
  export type EmailEnviadosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailEnviados
     */
    select?: EmailEnviadosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailEnviados
     */
    omit?: EmailEnviadosOmit<ExtArgs> | null
    /**
     * Filter, which EmailEnviados to fetch.
     */
    where?: EmailEnviadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailEnviados to fetch.
     */
    orderBy?: EmailEnviadosOrderByWithRelationInput | EmailEnviadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailEnviados.
     */
    cursor?: EmailEnviadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailEnviados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailEnviados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailEnviados.
     */
    distinct?: EmailEnviadosScalarFieldEnum | EmailEnviadosScalarFieldEnum[]
  }

  /**
   * EmailEnviados findFirstOrThrow
   */
  export type EmailEnviadosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailEnviados
     */
    select?: EmailEnviadosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailEnviados
     */
    omit?: EmailEnviadosOmit<ExtArgs> | null
    /**
     * Filter, which EmailEnviados to fetch.
     */
    where?: EmailEnviadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailEnviados to fetch.
     */
    orderBy?: EmailEnviadosOrderByWithRelationInput | EmailEnviadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailEnviados.
     */
    cursor?: EmailEnviadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailEnviados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailEnviados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailEnviados.
     */
    distinct?: EmailEnviadosScalarFieldEnum | EmailEnviadosScalarFieldEnum[]
  }

  /**
   * EmailEnviados findMany
   */
  export type EmailEnviadosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailEnviados
     */
    select?: EmailEnviadosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailEnviados
     */
    omit?: EmailEnviadosOmit<ExtArgs> | null
    /**
     * Filter, which EmailEnviados to fetch.
     */
    where?: EmailEnviadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailEnviados to fetch.
     */
    orderBy?: EmailEnviadosOrderByWithRelationInput | EmailEnviadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailEnviados.
     */
    cursor?: EmailEnviadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailEnviados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailEnviados.
     */
    skip?: number
    distinct?: EmailEnviadosScalarFieldEnum | EmailEnviadosScalarFieldEnum[]
  }

  /**
   * EmailEnviados create
   */
  export type EmailEnviadosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailEnviados
     */
    select?: EmailEnviadosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailEnviados
     */
    omit?: EmailEnviadosOmit<ExtArgs> | null
    /**
     * The data needed to create a EmailEnviados.
     */
    data: XOR<EmailEnviadosCreateInput, EmailEnviadosUncheckedCreateInput>
  }

  /**
   * EmailEnviados createMany
   */
  export type EmailEnviadosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailEnviados.
     */
    data: EmailEnviadosCreateManyInput | EmailEnviadosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailEnviados createManyAndReturn
   */
  export type EmailEnviadosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailEnviados
     */
    select?: EmailEnviadosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailEnviados
     */
    omit?: EmailEnviadosOmit<ExtArgs> | null
    /**
     * The data used to create many EmailEnviados.
     */
    data: EmailEnviadosCreateManyInput | EmailEnviadosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailEnviados update
   */
  export type EmailEnviadosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailEnviados
     */
    select?: EmailEnviadosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailEnviados
     */
    omit?: EmailEnviadosOmit<ExtArgs> | null
    /**
     * The data needed to update a EmailEnviados.
     */
    data: XOR<EmailEnviadosUpdateInput, EmailEnviadosUncheckedUpdateInput>
    /**
     * Choose, which EmailEnviados to update.
     */
    where: EmailEnviadosWhereUniqueInput
  }

  /**
   * EmailEnviados updateMany
   */
  export type EmailEnviadosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailEnviados.
     */
    data: XOR<EmailEnviadosUpdateManyMutationInput, EmailEnviadosUncheckedUpdateManyInput>
    /**
     * Filter which EmailEnviados to update
     */
    where?: EmailEnviadosWhereInput
    /**
     * Limit how many EmailEnviados to update.
     */
    limit?: number
  }

  /**
   * EmailEnviados updateManyAndReturn
   */
  export type EmailEnviadosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailEnviados
     */
    select?: EmailEnviadosSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailEnviados
     */
    omit?: EmailEnviadosOmit<ExtArgs> | null
    /**
     * The data used to update EmailEnviados.
     */
    data: XOR<EmailEnviadosUpdateManyMutationInput, EmailEnviadosUncheckedUpdateManyInput>
    /**
     * Filter which EmailEnviados to update
     */
    where?: EmailEnviadosWhereInput
    /**
     * Limit how many EmailEnviados to update.
     */
    limit?: number
  }

  /**
   * EmailEnviados upsert
   */
  export type EmailEnviadosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailEnviados
     */
    select?: EmailEnviadosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailEnviados
     */
    omit?: EmailEnviadosOmit<ExtArgs> | null
    /**
     * The filter to search for the EmailEnviados to update in case it exists.
     */
    where: EmailEnviadosWhereUniqueInput
    /**
     * In case the EmailEnviados found by the `where` argument doesn't exist, create a new EmailEnviados with this data.
     */
    create: XOR<EmailEnviadosCreateInput, EmailEnviadosUncheckedCreateInput>
    /**
     * In case the EmailEnviados was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailEnviadosUpdateInput, EmailEnviadosUncheckedUpdateInput>
  }

  /**
   * EmailEnviados delete
   */
  export type EmailEnviadosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailEnviados
     */
    select?: EmailEnviadosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailEnviados
     */
    omit?: EmailEnviadosOmit<ExtArgs> | null
    /**
     * Filter which EmailEnviados to delete.
     */
    where: EmailEnviadosWhereUniqueInput
  }

  /**
   * EmailEnviados deleteMany
   */
  export type EmailEnviadosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailEnviados to delete
     */
    where?: EmailEnviadosWhereInput
    /**
     * Limit how many EmailEnviados to delete.
     */
    limit?: number
  }

  /**
   * EmailEnviados without action
   */
  export type EmailEnviadosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailEnviados
     */
    select?: EmailEnviadosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailEnviados
     */
    omit?: EmailEnviadosOmit<ExtArgs> | null
  }


  /**
   * Model HistoricoIndicacaos
   */

  export type AggregateHistoricoIndicacaos = {
    _count: HistoricoIndicacaosCountAggregateOutputType | null
    _avg: HistoricoIndicacaosAvgAggregateOutputType | null
    _sum: HistoricoIndicacaosSumAggregateOutputType | null
    _min: HistoricoIndicacaosMinAggregateOutputType | null
    _max: HistoricoIndicacaosMaxAggregateOutputType | null
  }

  export type HistoricoIndicacaosAvgAggregateOutputType = {
    id: number | null
    indicador_id: number | null
    indicado_id: number | null
  }

  export type HistoricoIndicacaosSumAggregateOutputType = {
    id: number | null
    indicador_id: number | null
    indicado_id: number | null
  }

  export type HistoricoIndicacaosMinAggregateOutputType = {
    id: number | null
    indicador_id: number | null
    indicado_id: number | null
    tipo: $Enums.enum_HistoricoIndicacaos_tipo | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HistoricoIndicacaosMaxAggregateOutputType = {
    id: number | null
    indicador_id: number | null
    indicado_id: number | null
    tipo: $Enums.enum_HistoricoIndicacaos_tipo | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HistoricoIndicacaosCountAggregateOutputType = {
    id: number
    indicador_id: number
    indicado_id: number
    tipo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HistoricoIndicacaosAvgAggregateInputType = {
    id?: true
    indicador_id?: true
    indicado_id?: true
  }

  export type HistoricoIndicacaosSumAggregateInputType = {
    id?: true
    indicador_id?: true
    indicado_id?: true
  }

  export type HistoricoIndicacaosMinAggregateInputType = {
    id?: true
    indicador_id?: true
    indicado_id?: true
    tipo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HistoricoIndicacaosMaxAggregateInputType = {
    id?: true
    indicador_id?: true
    indicado_id?: true
    tipo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HistoricoIndicacaosCountAggregateInputType = {
    id?: true
    indicador_id?: true
    indicado_id?: true
    tipo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HistoricoIndicacaosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HistoricoIndicacaos to aggregate.
     */
    where?: HistoricoIndicacaosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HistoricoIndicacaos to fetch.
     */
    orderBy?: HistoricoIndicacaosOrderByWithRelationInput | HistoricoIndicacaosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HistoricoIndicacaosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HistoricoIndicacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HistoricoIndicacaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HistoricoIndicacaos
    **/
    _count?: true | HistoricoIndicacaosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HistoricoIndicacaosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HistoricoIndicacaosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HistoricoIndicacaosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HistoricoIndicacaosMaxAggregateInputType
  }

  export type GetHistoricoIndicacaosAggregateType<T extends HistoricoIndicacaosAggregateArgs> = {
        [P in keyof T & keyof AggregateHistoricoIndicacaos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHistoricoIndicacaos[P]>
      : GetScalarType<T[P], AggregateHistoricoIndicacaos[P]>
  }




  export type HistoricoIndicacaosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HistoricoIndicacaosWhereInput
    orderBy?: HistoricoIndicacaosOrderByWithAggregationInput | HistoricoIndicacaosOrderByWithAggregationInput[]
    by: HistoricoIndicacaosScalarFieldEnum[] | HistoricoIndicacaosScalarFieldEnum
    having?: HistoricoIndicacaosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HistoricoIndicacaosCountAggregateInputType | true
    _avg?: HistoricoIndicacaosAvgAggregateInputType
    _sum?: HistoricoIndicacaosSumAggregateInputType
    _min?: HistoricoIndicacaosMinAggregateInputType
    _max?: HistoricoIndicacaosMaxAggregateInputType
  }

  export type HistoricoIndicacaosGroupByOutputType = {
    id: number
    indicador_id: number
    indicado_id: number
    tipo: $Enums.enum_HistoricoIndicacaos_tipo | null
    createdAt: Date
    updatedAt: Date
    _count: HistoricoIndicacaosCountAggregateOutputType | null
    _avg: HistoricoIndicacaosAvgAggregateOutputType | null
    _sum: HistoricoIndicacaosSumAggregateOutputType | null
    _min: HistoricoIndicacaosMinAggregateOutputType | null
    _max: HistoricoIndicacaosMaxAggregateOutputType | null
  }

  type GetHistoricoIndicacaosGroupByPayload<T extends HistoricoIndicacaosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HistoricoIndicacaosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HistoricoIndicacaosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HistoricoIndicacaosGroupByOutputType[P]>
            : GetScalarType<T[P], HistoricoIndicacaosGroupByOutputType[P]>
        }
      >
    >


  export type HistoricoIndicacaosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    indicador_id?: boolean
    indicado_id?: boolean
    tipo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["historicoIndicacaos"]>

  export type HistoricoIndicacaosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    indicador_id?: boolean
    indicado_id?: boolean
    tipo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["historicoIndicacaos"]>

  export type HistoricoIndicacaosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    indicador_id?: boolean
    indicado_id?: boolean
    tipo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["historicoIndicacaos"]>

  export type HistoricoIndicacaosSelectScalar = {
    id?: boolean
    indicador_id?: boolean
    indicado_id?: boolean
    tipo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HistoricoIndicacaosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "indicador_id" | "indicado_id" | "tipo" | "createdAt" | "updatedAt", ExtArgs["result"]["historicoIndicacaos"]>

  export type $HistoricoIndicacaosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HistoricoIndicacaos"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      indicador_id: number
      indicado_id: number
      tipo: $Enums.enum_HistoricoIndicacaos_tipo | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["historicoIndicacaos"]>
    composites: {}
  }

  type HistoricoIndicacaosGetPayload<S extends boolean | null | undefined | HistoricoIndicacaosDefaultArgs> = $Result.GetResult<Prisma.$HistoricoIndicacaosPayload, S>

  type HistoricoIndicacaosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HistoricoIndicacaosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HistoricoIndicacaosCountAggregateInputType | true
    }

  export interface HistoricoIndicacaosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HistoricoIndicacaos'], meta: { name: 'HistoricoIndicacaos' } }
    /**
     * Find zero or one HistoricoIndicacaos that matches the filter.
     * @param {HistoricoIndicacaosFindUniqueArgs} args - Arguments to find a HistoricoIndicacaos
     * @example
     * // Get one HistoricoIndicacaos
     * const historicoIndicacaos = await prisma.historicoIndicacaos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HistoricoIndicacaosFindUniqueArgs>(args: SelectSubset<T, HistoricoIndicacaosFindUniqueArgs<ExtArgs>>): Prisma__HistoricoIndicacaosClient<$Result.GetResult<Prisma.$HistoricoIndicacaosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HistoricoIndicacaos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HistoricoIndicacaosFindUniqueOrThrowArgs} args - Arguments to find a HistoricoIndicacaos
     * @example
     * // Get one HistoricoIndicacaos
     * const historicoIndicacaos = await prisma.historicoIndicacaos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HistoricoIndicacaosFindUniqueOrThrowArgs>(args: SelectSubset<T, HistoricoIndicacaosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HistoricoIndicacaosClient<$Result.GetResult<Prisma.$HistoricoIndicacaosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HistoricoIndicacaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoricoIndicacaosFindFirstArgs} args - Arguments to find a HistoricoIndicacaos
     * @example
     * // Get one HistoricoIndicacaos
     * const historicoIndicacaos = await prisma.historicoIndicacaos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HistoricoIndicacaosFindFirstArgs>(args?: SelectSubset<T, HistoricoIndicacaosFindFirstArgs<ExtArgs>>): Prisma__HistoricoIndicacaosClient<$Result.GetResult<Prisma.$HistoricoIndicacaosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HistoricoIndicacaos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoricoIndicacaosFindFirstOrThrowArgs} args - Arguments to find a HistoricoIndicacaos
     * @example
     * // Get one HistoricoIndicacaos
     * const historicoIndicacaos = await prisma.historicoIndicacaos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HistoricoIndicacaosFindFirstOrThrowArgs>(args?: SelectSubset<T, HistoricoIndicacaosFindFirstOrThrowArgs<ExtArgs>>): Prisma__HistoricoIndicacaosClient<$Result.GetResult<Prisma.$HistoricoIndicacaosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HistoricoIndicacaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoricoIndicacaosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HistoricoIndicacaos
     * const historicoIndicacaos = await prisma.historicoIndicacaos.findMany()
     * 
     * // Get first 10 HistoricoIndicacaos
     * const historicoIndicacaos = await prisma.historicoIndicacaos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const historicoIndicacaosWithIdOnly = await prisma.historicoIndicacaos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HistoricoIndicacaosFindManyArgs>(args?: SelectSubset<T, HistoricoIndicacaosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HistoricoIndicacaosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HistoricoIndicacaos.
     * @param {HistoricoIndicacaosCreateArgs} args - Arguments to create a HistoricoIndicacaos.
     * @example
     * // Create one HistoricoIndicacaos
     * const HistoricoIndicacaos = await prisma.historicoIndicacaos.create({
     *   data: {
     *     // ... data to create a HistoricoIndicacaos
     *   }
     * })
     * 
     */
    create<T extends HistoricoIndicacaosCreateArgs>(args: SelectSubset<T, HistoricoIndicacaosCreateArgs<ExtArgs>>): Prisma__HistoricoIndicacaosClient<$Result.GetResult<Prisma.$HistoricoIndicacaosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HistoricoIndicacaos.
     * @param {HistoricoIndicacaosCreateManyArgs} args - Arguments to create many HistoricoIndicacaos.
     * @example
     * // Create many HistoricoIndicacaos
     * const historicoIndicacaos = await prisma.historicoIndicacaos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HistoricoIndicacaosCreateManyArgs>(args?: SelectSubset<T, HistoricoIndicacaosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HistoricoIndicacaos and returns the data saved in the database.
     * @param {HistoricoIndicacaosCreateManyAndReturnArgs} args - Arguments to create many HistoricoIndicacaos.
     * @example
     * // Create many HistoricoIndicacaos
     * const historicoIndicacaos = await prisma.historicoIndicacaos.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HistoricoIndicacaos and only return the `id`
     * const historicoIndicacaosWithIdOnly = await prisma.historicoIndicacaos.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HistoricoIndicacaosCreateManyAndReturnArgs>(args?: SelectSubset<T, HistoricoIndicacaosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HistoricoIndicacaosPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a HistoricoIndicacaos.
     * @param {HistoricoIndicacaosDeleteArgs} args - Arguments to delete one HistoricoIndicacaos.
     * @example
     * // Delete one HistoricoIndicacaos
     * const HistoricoIndicacaos = await prisma.historicoIndicacaos.delete({
     *   where: {
     *     // ... filter to delete one HistoricoIndicacaos
     *   }
     * })
     * 
     */
    delete<T extends HistoricoIndicacaosDeleteArgs>(args: SelectSubset<T, HistoricoIndicacaosDeleteArgs<ExtArgs>>): Prisma__HistoricoIndicacaosClient<$Result.GetResult<Prisma.$HistoricoIndicacaosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HistoricoIndicacaos.
     * @param {HistoricoIndicacaosUpdateArgs} args - Arguments to update one HistoricoIndicacaos.
     * @example
     * // Update one HistoricoIndicacaos
     * const historicoIndicacaos = await prisma.historicoIndicacaos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HistoricoIndicacaosUpdateArgs>(args: SelectSubset<T, HistoricoIndicacaosUpdateArgs<ExtArgs>>): Prisma__HistoricoIndicacaosClient<$Result.GetResult<Prisma.$HistoricoIndicacaosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HistoricoIndicacaos.
     * @param {HistoricoIndicacaosDeleteManyArgs} args - Arguments to filter HistoricoIndicacaos to delete.
     * @example
     * // Delete a few HistoricoIndicacaos
     * const { count } = await prisma.historicoIndicacaos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HistoricoIndicacaosDeleteManyArgs>(args?: SelectSubset<T, HistoricoIndicacaosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HistoricoIndicacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoricoIndicacaosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HistoricoIndicacaos
     * const historicoIndicacaos = await prisma.historicoIndicacaos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HistoricoIndicacaosUpdateManyArgs>(args: SelectSubset<T, HistoricoIndicacaosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HistoricoIndicacaos and returns the data updated in the database.
     * @param {HistoricoIndicacaosUpdateManyAndReturnArgs} args - Arguments to update many HistoricoIndicacaos.
     * @example
     * // Update many HistoricoIndicacaos
     * const historicoIndicacaos = await prisma.historicoIndicacaos.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HistoricoIndicacaos and only return the `id`
     * const historicoIndicacaosWithIdOnly = await prisma.historicoIndicacaos.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HistoricoIndicacaosUpdateManyAndReturnArgs>(args: SelectSubset<T, HistoricoIndicacaosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HistoricoIndicacaosPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one HistoricoIndicacaos.
     * @param {HistoricoIndicacaosUpsertArgs} args - Arguments to update or create a HistoricoIndicacaos.
     * @example
     * // Update or create a HistoricoIndicacaos
     * const historicoIndicacaos = await prisma.historicoIndicacaos.upsert({
     *   create: {
     *     // ... data to create a HistoricoIndicacaos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HistoricoIndicacaos we want to update
     *   }
     * })
     */
    upsert<T extends HistoricoIndicacaosUpsertArgs>(args: SelectSubset<T, HistoricoIndicacaosUpsertArgs<ExtArgs>>): Prisma__HistoricoIndicacaosClient<$Result.GetResult<Prisma.$HistoricoIndicacaosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HistoricoIndicacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoricoIndicacaosCountArgs} args - Arguments to filter HistoricoIndicacaos to count.
     * @example
     * // Count the number of HistoricoIndicacaos
     * const count = await prisma.historicoIndicacaos.count({
     *   where: {
     *     // ... the filter for the HistoricoIndicacaos we want to count
     *   }
     * })
    **/
    count<T extends HistoricoIndicacaosCountArgs>(
      args?: Subset<T, HistoricoIndicacaosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HistoricoIndicacaosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HistoricoIndicacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoricoIndicacaosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HistoricoIndicacaosAggregateArgs>(args: Subset<T, HistoricoIndicacaosAggregateArgs>): Prisma.PrismaPromise<GetHistoricoIndicacaosAggregateType<T>>

    /**
     * Group by HistoricoIndicacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoricoIndicacaosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HistoricoIndicacaosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HistoricoIndicacaosGroupByArgs['orderBy'] }
        : { orderBy?: HistoricoIndicacaosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HistoricoIndicacaosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHistoricoIndicacaosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HistoricoIndicacaos model
   */
  readonly fields: HistoricoIndicacaosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HistoricoIndicacaos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HistoricoIndicacaosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HistoricoIndicacaos model
   */
  interface HistoricoIndicacaosFieldRefs {
    readonly id: FieldRef<"HistoricoIndicacaos", 'Int'>
    readonly indicador_id: FieldRef<"HistoricoIndicacaos", 'Int'>
    readonly indicado_id: FieldRef<"HistoricoIndicacaos", 'Int'>
    readonly tipo: FieldRef<"HistoricoIndicacaos", 'enum_HistoricoIndicacaos_tipo'>
    readonly createdAt: FieldRef<"HistoricoIndicacaos", 'DateTime'>
    readonly updatedAt: FieldRef<"HistoricoIndicacaos", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HistoricoIndicacaos findUnique
   */
  export type HistoricoIndicacaosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistoricoIndicacaos
     */
    select?: HistoricoIndicacaosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistoricoIndicacaos
     */
    omit?: HistoricoIndicacaosOmit<ExtArgs> | null
    /**
     * Filter, which HistoricoIndicacaos to fetch.
     */
    where: HistoricoIndicacaosWhereUniqueInput
  }

  /**
   * HistoricoIndicacaos findUniqueOrThrow
   */
  export type HistoricoIndicacaosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistoricoIndicacaos
     */
    select?: HistoricoIndicacaosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistoricoIndicacaos
     */
    omit?: HistoricoIndicacaosOmit<ExtArgs> | null
    /**
     * Filter, which HistoricoIndicacaos to fetch.
     */
    where: HistoricoIndicacaosWhereUniqueInput
  }

  /**
   * HistoricoIndicacaos findFirst
   */
  export type HistoricoIndicacaosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistoricoIndicacaos
     */
    select?: HistoricoIndicacaosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistoricoIndicacaos
     */
    omit?: HistoricoIndicacaosOmit<ExtArgs> | null
    /**
     * Filter, which HistoricoIndicacaos to fetch.
     */
    where?: HistoricoIndicacaosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HistoricoIndicacaos to fetch.
     */
    orderBy?: HistoricoIndicacaosOrderByWithRelationInput | HistoricoIndicacaosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HistoricoIndicacaos.
     */
    cursor?: HistoricoIndicacaosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HistoricoIndicacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HistoricoIndicacaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HistoricoIndicacaos.
     */
    distinct?: HistoricoIndicacaosScalarFieldEnum | HistoricoIndicacaosScalarFieldEnum[]
  }

  /**
   * HistoricoIndicacaos findFirstOrThrow
   */
  export type HistoricoIndicacaosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistoricoIndicacaos
     */
    select?: HistoricoIndicacaosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistoricoIndicacaos
     */
    omit?: HistoricoIndicacaosOmit<ExtArgs> | null
    /**
     * Filter, which HistoricoIndicacaos to fetch.
     */
    where?: HistoricoIndicacaosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HistoricoIndicacaos to fetch.
     */
    orderBy?: HistoricoIndicacaosOrderByWithRelationInput | HistoricoIndicacaosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HistoricoIndicacaos.
     */
    cursor?: HistoricoIndicacaosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HistoricoIndicacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HistoricoIndicacaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HistoricoIndicacaos.
     */
    distinct?: HistoricoIndicacaosScalarFieldEnum | HistoricoIndicacaosScalarFieldEnum[]
  }

  /**
   * HistoricoIndicacaos findMany
   */
  export type HistoricoIndicacaosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistoricoIndicacaos
     */
    select?: HistoricoIndicacaosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistoricoIndicacaos
     */
    omit?: HistoricoIndicacaosOmit<ExtArgs> | null
    /**
     * Filter, which HistoricoIndicacaos to fetch.
     */
    where?: HistoricoIndicacaosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HistoricoIndicacaos to fetch.
     */
    orderBy?: HistoricoIndicacaosOrderByWithRelationInput | HistoricoIndicacaosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HistoricoIndicacaos.
     */
    cursor?: HistoricoIndicacaosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HistoricoIndicacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HistoricoIndicacaos.
     */
    skip?: number
    distinct?: HistoricoIndicacaosScalarFieldEnum | HistoricoIndicacaosScalarFieldEnum[]
  }

  /**
   * HistoricoIndicacaos create
   */
  export type HistoricoIndicacaosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistoricoIndicacaos
     */
    select?: HistoricoIndicacaosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistoricoIndicacaos
     */
    omit?: HistoricoIndicacaosOmit<ExtArgs> | null
    /**
     * The data needed to create a HistoricoIndicacaos.
     */
    data: XOR<HistoricoIndicacaosCreateInput, HistoricoIndicacaosUncheckedCreateInput>
  }

  /**
   * HistoricoIndicacaos createMany
   */
  export type HistoricoIndicacaosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HistoricoIndicacaos.
     */
    data: HistoricoIndicacaosCreateManyInput | HistoricoIndicacaosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HistoricoIndicacaos createManyAndReturn
   */
  export type HistoricoIndicacaosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistoricoIndicacaos
     */
    select?: HistoricoIndicacaosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HistoricoIndicacaos
     */
    omit?: HistoricoIndicacaosOmit<ExtArgs> | null
    /**
     * The data used to create many HistoricoIndicacaos.
     */
    data: HistoricoIndicacaosCreateManyInput | HistoricoIndicacaosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HistoricoIndicacaos update
   */
  export type HistoricoIndicacaosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistoricoIndicacaos
     */
    select?: HistoricoIndicacaosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistoricoIndicacaos
     */
    omit?: HistoricoIndicacaosOmit<ExtArgs> | null
    /**
     * The data needed to update a HistoricoIndicacaos.
     */
    data: XOR<HistoricoIndicacaosUpdateInput, HistoricoIndicacaosUncheckedUpdateInput>
    /**
     * Choose, which HistoricoIndicacaos to update.
     */
    where: HistoricoIndicacaosWhereUniqueInput
  }

  /**
   * HistoricoIndicacaos updateMany
   */
  export type HistoricoIndicacaosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HistoricoIndicacaos.
     */
    data: XOR<HistoricoIndicacaosUpdateManyMutationInput, HistoricoIndicacaosUncheckedUpdateManyInput>
    /**
     * Filter which HistoricoIndicacaos to update
     */
    where?: HistoricoIndicacaosWhereInput
    /**
     * Limit how many HistoricoIndicacaos to update.
     */
    limit?: number
  }

  /**
   * HistoricoIndicacaos updateManyAndReturn
   */
  export type HistoricoIndicacaosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistoricoIndicacaos
     */
    select?: HistoricoIndicacaosSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HistoricoIndicacaos
     */
    omit?: HistoricoIndicacaosOmit<ExtArgs> | null
    /**
     * The data used to update HistoricoIndicacaos.
     */
    data: XOR<HistoricoIndicacaosUpdateManyMutationInput, HistoricoIndicacaosUncheckedUpdateManyInput>
    /**
     * Filter which HistoricoIndicacaos to update
     */
    where?: HistoricoIndicacaosWhereInput
    /**
     * Limit how many HistoricoIndicacaos to update.
     */
    limit?: number
  }

  /**
   * HistoricoIndicacaos upsert
   */
  export type HistoricoIndicacaosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistoricoIndicacaos
     */
    select?: HistoricoIndicacaosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistoricoIndicacaos
     */
    omit?: HistoricoIndicacaosOmit<ExtArgs> | null
    /**
     * The filter to search for the HistoricoIndicacaos to update in case it exists.
     */
    where: HistoricoIndicacaosWhereUniqueInput
    /**
     * In case the HistoricoIndicacaos found by the `where` argument doesn't exist, create a new HistoricoIndicacaos with this data.
     */
    create: XOR<HistoricoIndicacaosCreateInput, HistoricoIndicacaosUncheckedCreateInput>
    /**
     * In case the HistoricoIndicacaos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HistoricoIndicacaosUpdateInput, HistoricoIndicacaosUncheckedUpdateInput>
  }

  /**
   * HistoricoIndicacaos delete
   */
  export type HistoricoIndicacaosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistoricoIndicacaos
     */
    select?: HistoricoIndicacaosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistoricoIndicacaos
     */
    omit?: HistoricoIndicacaosOmit<ExtArgs> | null
    /**
     * Filter which HistoricoIndicacaos to delete.
     */
    where: HistoricoIndicacaosWhereUniqueInput
  }

  /**
   * HistoricoIndicacaos deleteMany
   */
  export type HistoricoIndicacaosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HistoricoIndicacaos to delete
     */
    where?: HistoricoIndicacaosWhereInput
    /**
     * Limit how many HistoricoIndicacaos to delete.
     */
    limit?: number
  }

  /**
   * HistoricoIndicacaos without action
   */
  export type HistoricoIndicacaosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistoricoIndicacaos
     */
    select?: HistoricoIndicacaosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistoricoIndicacaos
     */
    omit?: HistoricoIndicacaosOmit<ExtArgs> | null
  }


  /**
   * Model HistoricoSelfies
   */

  export type AggregateHistoricoSelfies = {
    _count: HistoricoSelfiesCountAggregateOutputType | null
    _avg: HistoricoSelfiesAvgAggregateOutputType | null
    _sum: HistoricoSelfiesSumAggregateOutputType | null
    _min: HistoricoSelfiesMinAggregateOutputType | null
    _max: HistoricoSelfiesMaxAggregateOutputType | null
  }

  export type HistoricoSelfiesAvgAggregateOutputType = {
    id: number | null
    usuario_id: number | null
  }

  export type HistoricoSelfiesSumAggregateOutputType = {
    id: number | null
    usuario_id: number | null
  }

  export type HistoricoSelfiesMinAggregateOutputType = {
    id: number | null
    usuario_id: number | null
    tipo: $Enums.enum_HistoricoSelfies_tipo | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HistoricoSelfiesMaxAggregateOutputType = {
    id: number | null
    usuario_id: number | null
    tipo: $Enums.enum_HistoricoSelfies_tipo | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HistoricoSelfiesCountAggregateOutputType = {
    id: number
    usuario_id: number
    tipo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HistoricoSelfiesAvgAggregateInputType = {
    id?: true
    usuario_id?: true
  }

  export type HistoricoSelfiesSumAggregateInputType = {
    id?: true
    usuario_id?: true
  }

  export type HistoricoSelfiesMinAggregateInputType = {
    id?: true
    usuario_id?: true
    tipo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HistoricoSelfiesMaxAggregateInputType = {
    id?: true
    usuario_id?: true
    tipo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HistoricoSelfiesCountAggregateInputType = {
    id?: true
    usuario_id?: true
    tipo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HistoricoSelfiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HistoricoSelfies to aggregate.
     */
    where?: HistoricoSelfiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HistoricoSelfies to fetch.
     */
    orderBy?: HistoricoSelfiesOrderByWithRelationInput | HistoricoSelfiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HistoricoSelfiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HistoricoSelfies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HistoricoSelfies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HistoricoSelfies
    **/
    _count?: true | HistoricoSelfiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HistoricoSelfiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HistoricoSelfiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HistoricoSelfiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HistoricoSelfiesMaxAggregateInputType
  }

  export type GetHistoricoSelfiesAggregateType<T extends HistoricoSelfiesAggregateArgs> = {
        [P in keyof T & keyof AggregateHistoricoSelfies]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHistoricoSelfies[P]>
      : GetScalarType<T[P], AggregateHistoricoSelfies[P]>
  }




  export type HistoricoSelfiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HistoricoSelfiesWhereInput
    orderBy?: HistoricoSelfiesOrderByWithAggregationInput | HistoricoSelfiesOrderByWithAggregationInput[]
    by: HistoricoSelfiesScalarFieldEnum[] | HistoricoSelfiesScalarFieldEnum
    having?: HistoricoSelfiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HistoricoSelfiesCountAggregateInputType | true
    _avg?: HistoricoSelfiesAvgAggregateInputType
    _sum?: HistoricoSelfiesSumAggregateInputType
    _min?: HistoricoSelfiesMinAggregateInputType
    _max?: HistoricoSelfiesMaxAggregateInputType
  }

  export type HistoricoSelfiesGroupByOutputType = {
    id: number
    usuario_id: number
    tipo: $Enums.enum_HistoricoSelfies_tipo | null
    createdAt: Date
    updatedAt: Date
    _count: HistoricoSelfiesCountAggregateOutputType | null
    _avg: HistoricoSelfiesAvgAggregateOutputType | null
    _sum: HistoricoSelfiesSumAggregateOutputType | null
    _min: HistoricoSelfiesMinAggregateOutputType | null
    _max: HistoricoSelfiesMaxAggregateOutputType | null
  }

  type GetHistoricoSelfiesGroupByPayload<T extends HistoricoSelfiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HistoricoSelfiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HistoricoSelfiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HistoricoSelfiesGroupByOutputType[P]>
            : GetScalarType<T[P], HistoricoSelfiesGroupByOutputType[P]>
        }
      >
    >


  export type HistoricoSelfiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    tipo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["historicoSelfies"]>

  export type HistoricoSelfiesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    tipo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["historicoSelfies"]>

  export type HistoricoSelfiesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    tipo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["historicoSelfies"]>

  export type HistoricoSelfiesSelectScalar = {
    id?: boolean
    usuario_id?: boolean
    tipo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HistoricoSelfiesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "usuario_id" | "tipo" | "createdAt" | "updatedAt", ExtArgs["result"]["historicoSelfies"]>

  export type $HistoricoSelfiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HistoricoSelfies"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      usuario_id: number
      tipo: $Enums.enum_HistoricoSelfies_tipo | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["historicoSelfies"]>
    composites: {}
  }

  type HistoricoSelfiesGetPayload<S extends boolean | null | undefined | HistoricoSelfiesDefaultArgs> = $Result.GetResult<Prisma.$HistoricoSelfiesPayload, S>

  type HistoricoSelfiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HistoricoSelfiesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HistoricoSelfiesCountAggregateInputType | true
    }

  export interface HistoricoSelfiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HistoricoSelfies'], meta: { name: 'HistoricoSelfies' } }
    /**
     * Find zero or one HistoricoSelfies that matches the filter.
     * @param {HistoricoSelfiesFindUniqueArgs} args - Arguments to find a HistoricoSelfies
     * @example
     * // Get one HistoricoSelfies
     * const historicoSelfies = await prisma.historicoSelfies.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HistoricoSelfiesFindUniqueArgs>(args: SelectSubset<T, HistoricoSelfiesFindUniqueArgs<ExtArgs>>): Prisma__HistoricoSelfiesClient<$Result.GetResult<Prisma.$HistoricoSelfiesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HistoricoSelfies that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HistoricoSelfiesFindUniqueOrThrowArgs} args - Arguments to find a HistoricoSelfies
     * @example
     * // Get one HistoricoSelfies
     * const historicoSelfies = await prisma.historicoSelfies.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HistoricoSelfiesFindUniqueOrThrowArgs>(args: SelectSubset<T, HistoricoSelfiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HistoricoSelfiesClient<$Result.GetResult<Prisma.$HistoricoSelfiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HistoricoSelfies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoricoSelfiesFindFirstArgs} args - Arguments to find a HistoricoSelfies
     * @example
     * // Get one HistoricoSelfies
     * const historicoSelfies = await prisma.historicoSelfies.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HistoricoSelfiesFindFirstArgs>(args?: SelectSubset<T, HistoricoSelfiesFindFirstArgs<ExtArgs>>): Prisma__HistoricoSelfiesClient<$Result.GetResult<Prisma.$HistoricoSelfiesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HistoricoSelfies that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoricoSelfiesFindFirstOrThrowArgs} args - Arguments to find a HistoricoSelfies
     * @example
     * // Get one HistoricoSelfies
     * const historicoSelfies = await prisma.historicoSelfies.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HistoricoSelfiesFindFirstOrThrowArgs>(args?: SelectSubset<T, HistoricoSelfiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__HistoricoSelfiesClient<$Result.GetResult<Prisma.$HistoricoSelfiesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HistoricoSelfies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoricoSelfiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HistoricoSelfies
     * const historicoSelfies = await prisma.historicoSelfies.findMany()
     * 
     * // Get first 10 HistoricoSelfies
     * const historicoSelfies = await prisma.historicoSelfies.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const historicoSelfiesWithIdOnly = await prisma.historicoSelfies.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HistoricoSelfiesFindManyArgs>(args?: SelectSubset<T, HistoricoSelfiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HistoricoSelfiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HistoricoSelfies.
     * @param {HistoricoSelfiesCreateArgs} args - Arguments to create a HistoricoSelfies.
     * @example
     * // Create one HistoricoSelfies
     * const HistoricoSelfies = await prisma.historicoSelfies.create({
     *   data: {
     *     // ... data to create a HistoricoSelfies
     *   }
     * })
     * 
     */
    create<T extends HistoricoSelfiesCreateArgs>(args: SelectSubset<T, HistoricoSelfiesCreateArgs<ExtArgs>>): Prisma__HistoricoSelfiesClient<$Result.GetResult<Prisma.$HistoricoSelfiesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HistoricoSelfies.
     * @param {HistoricoSelfiesCreateManyArgs} args - Arguments to create many HistoricoSelfies.
     * @example
     * // Create many HistoricoSelfies
     * const historicoSelfies = await prisma.historicoSelfies.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HistoricoSelfiesCreateManyArgs>(args?: SelectSubset<T, HistoricoSelfiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HistoricoSelfies and returns the data saved in the database.
     * @param {HistoricoSelfiesCreateManyAndReturnArgs} args - Arguments to create many HistoricoSelfies.
     * @example
     * // Create many HistoricoSelfies
     * const historicoSelfies = await prisma.historicoSelfies.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HistoricoSelfies and only return the `id`
     * const historicoSelfiesWithIdOnly = await prisma.historicoSelfies.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HistoricoSelfiesCreateManyAndReturnArgs>(args?: SelectSubset<T, HistoricoSelfiesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HistoricoSelfiesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a HistoricoSelfies.
     * @param {HistoricoSelfiesDeleteArgs} args - Arguments to delete one HistoricoSelfies.
     * @example
     * // Delete one HistoricoSelfies
     * const HistoricoSelfies = await prisma.historicoSelfies.delete({
     *   where: {
     *     // ... filter to delete one HistoricoSelfies
     *   }
     * })
     * 
     */
    delete<T extends HistoricoSelfiesDeleteArgs>(args: SelectSubset<T, HistoricoSelfiesDeleteArgs<ExtArgs>>): Prisma__HistoricoSelfiesClient<$Result.GetResult<Prisma.$HistoricoSelfiesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HistoricoSelfies.
     * @param {HistoricoSelfiesUpdateArgs} args - Arguments to update one HistoricoSelfies.
     * @example
     * // Update one HistoricoSelfies
     * const historicoSelfies = await prisma.historicoSelfies.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HistoricoSelfiesUpdateArgs>(args: SelectSubset<T, HistoricoSelfiesUpdateArgs<ExtArgs>>): Prisma__HistoricoSelfiesClient<$Result.GetResult<Prisma.$HistoricoSelfiesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HistoricoSelfies.
     * @param {HistoricoSelfiesDeleteManyArgs} args - Arguments to filter HistoricoSelfies to delete.
     * @example
     * // Delete a few HistoricoSelfies
     * const { count } = await prisma.historicoSelfies.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HistoricoSelfiesDeleteManyArgs>(args?: SelectSubset<T, HistoricoSelfiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HistoricoSelfies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoricoSelfiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HistoricoSelfies
     * const historicoSelfies = await prisma.historicoSelfies.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HistoricoSelfiesUpdateManyArgs>(args: SelectSubset<T, HistoricoSelfiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HistoricoSelfies and returns the data updated in the database.
     * @param {HistoricoSelfiesUpdateManyAndReturnArgs} args - Arguments to update many HistoricoSelfies.
     * @example
     * // Update many HistoricoSelfies
     * const historicoSelfies = await prisma.historicoSelfies.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HistoricoSelfies and only return the `id`
     * const historicoSelfiesWithIdOnly = await prisma.historicoSelfies.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HistoricoSelfiesUpdateManyAndReturnArgs>(args: SelectSubset<T, HistoricoSelfiesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HistoricoSelfiesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one HistoricoSelfies.
     * @param {HistoricoSelfiesUpsertArgs} args - Arguments to update or create a HistoricoSelfies.
     * @example
     * // Update or create a HistoricoSelfies
     * const historicoSelfies = await prisma.historicoSelfies.upsert({
     *   create: {
     *     // ... data to create a HistoricoSelfies
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HistoricoSelfies we want to update
     *   }
     * })
     */
    upsert<T extends HistoricoSelfiesUpsertArgs>(args: SelectSubset<T, HistoricoSelfiesUpsertArgs<ExtArgs>>): Prisma__HistoricoSelfiesClient<$Result.GetResult<Prisma.$HistoricoSelfiesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HistoricoSelfies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoricoSelfiesCountArgs} args - Arguments to filter HistoricoSelfies to count.
     * @example
     * // Count the number of HistoricoSelfies
     * const count = await prisma.historicoSelfies.count({
     *   where: {
     *     // ... the filter for the HistoricoSelfies we want to count
     *   }
     * })
    **/
    count<T extends HistoricoSelfiesCountArgs>(
      args?: Subset<T, HistoricoSelfiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HistoricoSelfiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HistoricoSelfies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoricoSelfiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HistoricoSelfiesAggregateArgs>(args: Subset<T, HistoricoSelfiesAggregateArgs>): Prisma.PrismaPromise<GetHistoricoSelfiesAggregateType<T>>

    /**
     * Group by HistoricoSelfies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoricoSelfiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HistoricoSelfiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HistoricoSelfiesGroupByArgs['orderBy'] }
        : { orderBy?: HistoricoSelfiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HistoricoSelfiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHistoricoSelfiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HistoricoSelfies model
   */
  readonly fields: HistoricoSelfiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HistoricoSelfies.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HistoricoSelfiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HistoricoSelfies model
   */
  interface HistoricoSelfiesFieldRefs {
    readonly id: FieldRef<"HistoricoSelfies", 'Int'>
    readonly usuario_id: FieldRef<"HistoricoSelfies", 'Int'>
    readonly tipo: FieldRef<"HistoricoSelfies", 'enum_HistoricoSelfies_tipo'>
    readonly createdAt: FieldRef<"HistoricoSelfies", 'DateTime'>
    readonly updatedAt: FieldRef<"HistoricoSelfies", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HistoricoSelfies findUnique
   */
  export type HistoricoSelfiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistoricoSelfies
     */
    select?: HistoricoSelfiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistoricoSelfies
     */
    omit?: HistoricoSelfiesOmit<ExtArgs> | null
    /**
     * Filter, which HistoricoSelfies to fetch.
     */
    where: HistoricoSelfiesWhereUniqueInput
  }

  /**
   * HistoricoSelfies findUniqueOrThrow
   */
  export type HistoricoSelfiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistoricoSelfies
     */
    select?: HistoricoSelfiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistoricoSelfies
     */
    omit?: HistoricoSelfiesOmit<ExtArgs> | null
    /**
     * Filter, which HistoricoSelfies to fetch.
     */
    where: HistoricoSelfiesWhereUniqueInput
  }

  /**
   * HistoricoSelfies findFirst
   */
  export type HistoricoSelfiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistoricoSelfies
     */
    select?: HistoricoSelfiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistoricoSelfies
     */
    omit?: HistoricoSelfiesOmit<ExtArgs> | null
    /**
     * Filter, which HistoricoSelfies to fetch.
     */
    where?: HistoricoSelfiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HistoricoSelfies to fetch.
     */
    orderBy?: HistoricoSelfiesOrderByWithRelationInput | HistoricoSelfiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HistoricoSelfies.
     */
    cursor?: HistoricoSelfiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HistoricoSelfies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HistoricoSelfies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HistoricoSelfies.
     */
    distinct?: HistoricoSelfiesScalarFieldEnum | HistoricoSelfiesScalarFieldEnum[]
  }

  /**
   * HistoricoSelfies findFirstOrThrow
   */
  export type HistoricoSelfiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistoricoSelfies
     */
    select?: HistoricoSelfiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistoricoSelfies
     */
    omit?: HistoricoSelfiesOmit<ExtArgs> | null
    /**
     * Filter, which HistoricoSelfies to fetch.
     */
    where?: HistoricoSelfiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HistoricoSelfies to fetch.
     */
    orderBy?: HistoricoSelfiesOrderByWithRelationInput | HistoricoSelfiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HistoricoSelfies.
     */
    cursor?: HistoricoSelfiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HistoricoSelfies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HistoricoSelfies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HistoricoSelfies.
     */
    distinct?: HistoricoSelfiesScalarFieldEnum | HistoricoSelfiesScalarFieldEnum[]
  }

  /**
   * HistoricoSelfies findMany
   */
  export type HistoricoSelfiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistoricoSelfies
     */
    select?: HistoricoSelfiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistoricoSelfies
     */
    omit?: HistoricoSelfiesOmit<ExtArgs> | null
    /**
     * Filter, which HistoricoSelfies to fetch.
     */
    where?: HistoricoSelfiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HistoricoSelfies to fetch.
     */
    orderBy?: HistoricoSelfiesOrderByWithRelationInput | HistoricoSelfiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HistoricoSelfies.
     */
    cursor?: HistoricoSelfiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HistoricoSelfies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HistoricoSelfies.
     */
    skip?: number
    distinct?: HistoricoSelfiesScalarFieldEnum | HistoricoSelfiesScalarFieldEnum[]
  }

  /**
   * HistoricoSelfies create
   */
  export type HistoricoSelfiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistoricoSelfies
     */
    select?: HistoricoSelfiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistoricoSelfies
     */
    omit?: HistoricoSelfiesOmit<ExtArgs> | null
    /**
     * The data needed to create a HistoricoSelfies.
     */
    data: XOR<HistoricoSelfiesCreateInput, HistoricoSelfiesUncheckedCreateInput>
  }

  /**
   * HistoricoSelfies createMany
   */
  export type HistoricoSelfiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HistoricoSelfies.
     */
    data: HistoricoSelfiesCreateManyInput | HistoricoSelfiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HistoricoSelfies createManyAndReturn
   */
  export type HistoricoSelfiesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistoricoSelfies
     */
    select?: HistoricoSelfiesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HistoricoSelfies
     */
    omit?: HistoricoSelfiesOmit<ExtArgs> | null
    /**
     * The data used to create many HistoricoSelfies.
     */
    data: HistoricoSelfiesCreateManyInput | HistoricoSelfiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HistoricoSelfies update
   */
  export type HistoricoSelfiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistoricoSelfies
     */
    select?: HistoricoSelfiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistoricoSelfies
     */
    omit?: HistoricoSelfiesOmit<ExtArgs> | null
    /**
     * The data needed to update a HistoricoSelfies.
     */
    data: XOR<HistoricoSelfiesUpdateInput, HistoricoSelfiesUncheckedUpdateInput>
    /**
     * Choose, which HistoricoSelfies to update.
     */
    where: HistoricoSelfiesWhereUniqueInput
  }

  /**
   * HistoricoSelfies updateMany
   */
  export type HistoricoSelfiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HistoricoSelfies.
     */
    data: XOR<HistoricoSelfiesUpdateManyMutationInput, HistoricoSelfiesUncheckedUpdateManyInput>
    /**
     * Filter which HistoricoSelfies to update
     */
    where?: HistoricoSelfiesWhereInput
    /**
     * Limit how many HistoricoSelfies to update.
     */
    limit?: number
  }

  /**
   * HistoricoSelfies updateManyAndReturn
   */
  export type HistoricoSelfiesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistoricoSelfies
     */
    select?: HistoricoSelfiesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HistoricoSelfies
     */
    omit?: HistoricoSelfiesOmit<ExtArgs> | null
    /**
     * The data used to update HistoricoSelfies.
     */
    data: XOR<HistoricoSelfiesUpdateManyMutationInput, HistoricoSelfiesUncheckedUpdateManyInput>
    /**
     * Filter which HistoricoSelfies to update
     */
    where?: HistoricoSelfiesWhereInput
    /**
     * Limit how many HistoricoSelfies to update.
     */
    limit?: number
  }

  /**
   * HistoricoSelfies upsert
   */
  export type HistoricoSelfiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistoricoSelfies
     */
    select?: HistoricoSelfiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistoricoSelfies
     */
    omit?: HistoricoSelfiesOmit<ExtArgs> | null
    /**
     * The filter to search for the HistoricoSelfies to update in case it exists.
     */
    where: HistoricoSelfiesWhereUniqueInput
    /**
     * In case the HistoricoSelfies found by the `where` argument doesn't exist, create a new HistoricoSelfies with this data.
     */
    create: XOR<HistoricoSelfiesCreateInput, HistoricoSelfiesUncheckedCreateInput>
    /**
     * In case the HistoricoSelfies was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HistoricoSelfiesUpdateInput, HistoricoSelfiesUncheckedUpdateInput>
  }

  /**
   * HistoricoSelfies delete
   */
  export type HistoricoSelfiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistoricoSelfies
     */
    select?: HistoricoSelfiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistoricoSelfies
     */
    omit?: HistoricoSelfiesOmit<ExtArgs> | null
    /**
     * Filter which HistoricoSelfies to delete.
     */
    where: HistoricoSelfiesWhereUniqueInput
  }

  /**
   * HistoricoSelfies deleteMany
   */
  export type HistoricoSelfiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HistoricoSelfies to delete
     */
    where?: HistoricoSelfiesWhereInput
    /**
     * Limit how many HistoricoSelfies to delete.
     */
    limit?: number
  }

  /**
   * HistoricoSelfies without action
   */
  export type HistoricoSelfiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistoricoSelfies
     */
    select?: HistoricoSelfiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistoricoSelfies
     */
    omit?: HistoricoSelfiesOmit<ExtArgs> | null
  }


  /**
   * Model Identidades
   */

  export type AggregateIdentidades = {
    _count: IdentidadesCountAggregateOutputType | null
    _avg: IdentidadesAvgAggregateOutputType | null
    _sum: IdentidadesSumAggregateOutputType | null
    _min: IdentidadesMinAggregateOutputType | null
    _max: IdentidadesMaxAggregateOutputType | null
  }

  export type IdentidadesAvgAggregateOutputType = {
    id: number | null
  }

  export type IdentidadesSumAggregateOutputType = {
    id: number | null
  }

  export type IdentidadesMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IdentidadesMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IdentidadesCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IdentidadesAvgAggregateInputType = {
    id?: true
  }

  export type IdentidadesSumAggregateInputType = {
    id?: true
  }

  export type IdentidadesMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IdentidadesMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IdentidadesCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IdentidadesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Identidades to aggregate.
     */
    where?: IdentidadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Identidades to fetch.
     */
    orderBy?: IdentidadesOrderByWithRelationInput | IdentidadesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IdentidadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Identidades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Identidades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Identidades
    **/
    _count?: true | IdentidadesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IdentidadesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IdentidadesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IdentidadesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IdentidadesMaxAggregateInputType
  }

  export type GetIdentidadesAggregateType<T extends IdentidadesAggregateArgs> = {
        [P in keyof T & keyof AggregateIdentidades]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIdentidades[P]>
      : GetScalarType<T[P], AggregateIdentidades[P]>
  }




  export type IdentidadesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IdentidadesWhereInput
    orderBy?: IdentidadesOrderByWithAggregationInput | IdentidadesOrderByWithAggregationInput[]
    by: IdentidadesScalarFieldEnum[] | IdentidadesScalarFieldEnum
    having?: IdentidadesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IdentidadesCountAggregateInputType | true
    _avg?: IdentidadesAvgAggregateInputType
    _sum?: IdentidadesSumAggregateInputType
    _min?: IdentidadesMinAggregateInputType
    _max?: IdentidadesMaxAggregateInputType
  }

  export type IdentidadesGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    _count: IdentidadesCountAggregateOutputType | null
    _avg: IdentidadesAvgAggregateOutputType | null
    _sum: IdentidadesSumAggregateOutputType | null
    _min: IdentidadesMinAggregateOutputType | null
    _max: IdentidadesMaxAggregateOutputType | null
  }

  type GetIdentidadesGroupByPayload<T extends IdentidadesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IdentidadesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IdentidadesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IdentidadesGroupByOutputType[P]>
            : GetScalarType<T[P], IdentidadesGroupByOutputType[P]>
        }
      >
    >


  export type IdentidadesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["identidades"]>

  export type IdentidadesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["identidades"]>

  export type IdentidadesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["identidades"]>

  export type IdentidadesSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IdentidadesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt", ExtArgs["result"]["identidades"]>

  export type $IdentidadesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Identidades"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["identidades"]>
    composites: {}
  }

  type IdentidadesGetPayload<S extends boolean | null | undefined | IdentidadesDefaultArgs> = $Result.GetResult<Prisma.$IdentidadesPayload, S>

  type IdentidadesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IdentidadesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IdentidadesCountAggregateInputType | true
    }

  export interface IdentidadesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Identidades'], meta: { name: 'Identidades' } }
    /**
     * Find zero or one Identidades that matches the filter.
     * @param {IdentidadesFindUniqueArgs} args - Arguments to find a Identidades
     * @example
     * // Get one Identidades
     * const identidades = await prisma.identidades.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IdentidadesFindUniqueArgs>(args: SelectSubset<T, IdentidadesFindUniqueArgs<ExtArgs>>): Prisma__IdentidadesClient<$Result.GetResult<Prisma.$IdentidadesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Identidades that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IdentidadesFindUniqueOrThrowArgs} args - Arguments to find a Identidades
     * @example
     * // Get one Identidades
     * const identidades = await prisma.identidades.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IdentidadesFindUniqueOrThrowArgs>(args: SelectSubset<T, IdentidadesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IdentidadesClient<$Result.GetResult<Prisma.$IdentidadesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Identidades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdentidadesFindFirstArgs} args - Arguments to find a Identidades
     * @example
     * // Get one Identidades
     * const identidades = await prisma.identidades.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IdentidadesFindFirstArgs>(args?: SelectSubset<T, IdentidadesFindFirstArgs<ExtArgs>>): Prisma__IdentidadesClient<$Result.GetResult<Prisma.$IdentidadesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Identidades that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdentidadesFindFirstOrThrowArgs} args - Arguments to find a Identidades
     * @example
     * // Get one Identidades
     * const identidades = await prisma.identidades.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IdentidadesFindFirstOrThrowArgs>(args?: SelectSubset<T, IdentidadesFindFirstOrThrowArgs<ExtArgs>>): Prisma__IdentidadesClient<$Result.GetResult<Prisma.$IdentidadesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Identidades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdentidadesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Identidades
     * const identidades = await prisma.identidades.findMany()
     * 
     * // Get first 10 Identidades
     * const identidades = await prisma.identidades.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const identidadesWithIdOnly = await prisma.identidades.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IdentidadesFindManyArgs>(args?: SelectSubset<T, IdentidadesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IdentidadesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Identidades.
     * @param {IdentidadesCreateArgs} args - Arguments to create a Identidades.
     * @example
     * // Create one Identidades
     * const Identidades = await prisma.identidades.create({
     *   data: {
     *     // ... data to create a Identidades
     *   }
     * })
     * 
     */
    create<T extends IdentidadesCreateArgs>(args: SelectSubset<T, IdentidadesCreateArgs<ExtArgs>>): Prisma__IdentidadesClient<$Result.GetResult<Prisma.$IdentidadesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Identidades.
     * @param {IdentidadesCreateManyArgs} args - Arguments to create many Identidades.
     * @example
     * // Create many Identidades
     * const identidades = await prisma.identidades.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IdentidadesCreateManyArgs>(args?: SelectSubset<T, IdentidadesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Identidades and returns the data saved in the database.
     * @param {IdentidadesCreateManyAndReturnArgs} args - Arguments to create many Identidades.
     * @example
     * // Create many Identidades
     * const identidades = await prisma.identidades.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Identidades and only return the `id`
     * const identidadesWithIdOnly = await prisma.identidades.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IdentidadesCreateManyAndReturnArgs>(args?: SelectSubset<T, IdentidadesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IdentidadesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Identidades.
     * @param {IdentidadesDeleteArgs} args - Arguments to delete one Identidades.
     * @example
     * // Delete one Identidades
     * const Identidades = await prisma.identidades.delete({
     *   where: {
     *     // ... filter to delete one Identidades
     *   }
     * })
     * 
     */
    delete<T extends IdentidadesDeleteArgs>(args: SelectSubset<T, IdentidadesDeleteArgs<ExtArgs>>): Prisma__IdentidadesClient<$Result.GetResult<Prisma.$IdentidadesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Identidades.
     * @param {IdentidadesUpdateArgs} args - Arguments to update one Identidades.
     * @example
     * // Update one Identidades
     * const identidades = await prisma.identidades.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IdentidadesUpdateArgs>(args: SelectSubset<T, IdentidadesUpdateArgs<ExtArgs>>): Prisma__IdentidadesClient<$Result.GetResult<Prisma.$IdentidadesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Identidades.
     * @param {IdentidadesDeleteManyArgs} args - Arguments to filter Identidades to delete.
     * @example
     * // Delete a few Identidades
     * const { count } = await prisma.identidades.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IdentidadesDeleteManyArgs>(args?: SelectSubset<T, IdentidadesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Identidades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdentidadesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Identidades
     * const identidades = await prisma.identidades.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IdentidadesUpdateManyArgs>(args: SelectSubset<T, IdentidadesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Identidades and returns the data updated in the database.
     * @param {IdentidadesUpdateManyAndReturnArgs} args - Arguments to update many Identidades.
     * @example
     * // Update many Identidades
     * const identidades = await prisma.identidades.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Identidades and only return the `id`
     * const identidadesWithIdOnly = await prisma.identidades.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IdentidadesUpdateManyAndReturnArgs>(args: SelectSubset<T, IdentidadesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IdentidadesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Identidades.
     * @param {IdentidadesUpsertArgs} args - Arguments to update or create a Identidades.
     * @example
     * // Update or create a Identidades
     * const identidades = await prisma.identidades.upsert({
     *   create: {
     *     // ... data to create a Identidades
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Identidades we want to update
     *   }
     * })
     */
    upsert<T extends IdentidadesUpsertArgs>(args: SelectSubset<T, IdentidadesUpsertArgs<ExtArgs>>): Prisma__IdentidadesClient<$Result.GetResult<Prisma.$IdentidadesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Identidades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdentidadesCountArgs} args - Arguments to filter Identidades to count.
     * @example
     * // Count the number of Identidades
     * const count = await prisma.identidades.count({
     *   where: {
     *     // ... the filter for the Identidades we want to count
     *   }
     * })
    **/
    count<T extends IdentidadesCountArgs>(
      args?: Subset<T, IdentidadesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IdentidadesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Identidades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdentidadesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IdentidadesAggregateArgs>(args: Subset<T, IdentidadesAggregateArgs>): Prisma.PrismaPromise<GetIdentidadesAggregateType<T>>

    /**
     * Group by Identidades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdentidadesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IdentidadesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IdentidadesGroupByArgs['orderBy'] }
        : { orderBy?: IdentidadesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IdentidadesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIdentidadesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Identidades model
   */
  readonly fields: IdentidadesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Identidades.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IdentidadesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Identidades model
   */
  interface IdentidadesFieldRefs {
    readonly id: FieldRef<"Identidades", 'Int'>
    readonly createdAt: FieldRef<"Identidades", 'DateTime'>
    readonly updatedAt: FieldRef<"Identidades", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Identidades findUnique
   */
  export type IdentidadesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Identidades
     */
    select?: IdentidadesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Identidades
     */
    omit?: IdentidadesOmit<ExtArgs> | null
    /**
     * Filter, which Identidades to fetch.
     */
    where: IdentidadesWhereUniqueInput
  }

  /**
   * Identidades findUniqueOrThrow
   */
  export type IdentidadesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Identidades
     */
    select?: IdentidadesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Identidades
     */
    omit?: IdentidadesOmit<ExtArgs> | null
    /**
     * Filter, which Identidades to fetch.
     */
    where: IdentidadesWhereUniqueInput
  }

  /**
   * Identidades findFirst
   */
  export type IdentidadesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Identidades
     */
    select?: IdentidadesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Identidades
     */
    omit?: IdentidadesOmit<ExtArgs> | null
    /**
     * Filter, which Identidades to fetch.
     */
    where?: IdentidadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Identidades to fetch.
     */
    orderBy?: IdentidadesOrderByWithRelationInput | IdentidadesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Identidades.
     */
    cursor?: IdentidadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Identidades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Identidades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Identidades.
     */
    distinct?: IdentidadesScalarFieldEnum | IdentidadesScalarFieldEnum[]
  }

  /**
   * Identidades findFirstOrThrow
   */
  export type IdentidadesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Identidades
     */
    select?: IdentidadesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Identidades
     */
    omit?: IdentidadesOmit<ExtArgs> | null
    /**
     * Filter, which Identidades to fetch.
     */
    where?: IdentidadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Identidades to fetch.
     */
    orderBy?: IdentidadesOrderByWithRelationInput | IdentidadesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Identidades.
     */
    cursor?: IdentidadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Identidades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Identidades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Identidades.
     */
    distinct?: IdentidadesScalarFieldEnum | IdentidadesScalarFieldEnum[]
  }

  /**
   * Identidades findMany
   */
  export type IdentidadesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Identidades
     */
    select?: IdentidadesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Identidades
     */
    omit?: IdentidadesOmit<ExtArgs> | null
    /**
     * Filter, which Identidades to fetch.
     */
    where?: IdentidadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Identidades to fetch.
     */
    orderBy?: IdentidadesOrderByWithRelationInput | IdentidadesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Identidades.
     */
    cursor?: IdentidadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Identidades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Identidades.
     */
    skip?: number
    distinct?: IdentidadesScalarFieldEnum | IdentidadesScalarFieldEnum[]
  }

  /**
   * Identidades create
   */
  export type IdentidadesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Identidades
     */
    select?: IdentidadesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Identidades
     */
    omit?: IdentidadesOmit<ExtArgs> | null
    /**
     * The data needed to create a Identidades.
     */
    data: XOR<IdentidadesCreateInput, IdentidadesUncheckedCreateInput>
  }

  /**
   * Identidades createMany
   */
  export type IdentidadesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Identidades.
     */
    data: IdentidadesCreateManyInput | IdentidadesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Identidades createManyAndReturn
   */
  export type IdentidadesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Identidades
     */
    select?: IdentidadesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Identidades
     */
    omit?: IdentidadesOmit<ExtArgs> | null
    /**
     * The data used to create many Identidades.
     */
    data: IdentidadesCreateManyInput | IdentidadesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Identidades update
   */
  export type IdentidadesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Identidades
     */
    select?: IdentidadesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Identidades
     */
    omit?: IdentidadesOmit<ExtArgs> | null
    /**
     * The data needed to update a Identidades.
     */
    data: XOR<IdentidadesUpdateInput, IdentidadesUncheckedUpdateInput>
    /**
     * Choose, which Identidades to update.
     */
    where: IdentidadesWhereUniqueInput
  }

  /**
   * Identidades updateMany
   */
  export type IdentidadesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Identidades.
     */
    data: XOR<IdentidadesUpdateManyMutationInput, IdentidadesUncheckedUpdateManyInput>
    /**
     * Filter which Identidades to update
     */
    where?: IdentidadesWhereInput
    /**
     * Limit how many Identidades to update.
     */
    limit?: number
  }

  /**
   * Identidades updateManyAndReturn
   */
  export type IdentidadesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Identidades
     */
    select?: IdentidadesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Identidades
     */
    omit?: IdentidadesOmit<ExtArgs> | null
    /**
     * The data used to update Identidades.
     */
    data: XOR<IdentidadesUpdateManyMutationInput, IdentidadesUncheckedUpdateManyInput>
    /**
     * Filter which Identidades to update
     */
    where?: IdentidadesWhereInput
    /**
     * Limit how many Identidades to update.
     */
    limit?: number
  }

  /**
   * Identidades upsert
   */
  export type IdentidadesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Identidades
     */
    select?: IdentidadesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Identidades
     */
    omit?: IdentidadesOmit<ExtArgs> | null
    /**
     * The filter to search for the Identidades to update in case it exists.
     */
    where: IdentidadesWhereUniqueInput
    /**
     * In case the Identidades found by the `where` argument doesn't exist, create a new Identidades with this data.
     */
    create: XOR<IdentidadesCreateInput, IdentidadesUncheckedCreateInput>
    /**
     * In case the Identidades was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IdentidadesUpdateInput, IdentidadesUncheckedUpdateInput>
  }

  /**
   * Identidades delete
   */
  export type IdentidadesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Identidades
     */
    select?: IdentidadesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Identidades
     */
    omit?: IdentidadesOmit<ExtArgs> | null
    /**
     * Filter which Identidades to delete.
     */
    where: IdentidadesWhereUniqueInput
  }

  /**
   * Identidades deleteMany
   */
  export type IdentidadesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Identidades to delete
     */
    where?: IdentidadesWhereInput
    /**
     * Limit how many Identidades to delete.
     */
    limit?: number
  }

  /**
   * Identidades without action
   */
  export type IdentidadesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Identidades
     */
    select?: IdentidadesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Identidades
     */
    omit?: IdentidadesOmit<ExtArgs> | null
  }


  /**
   * Model Indicacaos
   */

  export type AggregateIndicacaos = {
    _count: IndicacaosCountAggregateOutputType | null
    _avg: IndicacaosAvgAggregateOutputType | null
    _sum: IndicacaosSumAggregateOutputType | null
    _min: IndicacaosMinAggregateOutputType | null
    _max: IndicacaosMaxAggregateOutputType | null
  }

  export type IndicacaosAvgAggregateOutputType = {
    id: number | null
    indicanteId: number | null
    indicadoId: number | null
  }

  export type IndicacaosSumAggregateOutputType = {
    id: number | null
    indicanteId: number | null
    indicadoId: number | null
  }

  export type IndicacaosMinAggregateOutputType = {
    id: number | null
    indicanteId: number | null
    indicadoId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IndicacaosMaxAggregateOutputType = {
    id: number | null
    indicanteId: number | null
    indicadoId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IndicacaosCountAggregateOutputType = {
    id: number
    indicanteId: number
    indicadoId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IndicacaosAvgAggregateInputType = {
    id?: true
    indicanteId?: true
    indicadoId?: true
  }

  export type IndicacaosSumAggregateInputType = {
    id?: true
    indicanteId?: true
    indicadoId?: true
  }

  export type IndicacaosMinAggregateInputType = {
    id?: true
    indicanteId?: true
    indicadoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IndicacaosMaxAggregateInputType = {
    id?: true
    indicanteId?: true
    indicadoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IndicacaosCountAggregateInputType = {
    id?: true
    indicanteId?: true
    indicadoId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IndicacaosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Indicacaos to aggregate.
     */
    where?: IndicacaosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Indicacaos to fetch.
     */
    orderBy?: IndicacaosOrderByWithRelationInput | IndicacaosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IndicacaosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Indicacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Indicacaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Indicacaos
    **/
    _count?: true | IndicacaosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IndicacaosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IndicacaosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IndicacaosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IndicacaosMaxAggregateInputType
  }

  export type GetIndicacaosAggregateType<T extends IndicacaosAggregateArgs> = {
        [P in keyof T & keyof AggregateIndicacaos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIndicacaos[P]>
      : GetScalarType<T[P], AggregateIndicacaos[P]>
  }




  export type IndicacaosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IndicacaosWhereInput
    orderBy?: IndicacaosOrderByWithAggregationInput | IndicacaosOrderByWithAggregationInput[]
    by: IndicacaosScalarFieldEnum[] | IndicacaosScalarFieldEnum
    having?: IndicacaosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IndicacaosCountAggregateInputType | true
    _avg?: IndicacaosAvgAggregateInputType
    _sum?: IndicacaosSumAggregateInputType
    _min?: IndicacaosMinAggregateInputType
    _max?: IndicacaosMaxAggregateInputType
  }

  export type IndicacaosGroupByOutputType = {
    id: number
    indicanteId: number
    indicadoId: number
    createdAt: Date
    updatedAt: Date
    _count: IndicacaosCountAggregateOutputType | null
    _avg: IndicacaosAvgAggregateOutputType | null
    _sum: IndicacaosSumAggregateOutputType | null
    _min: IndicacaosMinAggregateOutputType | null
    _max: IndicacaosMaxAggregateOutputType | null
  }

  type GetIndicacaosGroupByPayload<T extends IndicacaosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IndicacaosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IndicacaosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IndicacaosGroupByOutputType[P]>
            : GetScalarType<T[P], IndicacaosGroupByOutputType[P]>
        }
      >
    >


  export type IndicacaosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    indicanteId?: boolean
    indicadoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Usuarios_Indicacaos_indicadoIdToUsuarios?: boolean | UsuariosDefaultArgs<ExtArgs>
    Usuarios_Indicacaos_indicanteIdToUsuarios?: boolean | UsuariosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["indicacaos"]>

  export type IndicacaosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    indicanteId?: boolean
    indicadoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Usuarios_Indicacaos_indicadoIdToUsuarios?: boolean | UsuariosDefaultArgs<ExtArgs>
    Usuarios_Indicacaos_indicanteIdToUsuarios?: boolean | UsuariosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["indicacaos"]>

  export type IndicacaosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    indicanteId?: boolean
    indicadoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Usuarios_Indicacaos_indicadoIdToUsuarios?: boolean | UsuariosDefaultArgs<ExtArgs>
    Usuarios_Indicacaos_indicanteIdToUsuarios?: boolean | UsuariosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["indicacaos"]>

  export type IndicacaosSelectScalar = {
    id?: boolean
    indicanteId?: boolean
    indicadoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IndicacaosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "indicanteId" | "indicadoId" | "createdAt" | "updatedAt", ExtArgs["result"]["indicacaos"]>
  export type IndicacaosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Usuarios_Indicacaos_indicadoIdToUsuarios?: boolean | UsuariosDefaultArgs<ExtArgs>
    Usuarios_Indicacaos_indicanteIdToUsuarios?: boolean | UsuariosDefaultArgs<ExtArgs>
  }
  export type IndicacaosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Usuarios_Indicacaos_indicadoIdToUsuarios?: boolean | UsuariosDefaultArgs<ExtArgs>
    Usuarios_Indicacaos_indicanteIdToUsuarios?: boolean | UsuariosDefaultArgs<ExtArgs>
  }
  export type IndicacaosIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Usuarios_Indicacaos_indicadoIdToUsuarios?: boolean | UsuariosDefaultArgs<ExtArgs>
    Usuarios_Indicacaos_indicanteIdToUsuarios?: boolean | UsuariosDefaultArgs<ExtArgs>
  }

  export type $IndicacaosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Indicacaos"
    objects: {
      Usuarios_Indicacaos_indicadoIdToUsuarios: Prisma.$UsuariosPayload<ExtArgs>
      Usuarios_Indicacaos_indicanteIdToUsuarios: Prisma.$UsuariosPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      indicanteId: number
      indicadoId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["indicacaos"]>
    composites: {}
  }

  type IndicacaosGetPayload<S extends boolean | null | undefined | IndicacaosDefaultArgs> = $Result.GetResult<Prisma.$IndicacaosPayload, S>

  type IndicacaosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IndicacaosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IndicacaosCountAggregateInputType | true
    }

  export interface IndicacaosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Indicacaos'], meta: { name: 'Indicacaos' } }
    /**
     * Find zero or one Indicacaos that matches the filter.
     * @param {IndicacaosFindUniqueArgs} args - Arguments to find a Indicacaos
     * @example
     * // Get one Indicacaos
     * const indicacaos = await prisma.indicacaos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IndicacaosFindUniqueArgs>(args: SelectSubset<T, IndicacaosFindUniqueArgs<ExtArgs>>): Prisma__IndicacaosClient<$Result.GetResult<Prisma.$IndicacaosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Indicacaos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IndicacaosFindUniqueOrThrowArgs} args - Arguments to find a Indicacaos
     * @example
     * // Get one Indicacaos
     * const indicacaos = await prisma.indicacaos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IndicacaosFindUniqueOrThrowArgs>(args: SelectSubset<T, IndicacaosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IndicacaosClient<$Result.GetResult<Prisma.$IndicacaosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Indicacaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicacaosFindFirstArgs} args - Arguments to find a Indicacaos
     * @example
     * // Get one Indicacaos
     * const indicacaos = await prisma.indicacaos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IndicacaosFindFirstArgs>(args?: SelectSubset<T, IndicacaosFindFirstArgs<ExtArgs>>): Prisma__IndicacaosClient<$Result.GetResult<Prisma.$IndicacaosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Indicacaos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicacaosFindFirstOrThrowArgs} args - Arguments to find a Indicacaos
     * @example
     * // Get one Indicacaos
     * const indicacaos = await prisma.indicacaos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IndicacaosFindFirstOrThrowArgs>(args?: SelectSubset<T, IndicacaosFindFirstOrThrowArgs<ExtArgs>>): Prisma__IndicacaosClient<$Result.GetResult<Prisma.$IndicacaosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Indicacaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicacaosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Indicacaos
     * const indicacaos = await prisma.indicacaos.findMany()
     * 
     * // Get first 10 Indicacaos
     * const indicacaos = await prisma.indicacaos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const indicacaosWithIdOnly = await prisma.indicacaos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IndicacaosFindManyArgs>(args?: SelectSubset<T, IndicacaosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicacaosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Indicacaos.
     * @param {IndicacaosCreateArgs} args - Arguments to create a Indicacaos.
     * @example
     * // Create one Indicacaos
     * const Indicacaos = await prisma.indicacaos.create({
     *   data: {
     *     // ... data to create a Indicacaos
     *   }
     * })
     * 
     */
    create<T extends IndicacaosCreateArgs>(args: SelectSubset<T, IndicacaosCreateArgs<ExtArgs>>): Prisma__IndicacaosClient<$Result.GetResult<Prisma.$IndicacaosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Indicacaos.
     * @param {IndicacaosCreateManyArgs} args - Arguments to create many Indicacaos.
     * @example
     * // Create many Indicacaos
     * const indicacaos = await prisma.indicacaos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IndicacaosCreateManyArgs>(args?: SelectSubset<T, IndicacaosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Indicacaos and returns the data saved in the database.
     * @param {IndicacaosCreateManyAndReturnArgs} args - Arguments to create many Indicacaos.
     * @example
     * // Create many Indicacaos
     * const indicacaos = await prisma.indicacaos.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Indicacaos and only return the `id`
     * const indicacaosWithIdOnly = await prisma.indicacaos.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IndicacaosCreateManyAndReturnArgs>(args?: SelectSubset<T, IndicacaosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicacaosPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Indicacaos.
     * @param {IndicacaosDeleteArgs} args - Arguments to delete one Indicacaos.
     * @example
     * // Delete one Indicacaos
     * const Indicacaos = await prisma.indicacaos.delete({
     *   where: {
     *     // ... filter to delete one Indicacaos
     *   }
     * })
     * 
     */
    delete<T extends IndicacaosDeleteArgs>(args: SelectSubset<T, IndicacaosDeleteArgs<ExtArgs>>): Prisma__IndicacaosClient<$Result.GetResult<Prisma.$IndicacaosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Indicacaos.
     * @param {IndicacaosUpdateArgs} args - Arguments to update one Indicacaos.
     * @example
     * // Update one Indicacaos
     * const indicacaos = await prisma.indicacaos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IndicacaosUpdateArgs>(args: SelectSubset<T, IndicacaosUpdateArgs<ExtArgs>>): Prisma__IndicacaosClient<$Result.GetResult<Prisma.$IndicacaosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Indicacaos.
     * @param {IndicacaosDeleteManyArgs} args - Arguments to filter Indicacaos to delete.
     * @example
     * // Delete a few Indicacaos
     * const { count } = await prisma.indicacaos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IndicacaosDeleteManyArgs>(args?: SelectSubset<T, IndicacaosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Indicacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicacaosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Indicacaos
     * const indicacaos = await prisma.indicacaos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IndicacaosUpdateManyArgs>(args: SelectSubset<T, IndicacaosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Indicacaos and returns the data updated in the database.
     * @param {IndicacaosUpdateManyAndReturnArgs} args - Arguments to update many Indicacaos.
     * @example
     * // Update many Indicacaos
     * const indicacaos = await prisma.indicacaos.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Indicacaos and only return the `id`
     * const indicacaosWithIdOnly = await prisma.indicacaos.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IndicacaosUpdateManyAndReturnArgs>(args: SelectSubset<T, IndicacaosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicacaosPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Indicacaos.
     * @param {IndicacaosUpsertArgs} args - Arguments to update or create a Indicacaos.
     * @example
     * // Update or create a Indicacaos
     * const indicacaos = await prisma.indicacaos.upsert({
     *   create: {
     *     // ... data to create a Indicacaos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Indicacaos we want to update
     *   }
     * })
     */
    upsert<T extends IndicacaosUpsertArgs>(args: SelectSubset<T, IndicacaosUpsertArgs<ExtArgs>>): Prisma__IndicacaosClient<$Result.GetResult<Prisma.$IndicacaosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Indicacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicacaosCountArgs} args - Arguments to filter Indicacaos to count.
     * @example
     * // Count the number of Indicacaos
     * const count = await prisma.indicacaos.count({
     *   where: {
     *     // ... the filter for the Indicacaos we want to count
     *   }
     * })
    **/
    count<T extends IndicacaosCountArgs>(
      args?: Subset<T, IndicacaosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IndicacaosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Indicacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicacaosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IndicacaosAggregateArgs>(args: Subset<T, IndicacaosAggregateArgs>): Prisma.PrismaPromise<GetIndicacaosAggregateType<T>>

    /**
     * Group by Indicacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicacaosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IndicacaosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IndicacaosGroupByArgs['orderBy'] }
        : { orderBy?: IndicacaosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IndicacaosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIndicacaosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Indicacaos model
   */
  readonly fields: IndicacaosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Indicacaos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IndicacaosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Usuarios_Indicacaos_indicadoIdToUsuarios<T extends UsuariosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuariosDefaultArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Usuarios_Indicacaos_indicanteIdToUsuarios<T extends UsuariosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuariosDefaultArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Indicacaos model
   */
  interface IndicacaosFieldRefs {
    readonly id: FieldRef<"Indicacaos", 'Int'>
    readonly indicanteId: FieldRef<"Indicacaos", 'Int'>
    readonly indicadoId: FieldRef<"Indicacaos", 'Int'>
    readonly createdAt: FieldRef<"Indicacaos", 'DateTime'>
    readonly updatedAt: FieldRef<"Indicacaos", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Indicacaos findUnique
   */
  export type IndicacaosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicacaos
     */
    select?: IndicacaosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Indicacaos
     */
    omit?: IndicacaosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicacaosInclude<ExtArgs> | null
    /**
     * Filter, which Indicacaos to fetch.
     */
    where: IndicacaosWhereUniqueInput
  }

  /**
   * Indicacaos findUniqueOrThrow
   */
  export type IndicacaosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicacaos
     */
    select?: IndicacaosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Indicacaos
     */
    omit?: IndicacaosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicacaosInclude<ExtArgs> | null
    /**
     * Filter, which Indicacaos to fetch.
     */
    where: IndicacaosWhereUniqueInput
  }

  /**
   * Indicacaos findFirst
   */
  export type IndicacaosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicacaos
     */
    select?: IndicacaosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Indicacaos
     */
    omit?: IndicacaosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicacaosInclude<ExtArgs> | null
    /**
     * Filter, which Indicacaos to fetch.
     */
    where?: IndicacaosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Indicacaos to fetch.
     */
    orderBy?: IndicacaosOrderByWithRelationInput | IndicacaosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Indicacaos.
     */
    cursor?: IndicacaosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Indicacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Indicacaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Indicacaos.
     */
    distinct?: IndicacaosScalarFieldEnum | IndicacaosScalarFieldEnum[]
  }

  /**
   * Indicacaos findFirstOrThrow
   */
  export type IndicacaosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicacaos
     */
    select?: IndicacaosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Indicacaos
     */
    omit?: IndicacaosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicacaosInclude<ExtArgs> | null
    /**
     * Filter, which Indicacaos to fetch.
     */
    where?: IndicacaosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Indicacaos to fetch.
     */
    orderBy?: IndicacaosOrderByWithRelationInput | IndicacaosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Indicacaos.
     */
    cursor?: IndicacaosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Indicacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Indicacaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Indicacaos.
     */
    distinct?: IndicacaosScalarFieldEnum | IndicacaosScalarFieldEnum[]
  }

  /**
   * Indicacaos findMany
   */
  export type IndicacaosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicacaos
     */
    select?: IndicacaosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Indicacaos
     */
    omit?: IndicacaosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicacaosInclude<ExtArgs> | null
    /**
     * Filter, which Indicacaos to fetch.
     */
    where?: IndicacaosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Indicacaos to fetch.
     */
    orderBy?: IndicacaosOrderByWithRelationInput | IndicacaosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Indicacaos.
     */
    cursor?: IndicacaosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Indicacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Indicacaos.
     */
    skip?: number
    distinct?: IndicacaosScalarFieldEnum | IndicacaosScalarFieldEnum[]
  }

  /**
   * Indicacaos create
   */
  export type IndicacaosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicacaos
     */
    select?: IndicacaosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Indicacaos
     */
    omit?: IndicacaosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicacaosInclude<ExtArgs> | null
    /**
     * The data needed to create a Indicacaos.
     */
    data: XOR<IndicacaosCreateInput, IndicacaosUncheckedCreateInput>
  }

  /**
   * Indicacaos createMany
   */
  export type IndicacaosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Indicacaos.
     */
    data: IndicacaosCreateManyInput | IndicacaosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Indicacaos createManyAndReturn
   */
  export type IndicacaosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicacaos
     */
    select?: IndicacaosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Indicacaos
     */
    omit?: IndicacaosOmit<ExtArgs> | null
    /**
     * The data used to create many Indicacaos.
     */
    data: IndicacaosCreateManyInput | IndicacaosCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicacaosIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Indicacaos update
   */
  export type IndicacaosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicacaos
     */
    select?: IndicacaosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Indicacaos
     */
    omit?: IndicacaosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicacaosInclude<ExtArgs> | null
    /**
     * The data needed to update a Indicacaos.
     */
    data: XOR<IndicacaosUpdateInput, IndicacaosUncheckedUpdateInput>
    /**
     * Choose, which Indicacaos to update.
     */
    where: IndicacaosWhereUniqueInput
  }

  /**
   * Indicacaos updateMany
   */
  export type IndicacaosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Indicacaos.
     */
    data: XOR<IndicacaosUpdateManyMutationInput, IndicacaosUncheckedUpdateManyInput>
    /**
     * Filter which Indicacaos to update
     */
    where?: IndicacaosWhereInput
    /**
     * Limit how many Indicacaos to update.
     */
    limit?: number
  }

  /**
   * Indicacaos updateManyAndReturn
   */
  export type IndicacaosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicacaos
     */
    select?: IndicacaosSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Indicacaos
     */
    omit?: IndicacaosOmit<ExtArgs> | null
    /**
     * The data used to update Indicacaos.
     */
    data: XOR<IndicacaosUpdateManyMutationInput, IndicacaosUncheckedUpdateManyInput>
    /**
     * Filter which Indicacaos to update
     */
    where?: IndicacaosWhereInput
    /**
     * Limit how many Indicacaos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicacaosIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Indicacaos upsert
   */
  export type IndicacaosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicacaos
     */
    select?: IndicacaosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Indicacaos
     */
    omit?: IndicacaosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicacaosInclude<ExtArgs> | null
    /**
     * The filter to search for the Indicacaos to update in case it exists.
     */
    where: IndicacaosWhereUniqueInput
    /**
     * In case the Indicacaos found by the `where` argument doesn't exist, create a new Indicacaos with this data.
     */
    create: XOR<IndicacaosCreateInput, IndicacaosUncheckedCreateInput>
    /**
     * In case the Indicacaos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IndicacaosUpdateInput, IndicacaosUncheckedUpdateInput>
  }

  /**
   * Indicacaos delete
   */
  export type IndicacaosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicacaos
     */
    select?: IndicacaosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Indicacaos
     */
    omit?: IndicacaosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicacaosInclude<ExtArgs> | null
    /**
     * Filter which Indicacaos to delete.
     */
    where: IndicacaosWhereUniqueInput
  }

  /**
   * Indicacaos deleteMany
   */
  export type IndicacaosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Indicacaos to delete
     */
    where?: IndicacaosWhereInput
    /**
     * Limit how many Indicacaos to delete.
     */
    limit?: number
  }

  /**
   * Indicacaos without action
   */
  export type IndicacaosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicacaos
     */
    select?: IndicacaosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Indicacaos
     */
    omit?: IndicacaosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicacaosInclude<ExtArgs> | null
  }


  /**
   * Model LogAcessos
   */

  export type AggregateLogAcessos = {
    _count: LogAcessosCountAggregateOutputType | null
    _avg: LogAcessosAvgAggregateOutputType | null
    _sum: LogAcessosSumAggregateOutputType | null
    _min: LogAcessosMinAggregateOutputType | null
    _max: LogAcessosMaxAggregateOutputType | null
  }

  export type LogAcessosAvgAggregateOutputType = {
    id: number | null
    usuario_id: number | null
  }

  export type LogAcessosSumAggregateOutputType = {
    id: number | null
    usuario_id: number | null
  }

  export type LogAcessosMinAggregateOutputType = {
    id: number | null
    usuario_id: number | null
    tipo_usuario: $Enums.enum_LogAcessos_tipo_usuario | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LogAcessosMaxAggregateOutputType = {
    id: number | null
    usuario_id: number | null
    tipo_usuario: $Enums.enum_LogAcessos_tipo_usuario | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LogAcessosCountAggregateOutputType = {
    id: number
    usuario_id: number
    tipo_usuario: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LogAcessosAvgAggregateInputType = {
    id?: true
    usuario_id?: true
  }

  export type LogAcessosSumAggregateInputType = {
    id?: true
    usuario_id?: true
  }

  export type LogAcessosMinAggregateInputType = {
    id?: true
    usuario_id?: true
    tipo_usuario?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LogAcessosMaxAggregateInputType = {
    id?: true
    usuario_id?: true
    tipo_usuario?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LogAcessosCountAggregateInputType = {
    id?: true
    usuario_id?: true
    tipo_usuario?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LogAcessosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogAcessos to aggregate.
     */
    where?: LogAcessosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogAcessos to fetch.
     */
    orderBy?: LogAcessosOrderByWithRelationInput | LogAcessosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogAcessosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogAcessos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogAcessos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LogAcessos
    **/
    _count?: true | LogAcessosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LogAcessosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LogAcessosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogAcessosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogAcessosMaxAggregateInputType
  }

  export type GetLogAcessosAggregateType<T extends LogAcessosAggregateArgs> = {
        [P in keyof T & keyof AggregateLogAcessos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogAcessos[P]>
      : GetScalarType<T[P], AggregateLogAcessos[P]>
  }




  export type LogAcessosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogAcessosWhereInput
    orderBy?: LogAcessosOrderByWithAggregationInput | LogAcessosOrderByWithAggregationInput[]
    by: LogAcessosScalarFieldEnum[] | LogAcessosScalarFieldEnum
    having?: LogAcessosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogAcessosCountAggregateInputType | true
    _avg?: LogAcessosAvgAggregateInputType
    _sum?: LogAcessosSumAggregateInputType
    _min?: LogAcessosMinAggregateInputType
    _max?: LogAcessosMaxAggregateInputType
  }

  export type LogAcessosGroupByOutputType = {
    id: number
    usuario_id: number
    tipo_usuario: $Enums.enum_LogAcessos_tipo_usuario | null
    createdAt: Date
    updatedAt: Date
    _count: LogAcessosCountAggregateOutputType | null
    _avg: LogAcessosAvgAggregateOutputType | null
    _sum: LogAcessosSumAggregateOutputType | null
    _min: LogAcessosMinAggregateOutputType | null
    _max: LogAcessosMaxAggregateOutputType | null
  }

  type GetLogAcessosGroupByPayload<T extends LogAcessosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogAcessosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogAcessosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogAcessosGroupByOutputType[P]>
            : GetScalarType<T[P], LogAcessosGroupByOutputType[P]>
        }
      >
    >


  export type LogAcessosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    tipo_usuario?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["logAcessos"]>

  export type LogAcessosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    tipo_usuario?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["logAcessos"]>

  export type LogAcessosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    tipo_usuario?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["logAcessos"]>

  export type LogAcessosSelectScalar = {
    id?: boolean
    usuario_id?: boolean
    tipo_usuario?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LogAcessosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "usuario_id" | "tipo_usuario" | "createdAt" | "updatedAt", ExtArgs["result"]["logAcessos"]>

  export type $LogAcessosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LogAcessos"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      usuario_id: number
      tipo_usuario: $Enums.enum_LogAcessos_tipo_usuario | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["logAcessos"]>
    composites: {}
  }

  type LogAcessosGetPayload<S extends boolean | null | undefined | LogAcessosDefaultArgs> = $Result.GetResult<Prisma.$LogAcessosPayload, S>

  type LogAcessosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LogAcessosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LogAcessosCountAggregateInputType | true
    }

  export interface LogAcessosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LogAcessos'], meta: { name: 'LogAcessos' } }
    /**
     * Find zero or one LogAcessos that matches the filter.
     * @param {LogAcessosFindUniqueArgs} args - Arguments to find a LogAcessos
     * @example
     * // Get one LogAcessos
     * const logAcessos = await prisma.logAcessos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LogAcessosFindUniqueArgs>(args: SelectSubset<T, LogAcessosFindUniqueArgs<ExtArgs>>): Prisma__LogAcessosClient<$Result.GetResult<Prisma.$LogAcessosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LogAcessos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LogAcessosFindUniqueOrThrowArgs} args - Arguments to find a LogAcessos
     * @example
     * // Get one LogAcessos
     * const logAcessos = await prisma.logAcessos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LogAcessosFindUniqueOrThrowArgs>(args: SelectSubset<T, LogAcessosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LogAcessosClient<$Result.GetResult<Prisma.$LogAcessosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LogAcessos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogAcessosFindFirstArgs} args - Arguments to find a LogAcessos
     * @example
     * // Get one LogAcessos
     * const logAcessos = await prisma.logAcessos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LogAcessosFindFirstArgs>(args?: SelectSubset<T, LogAcessosFindFirstArgs<ExtArgs>>): Prisma__LogAcessosClient<$Result.GetResult<Prisma.$LogAcessosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LogAcessos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogAcessosFindFirstOrThrowArgs} args - Arguments to find a LogAcessos
     * @example
     * // Get one LogAcessos
     * const logAcessos = await prisma.logAcessos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LogAcessosFindFirstOrThrowArgs>(args?: SelectSubset<T, LogAcessosFindFirstOrThrowArgs<ExtArgs>>): Prisma__LogAcessosClient<$Result.GetResult<Prisma.$LogAcessosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LogAcessos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogAcessosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LogAcessos
     * const logAcessos = await prisma.logAcessos.findMany()
     * 
     * // Get first 10 LogAcessos
     * const logAcessos = await prisma.logAcessos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logAcessosWithIdOnly = await prisma.logAcessos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LogAcessosFindManyArgs>(args?: SelectSubset<T, LogAcessosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogAcessosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LogAcessos.
     * @param {LogAcessosCreateArgs} args - Arguments to create a LogAcessos.
     * @example
     * // Create one LogAcessos
     * const LogAcessos = await prisma.logAcessos.create({
     *   data: {
     *     // ... data to create a LogAcessos
     *   }
     * })
     * 
     */
    create<T extends LogAcessosCreateArgs>(args: SelectSubset<T, LogAcessosCreateArgs<ExtArgs>>): Prisma__LogAcessosClient<$Result.GetResult<Prisma.$LogAcessosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LogAcessos.
     * @param {LogAcessosCreateManyArgs} args - Arguments to create many LogAcessos.
     * @example
     * // Create many LogAcessos
     * const logAcessos = await prisma.logAcessos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LogAcessosCreateManyArgs>(args?: SelectSubset<T, LogAcessosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LogAcessos and returns the data saved in the database.
     * @param {LogAcessosCreateManyAndReturnArgs} args - Arguments to create many LogAcessos.
     * @example
     * // Create many LogAcessos
     * const logAcessos = await prisma.logAcessos.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LogAcessos and only return the `id`
     * const logAcessosWithIdOnly = await prisma.logAcessos.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LogAcessosCreateManyAndReturnArgs>(args?: SelectSubset<T, LogAcessosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogAcessosPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LogAcessos.
     * @param {LogAcessosDeleteArgs} args - Arguments to delete one LogAcessos.
     * @example
     * // Delete one LogAcessos
     * const LogAcessos = await prisma.logAcessos.delete({
     *   where: {
     *     // ... filter to delete one LogAcessos
     *   }
     * })
     * 
     */
    delete<T extends LogAcessosDeleteArgs>(args: SelectSubset<T, LogAcessosDeleteArgs<ExtArgs>>): Prisma__LogAcessosClient<$Result.GetResult<Prisma.$LogAcessosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LogAcessos.
     * @param {LogAcessosUpdateArgs} args - Arguments to update one LogAcessos.
     * @example
     * // Update one LogAcessos
     * const logAcessos = await prisma.logAcessos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LogAcessosUpdateArgs>(args: SelectSubset<T, LogAcessosUpdateArgs<ExtArgs>>): Prisma__LogAcessosClient<$Result.GetResult<Prisma.$LogAcessosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LogAcessos.
     * @param {LogAcessosDeleteManyArgs} args - Arguments to filter LogAcessos to delete.
     * @example
     * // Delete a few LogAcessos
     * const { count } = await prisma.logAcessos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LogAcessosDeleteManyArgs>(args?: SelectSubset<T, LogAcessosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LogAcessos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogAcessosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LogAcessos
     * const logAcessos = await prisma.logAcessos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LogAcessosUpdateManyArgs>(args: SelectSubset<T, LogAcessosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LogAcessos and returns the data updated in the database.
     * @param {LogAcessosUpdateManyAndReturnArgs} args - Arguments to update many LogAcessos.
     * @example
     * // Update many LogAcessos
     * const logAcessos = await prisma.logAcessos.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LogAcessos and only return the `id`
     * const logAcessosWithIdOnly = await prisma.logAcessos.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LogAcessosUpdateManyAndReturnArgs>(args: SelectSubset<T, LogAcessosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogAcessosPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LogAcessos.
     * @param {LogAcessosUpsertArgs} args - Arguments to update or create a LogAcessos.
     * @example
     * // Update or create a LogAcessos
     * const logAcessos = await prisma.logAcessos.upsert({
     *   create: {
     *     // ... data to create a LogAcessos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LogAcessos we want to update
     *   }
     * })
     */
    upsert<T extends LogAcessosUpsertArgs>(args: SelectSubset<T, LogAcessosUpsertArgs<ExtArgs>>): Prisma__LogAcessosClient<$Result.GetResult<Prisma.$LogAcessosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LogAcessos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogAcessosCountArgs} args - Arguments to filter LogAcessos to count.
     * @example
     * // Count the number of LogAcessos
     * const count = await prisma.logAcessos.count({
     *   where: {
     *     // ... the filter for the LogAcessos we want to count
     *   }
     * })
    **/
    count<T extends LogAcessosCountArgs>(
      args?: Subset<T, LogAcessosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogAcessosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LogAcessos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogAcessosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogAcessosAggregateArgs>(args: Subset<T, LogAcessosAggregateArgs>): Prisma.PrismaPromise<GetLogAcessosAggregateType<T>>

    /**
     * Group by LogAcessos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogAcessosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogAcessosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogAcessosGroupByArgs['orderBy'] }
        : { orderBy?: LogAcessosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogAcessosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogAcessosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LogAcessos model
   */
  readonly fields: LogAcessosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LogAcessos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogAcessosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LogAcessos model
   */
  interface LogAcessosFieldRefs {
    readonly id: FieldRef<"LogAcessos", 'Int'>
    readonly usuario_id: FieldRef<"LogAcessos", 'Int'>
    readonly tipo_usuario: FieldRef<"LogAcessos", 'enum_LogAcessos_tipo_usuario'>
    readonly createdAt: FieldRef<"LogAcessos", 'DateTime'>
    readonly updatedAt: FieldRef<"LogAcessos", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LogAcessos findUnique
   */
  export type LogAcessosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogAcessos
     */
    select?: LogAcessosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LogAcessos
     */
    omit?: LogAcessosOmit<ExtArgs> | null
    /**
     * Filter, which LogAcessos to fetch.
     */
    where: LogAcessosWhereUniqueInput
  }

  /**
   * LogAcessos findUniqueOrThrow
   */
  export type LogAcessosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogAcessos
     */
    select?: LogAcessosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LogAcessos
     */
    omit?: LogAcessosOmit<ExtArgs> | null
    /**
     * Filter, which LogAcessos to fetch.
     */
    where: LogAcessosWhereUniqueInput
  }

  /**
   * LogAcessos findFirst
   */
  export type LogAcessosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogAcessos
     */
    select?: LogAcessosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LogAcessos
     */
    omit?: LogAcessosOmit<ExtArgs> | null
    /**
     * Filter, which LogAcessos to fetch.
     */
    where?: LogAcessosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogAcessos to fetch.
     */
    orderBy?: LogAcessosOrderByWithRelationInput | LogAcessosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogAcessos.
     */
    cursor?: LogAcessosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogAcessos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogAcessos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogAcessos.
     */
    distinct?: LogAcessosScalarFieldEnum | LogAcessosScalarFieldEnum[]
  }

  /**
   * LogAcessos findFirstOrThrow
   */
  export type LogAcessosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogAcessos
     */
    select?: LogAcessosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LogAcessos
     */
    omit?: LogAcessosOmit<ExtArgs> | null
    /**
     * Filter, which LogAcessos to fetch.
     */
    where?: LogAcessosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogAcessos to fetch.
     */
    orderBy?: LogAcessosOrderByWithRelationInput | LogAcessosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogAcessos.
     */
    cursor?: LogAcessosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogAcessos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogAcessos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogAcessos.
     */
    distinct?: LogAcessosScalarFieldEnum | LogAcessosScalarFieldEnum[]
  }

  /**
   * LogAcessos findMany
   */
  export type LogAcessosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogAcessos
     */
    select?: LogAcessosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LogAcessos
     */
    omit?: LogAcessosOmit<ExtArgs> | null
    /**
     * Filter, which LogAcessos to fetch.
     */
    where?: LogAcessosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogAcessos to fetch.
     */
    orderBy?: LogAcessosOrderByWithRelationInput | LogAcessosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LogAcessos.
     */
    cursor?: LogAcessosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogAcessos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogAcessos.
     */
    skip?: number
    distinct?: LogAcessosScalarFieldEnum | LogAcessosScalarFieldEnum[]
  }

  /**
   * LogAcessos create
   */
  export type LogAcessosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogAcessos
     */
    select?: LogAcessosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LogAcessos
     */
    omit?: LogAcessosOmit<ExtArgs> | null
    /**
     * The data needed to create a LogAcessos.
     */
    data: XOR<LogAcessosCreateInput, LogAcessosUncheckedCreateInput>
  }

  /**
   * LogAcessos createMany
   */
  export type LogAcessosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LogAcessos.
     */
    data: LogAcessosCreateManyInput | LogAcessosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LogAcessos createManyAndReturn
   */
  export type LogAcessosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogAcessos
     */
    select?: LogAcessosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LogAcessos
     */
    omit?: LogAcessosOmit<ExtArgs> | null
    /**
     * The data used to create many LogAcessos.
     */
    data: LogAcessosCreateManyInput | LogAcessosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LogAcessos update
   */
  export type LogAcessosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogAcessos
     */
    select?: LogAcessosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LogAcessos
     */
    omit?: LogAcessosOmit<ExtArgs> | null
    /**
     * The data needed to update a LogAcessos.
     */
    data: XOR<LogAcessosUpdateInput, LogAcessosUncheckedUpdateInput>
    /**
     * Choose, which LogAcessos to update.
     */
    where: LogAcessosWhereUniqueInput
  }

  /**
   * LogAcessos updateMany
   */
  export type LogAcessosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LogAcessos.
     */
    data: XOR<LogAcessosUpdateManyMutationInput, LogAcessosUncheckedUpdateManyInput>
    /**
     * Filter which LogAcessos to update
     */
    where?: LogAcessosWhereInput
    /**
     * Limit how many LogAcessos to update.
     */
    limit?: number
  }

  /**
   * LogAcessos updateManyAndReturn
   */
  export type LogAcessosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogAcessos
     */
    select?: LogAcessosSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LogAcessos
     */
    omit?: LogAcessosOmit<ExtArgs> | null
    /**
     * The data used to update LogAcessos.
     */
    data: XOR<LogAcessosUpdateManyMutationInput, LogAcessosUncheckedUpdateManyInput>
    /**
     * Filter which LogAcessos to update
     */
    where?: LogAcessosWhereInput
    /**
     * Limit how many LogAcessos to update.
     */
    limit?: number
  }

  /**
   * LogAcessos upsert
   */
  export type LogAcessosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogAcessos
     */
    select?: LogAcessosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LogAcessos
     */
    omit?: LogAcessosOmit<ExtArgs> | null
    /**
     * The filter to search for the LogAcessos to update in case it exists.
     */
    where: LogAcessosWhereUniqueInput
    /**
     * In case the LogAcessos found by the `where` argument doesn't exist, create a new LogAcessos with this data.
     */
    create: XOR<LogAcessosCreateInput, LogAcessosUncheckedCreateInput>
    /**
     * In case the LogAcessos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogAcessosUpdateInput, LogAcessosUncheckedUpdateInput>
  }

  /**
   * LogAcessos delete
   */
  export type LogAcessosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogAcessos
     */
    select?: LogAcessosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LogAcessos
     */
    omit?: LogAcessosOmit<ExtArgs> | null
    /**
     * Filter which LogAcessos to delete.
     */
    where: LogAcessosWhereUniqueInput
  }

  /**
   * LogAcessos deleteMany
   */
  export type LogAcessosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogAcessos to delete
     */
    where?: LogAcessosWhereInput
    /**
     * Limit how many LogAcessos to delete.
     */
    limit?: number
  }

  /**
   * LogAcessos without action
   */
  export type LogAcessosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogAcessos
     */
    select?: LogAcessosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LogAcessos
     */
    omit?: LogAcessosOmit<ExtArgs> | null
  }


  /**
   * Model MensagemSuportes
   */

  export type AggregateMensagemSuportes = {
    _count: MensagemSuportesCountAggregateOutputType | null
    _avg: MensagemSuportesAvgAggregateOutputType | null
    _sum: MensagemSuportesSumAggregateOutputType | null
    _min: MensagemSuportesMinAggregateOutputType | null
    _max: MensagemSuportesMaxAggregateOutputType | null
  }

  export type MensagemSuportesAvgAggregateOutputType = {
    id: number | null
    usuario_id: number | null
  }

  export type MensagemSuportesSumAggregateOutputType = {
    id: number | null
    usuario_id: number | null
  }

  export type MensagemSuportesMinAggregateOutputType = {
    id: number | null
    usuario_id: number | null
    tipo_usuario: $Enums.enum_MensagemSuportes_tipo_usuario | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MensagemSuportesMaxAggregateOutputType = {
    id: number | null
    usuario_id: number | null
    tipo_usuario: $Enums.enum_MensagemSuportes_tipo_usuario | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MensagemSuportesCountAggregateOutputType = {
    id: number
    usuario_id: number
    tipo_usuario: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MensagemSuportesAvgAggregateInputType = {
    id?: true
    usuario_id?: true
  }

  export type MensagemSuportesSumAggregateInputType = {
    id?: true
    usuario_id?: true
  }

  export type MensagemSuportesMinAggregateInputType = {
    id?: true
    usuario_id?: true
    tipo_usuario?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MensagemSuportesMaxAggregateInputType = {
    id?: true
    usuario_id?: true
    tipo_usuario?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MensagemSuportesCountAggregateInputType = {
    id?: true
    usuario_id?: true
    tipo_usuario?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MensagemSuportesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MensagemSuportes to aggregate.
     */
    where?: MensagemSuportesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MensagemSuportes to fetch.
     */
    orderBy?: MensagemSuportesOrderByWithRelationInput | MensagemSuportesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MensagemSuportesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MensagemSuportes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MensagemSuportes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MensagemSuportes
    **/
    _count?: true | MensagemSuportesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MensagemSuportesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MensagemSuportesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MensagemSuportesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MensagemSuportesMaxAggregateInputType
  }

  export type GetMensagemSuportesAggregateType<T extends MensagemSuportesAggregateArgs> = {
        [P in keyof T & keyof AggregateMensagemSuportes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMensagemSuportes[P]>
      : GetScalarType<T[P], AggregateMensagemSuportes[P]>
  }




  export type MensagemSuportesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MensagemSuportesWhereInput
    orderBy?: MensagemSuportesOrderByWithAggregationInput | MensagemSuportesOrderByWithAggregationInput[]
    by: MensagemSuportesScalarFieldEnum[] | MensagemSuportesScalarFieldEnum
    having?: MensagemSuportesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MensagemSuportesCountAggregateInputType | true
    _avg?: MensagemSuportesAvgAggregateInputType
    _sum?: MensagemSuportesSumAggregateInputType
    _min?: MensagemSuportesMinAggregateInputType
    _max?: MensagemSuportesMaxAggregateInputType
  }

  export type MensagemSuportesGroupByOutputType = {
    id: number
    usuario_id: number
    tipo_usuario: $Enums.enum_MensagemSuportes_tipo_usuario | null
    createdAt: Date
    updatedAt: Date
    _count: MensagemSuportesCountAggregateOutputType | null
    _avg: MensagemSuportesAvgAggregateOutputType | null
    _sum: MensagemSuportesSumAggregateOutputType | null
    _min: MensagemSuportesMinAggregateOutputType | null
    _max: MensagemSuportesMaxAggregateOutputType | null
  }

  type GetMensagemSuportesGroupByPayload<T extends MensagemSuportesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MensagemSuportesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MensagemSuportesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MensagemSuportesGroupByOutputType[P]>
            : GetScalarType<T[P], MensagemSuportesGroupByOutputType[P]>
        }
      >
    >


  export type MensagemSuportesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    tipo_usuario?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["mensagemSuportes"]>

  export type MensagemSuportesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    tipo_usuario?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["mensagemSuportes"]>

  export type MensagemSuportesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    tipo_usuario?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["mensagemSuportes"]>

  export type MensagemSuportesSelectScalar = {
    id?: boolean
    usuario_id?: boolean
    tipo_usuario?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MensagemSuportesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "usuario_id" | "tipo_usuario" | "createdAt" | "updatedAt", ExtArgs["result"]["mensagemSuportes"]>

  export type $MensagemSuportesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MensagemSuportes"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      usuario_id: number
      tipo_usuario: $Enums.enum_MensagemSuportes_tipo_usuario | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["mensagemSuportes"]>
    composites: {}
  }

  type MensagemSuportesGetPayload<S extends boolean | null | undefined | MensagemSuportesDefaultArgs> = $Result.GetResult<Prisma.$MensagemSuportesPayload, S>

  type MensagemSuportesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MensagemSuportesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MensagemSuportesCountAggregateInputType | true
    }

  export interface MensagemSuportesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MensagemSuportes'], meta: { name: 'MensagemSuportes' } }
    /**
     * Find zero or one MensagemSuportes that matches the filter.
     * @param {MensagemSuportesFindUniqueArgs} args - Arguments to find a MensagemSuportes
     * @example
     * // Get one MensagemSuportes
     * const mensagemSuportes = await prisma.mensagemSuportes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MensagemSuportesFindUniqueArgs>(args: SelectSubset<T, MensagemSuportesFindUniqueArgs<ExtArgs>>): Prisma__MensagemSuportesClient<$Result.GetResult<Prisma.$MensagemSuportesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MensagemSuportes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MensagemSuportesFindUniqueOrThrowArgs} args - Arguments to find a MensagemSuportes
     * @example
     * // Get one MensagemSuportes
     * const mensagemSuportes = await prisma.mensagemSuportes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MensagemSuportesFindUniqueOrThrowArgs>(args: SelectSubset<T, MensagemSuportesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MensagemSuportesClient<$Result.GetResult<Prisma.$MensagemSuportesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MensagemSuportes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MensagemSuportesFindFirstArgs} args - Arguments to find a MensagemSuportes
     * @example
     * // Get one MensagemSuportes
     * const mensagemSuportes = await prisma.mensagemSuportes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MensagemSuportesFindFirstArgs>(args?: SelectSubset<T, MensagemSuportesFindFirstArgs<ExtArgs>>): Prisma__MensagemSuportesClient<$Result.GetResult<Prisma.$MensagemSuportesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MensagemSuportes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MensagemSuportesFindFirstOrThrowArgs} args - Arguments to find a MensagemSuportes
     * @example
     * // Get one MensagemSuportes
     * const mensagemSuportes = await prisma.mensagemSuportes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MensagemSuportesFindFirstOrThrowArgs>(args?: SelectSubset<T, MensagemSuportesFindFirstOrThrowArgs<ExtArgs>>): Prisma__MensagemSuportesClient<$Result.GetResult<Prisma.$MensagemSuportesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MensagemSuportes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MensagemSuportesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MensagemSuportes
     * const mensagemSuportes = await prisma.mensagemSuportes.findMany()
     * 
     * // Get first 10 MensagemSuportes
     * const mensagemSuportes = await prisma.mensagemSuportes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mensagemSuportesWithIdOnly = await prisma.mensagemSuportes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MensagemSuportesFindManyArgs>(args?: SelectSubset<T, MensagemSuportesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MensagemSuportesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MensagemSuportes.
     * @param {MensagemSuportesCreateArgs} args - Arguments to create a MensagemSuportes.
     * @example
     * // Create one MensagemSuportes
     * const MensagemSuportes = await prisma.mensagemSuportes.create({
     *   data: {
     *     // ... data to create a MensagemSuportes
     *   }
     * })
     * 
     */
    create<T extends MensagemSuportesCreateArgs>(args: SelectSubset<T, MensagemSuportesCreateArgs<ExtArgs>>): Prisma__MensagemSuportesClient<$Result.GetResult<Prisma.$MensagemSuportesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MensagemSuportes.
     * @param {MensagemSuportesCreateManyArgs} args - Arguments to create many MensagemSuportes.
     * @example
     * // Create many MensagemSuportes
     * const mensagemSuportes = await prisma.mensagemSuportes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MensagemSuportesCreateManyArgs>(args?: SelectSubset<T, MensagemSuportesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MensagemSuportes and returns the data saved in the database.
     * @param {MensagemSuportesCreateManyAndReturnArgs} args - Arguments to create many MensagemSuportes.
     * @example
     * // Create many MensagemSuportes
     * const mensagemSuportes = await prisma.mensagemSuportes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MensagemSuportes and only return the `id`
     * const mensagemSuportesWithIdOnly = await prisma.mensagemSuportes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MensagemSuportesCreateManyAndReturnArgs>(args?: SelectSubset<T, MensagemSuportesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MensagemSuportesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MensagemSuportes.
     * @param {MensagemSuportesDeleteArgs} args - Arguments to delete one MensagemSuportes.
     * @example
     * // Delete one MensagemSuportes
     * const MensagemSuportes = await prisma.mensagemSuportes.delete({
     *   where: {
     *     // ... filter to delete one MensagemSuportes
     *   }
     * })
     * 
     */
    delete<T extends MensagemSuportesDeleteArgs>(args: SelectSubset<T, MensagemSuportesDeleteArgs<ExtArgs>>): Prisma__MensagemSuportesClient<$Result.GetResult<Prisma.$MensagemSuportesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MensagemSuportes.
     * @param {MensagemSuportesUpdateArgs} args - Arguments to update one MensagemSuportes.
     * @example
     * // Update one MensagemSuportes
     * const mensagemSuportes = await prisma.mensagemSuportes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MensagemSuportesUpdateArgs>(args: SelectSubset<T, MensagemSuportesUpdateArgs<ExtArgs>>): Prisma__MensagemSuportesClient<$Result.GetResult<Prisma.$MensagemSuportesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MensagemSuportes.
     * @param {MensagemSuportesDeleteManyArgs} args - Arguments to filter MensagemSuportes to delete.
     * @example
     * // Delete a few MensagemSuportes
     * const { count } = await prisma.mensagemSuportes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MensagemSuportesDeleteManyArgs>(args?: SelectSubset<T, MensagemSuportesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MensagemSuportes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MensagemSuportesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MensagemSuportes
     * const mensagemSuportes = await prisma.mensagemSuportes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MensagemSuportesUpdateManyArgs>(args: SelectSubset<T, MensagemSuportesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MensagemSuportes and returns the data updated in the database.
     * @param {MensagemSuportesUpdateManyAndReturnArgs} args - Arguments to update many MensagemSuportes.
     * @example
     * // Update many MensagemSuportes
     * const mensagemSuportes = await prisma.mensagemSuportes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MensagemSuportes and only return the `id`
     * const mensagemSuportesWithIdOnly = await prisma.mensagemSuportes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MensagemSuportesUpdateManyAndReturnArgs>(args: SelectSubset<T, MensagemSuportesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MensagemSuportesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MensagemSuportes.
     * @param {MensagemSuportesUpsertArgs} args - Arguments to update or create a MensagemSuportes.
     * @example
     * // Update or create a MensagemSuportes
     * const mensagemSuportes = await prisma.mensagemSuportes.upsert({
     *   create: {
     *     // ... data to create a MensagemSuportes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MensagemSuportes we want to update
     *   }
     * })
     */
    upsert<T extends MensagemSuportesUpsertArgs>(args: SelectSubset<T, MensagemSuportesUpsertArgs<ExtArgs>>): Prisma__MensagemSuportesClient<$Result.GetResult<Prisma.$MensagemSuportesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MensagemSuportes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MensagemSuportesCountArgs} args - Arguments to filter MensagemSuportes to count.
     * @example
     * // Count the number of MensagemSuportes
     * const count = await prisma.mensagemSuportes.count({
     *   where: {
     *     // ... the filter for the MensagemSuportes we want to count
     *   }
     * })
    **/
    count<T extends MensagemSuportesCountArgs>(
      args?: Subset<T, MensagemSuportesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MensagemSuportesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MensagemSuportes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MensagemSuportesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MensagemSuportesAggregateArgs>(args: Subset<T, MensagemSuportesAggregateArgs>): Prisma.PrismaPromise<GetMensagemSuportesAggregateType<T>>

    /**
     * Group by MensagemSuportes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MensagemSuportesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MensagemSuportesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MensagemSuportesGroupByArgs['orderBy'] }
        : { orderBy?: MensagemSuportesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MensagemSuportesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMensagemSuportesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MensagemSuportes model
   */
  readonly fields: MensagemSuportesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MensagemSuportes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MensagemSuportesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MensagemSuportes model
   */
  interface MensagemSuportesFieldRefs {
    readonly id: FieldRef<"MensagemSuportes", 'Int'>
    readonly usuario_id: FieldRef<"MensagemSuportes", 'Int'>
    readonly tipo_usuario: FieldRef<"MensagemSuportes", 'enum_MensagemSuportes_tipo_usuario'>
    readonly createdAt: FieldRef<"MensagemSuportes", 'DateTime'>
    readonly updatedAt: FieldRef<"MensagemSuportes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MensagemSuportes findUnique
   */
  export type MensagemSuportesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MensagemSuportes
     */
    select?: MensagemSuportesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MensagemSuportes
     */
    omit?: MensagemSuportesOmit<ExtArgs> | null
    /**
     * Filter, which MensagemSuportes to fetch.
     */
    where: MensagemSuportesWhereUniqueInput
  }

  /**
   * MensagemSuportes findUniqueOrThrow
   */
  export type MensagemSuportesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MensagemSuportes
     */
    select?: MensagemSuportesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MensagemSuportes
     */
    omit?: MensagemSuportesOmit<ExtArgs> | null
    /**
     * Filter, which MensagemSuportes to fetch.
     */
    where: MensagemSuportesWhereUniqueInput
  }

  /**
   * MensagemSuportes findFirst
   */
  export type MensagemSuportesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MensagemSuportes
     */
    select?: MensagemSuportesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MensagemSuportes
     */
    omit?: MensagemSuportesOmit<ExtArgs> | null
    /**
     * Filter, which MensagemSuportes to fetch.
     */
    where?: MensagemSuportesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MensagemSuportes to fetch.
     */
    orderBy?: MensagemSuportesOrderByWithRelationInput | MensagemSuportesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MensagemSuportes.
     */
    cursor?: MensagemSuportesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MensagemSuportes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MensagemSuportes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MensagemSuportes.
     */
    distinct?: MensagemSuportesScalarFieldEnum | MensagemSuportesScalarFieldEnum[]
  }

  /**
   * MensagemSuportes findFirstOrThrow
   */
  export type MensagemSuportesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MensagemSuportes
     */
    select?: MensagemSuportesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MensagemSuportes
     */
    omit?: MensagemSuportesOmit<ExtArgs> | null
    /**
     * Filter, which MensagemSuportes to fetch.
     */
    where?: MensagemSuportesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MensagemSuportes to fetch.
     */
    orderBy?: MensagemSuportesOrderByWithRelationInput | MensagemSuportesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MensagemSuportes.
     */
    cursor?: MensagemSuportesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MensagemSuportes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MensagemSuportes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MensagemSuportes.
     */
    distinct?: MensagemSuportesScalarFieldEnum | MensagemSuportesScalarFieldEnum[]
  }

  /**
   * MensagemSuportes findMany
   */
  export type MensagemSuportesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MensagemSuportes
     */
    select?: MensagemSuportesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MensagemSuportes
     */
    omit?: MensagemSuportesOmit<ExtArgs> | null
    /**
     * Filter, which MensagemSuportes to fetch.
     */
    where?: MensagemSuportesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MensagemSuportes to fetch.
     */
    orderBy?: MensagemSuportesOrderByWithRelationInput | MensagemSuportesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MensagemSuportes.
     */
    cursor?: MensagemSuportesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MensagemSuportes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MensagemSuportes.
     */
    skip?: number
    distinct?: MensagemSuportesScalarFieldEnum | MensagemSuportesScalarFieldEnum[]
  }

  /**
   * MensagemSuportes create
   */
  export type MensagemSuportesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MensagemSuportes
     */
    select?: MensagemSuportesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MensagemSuportes
     */
    omit?: MensagemSuportesOmit<ExtArgs> | null
    /**
     * The data needed to create a MensagemSuportes.
     */
    data: XOR<MensagemSuportesCreateInput, MensagemSuportesUncheckedCreateInput>
  }

  /**
   * MensagemSuportes createMany
   */
  export type MensagemSuportesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MensagemSuportes.
     */
    data: MensagemSuportesCreateManyInput | MensagemSuportesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MensagemSuportes createManyAndReturn
   */
  export type MensagemSuportesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MensagemSuportes
     */
    select?: MensagemSuportesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MensagemSuportes
     */
    omit?: MensagemSuportesOmit<ExtArgs> | null
    /**
     * The data used to create many MensagemSuportes.
     */
    data: MensagemSuportesCreateManyInput | MensagemSuportesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MensagemSuportes update
   */
  export type MensagemSuportesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MensagemSuportes
     */
    select?: MensagemSuportesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MensagemSuportes
     */
    omit?: MensagemSuportesOmit<ExtArgs> | null
    /**
     * The data needed to update a MensagemSuportes.
     */
    data: XOR<MensagemSuportesUpdateInput, MensagemSuportesUncheckedUpdateInput>
    /**
     * Choose, which MensagemSuportes to update.
     */
    where: MensagemSuportesWhereUniqueInput
  }

  /**
   * MensagemSuportes updateMany
   */
  export type MensagemSuportesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MensagemSuportes.
     */
    data: XOR<MensagemSuportesUpdateManyMutationInput, MensagemSuportesUncheckedUpdateManyInput>
    /**
     * Filter which MensagemSuportes to update
     */
    where?: MensagemSuportesWhereInput
    /**
     * Limit how many MensagemSuportes to update.
     */
    limit?: number
  }

  /**
   * MensagemSuportes updateManyAndReturn
   */
  export type MensagemSuportesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MensagemSuportes
     */
    select?: MensagemSuportesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MensagemSuportes
     */
    omit?: MensagemSuportesOmit<ExtArgs> | null
    /**
     * The data used to update MensagemSuportes.
     */
    data: XOR<MensagemSuportesUpdateManyMutationInput, MensagemSuportesUncheckedUpdateManyInput>
    /**
     * Filter which MensagemSuportes to update
     */
    where?: MensagemSuportesWhereInput
    /**
     * Limit how many MensagemSuportes to update.
     */
    limit?: number
  }

  /**
   * MensagemSuportes upsert
   */
  export type MensagemSuportesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MensagemSuportes
     */
    select?: MensagemSuportesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MensagemSuportes
     */
    omit?: MensagemSuportesOmit<ExtArgs> | null
    /**
     * The filter to search for the MensagemSuportes to update in case it exists.
     */
    where: MensagemSuportesWhereUniqueInput
    /**
     * In case the MensagemSuportes found by the `where` argument doesn't exist, create a new MensagemSuportes with this data.
     */
    create: XOR<MensagemSuportesCreateInput, MensagemSuportesUncheckedCreateInput>
    /**
     * In case the MensagemSuportes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MensagemSuportesUpdateInput, MensagemSuportesUncheckedUpdateInput>
  }

  /**
   * MensagemSuportes delete
   */
  export type MensagemSuportesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MensagemSuportes
     */
    select?: MensagemSuportesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MensagemSuportes
     */
    omit?: MensagemSuportesOmit<ExtArgs> | null
    /**
     * Filter which MensagemSuportes to delete.
     */
    where: MensagemSuportesWhereUniqueInput
  }

  /**
   * MensagemSuportes deleteMany
   */
  export type MensagemSuportesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MensagemSuportes to delete
     */
    where?: MensagemSuportesWhereInput
    /**
     * Limit how many MensagemSuportes to delete.
     */
    limit?: number
  }

  /**
   * MensagemSuportes without action
   */
  export type MensagemSuportesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MensagemSuportes
     */
    select?: MensagemSuportesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MensagemSuportes
     */
    omit?: MensagemSuportesOmit<ExtArgs> | null
  }


  /**
   * Model Recompensas
   */

  export type AggregateRecompensas = {
    _count: RecompensasCountAggregateOutputType | null
    _avg: RecompensasAvgAggregateOutputType | null
    _sum: RecompensasSumAggregateOutputType | null
    _min: RecompensasMinAggregateOutputType | null
    _max: RecompensasMaxAggregateOutputType | null
  }

  export type RecompensasAvgAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    valor: number | null
  }

  export type RecompensasSumAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    valor: number | null
  }

  export type RecompensasMinAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    descricao: string | null
    valor: number | null
    status: $Enums.enum_Recompensas_status | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecompensasMaxAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    descricao: string | null
    valor: number | null
    status: $Enums.enum_Recompensas_status | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecompensasCountAggregateOutputType = {
    id: number
    usuarioId: number
    descricao: number
    valor: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RecompensasAvgAggregateInputType = {
    id?: true
    usuarioId?: true
    valor?: true
  }

  export type RecompensasSumAggregateInputType = {
    id?: true
    usuarioId?: true
    valor?: true
  }

  export type RecompensasMinAggregateInputType = {
    id?: true
    usuarioId?: true
    descricao?: true
    valor?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecompensasMaxAggregateInputType = {
    id?: true
    usuarioId?: true
    descricao?: true
    valor?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecompensasCountAggregateInputType = {
    id?: true
    usuarioId?: true
    descricao?: true
    valor?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RecompensasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Recompensas to aggregate.
     */
    where?: RecompensasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recompensas to fetch.
     */
    orderBy?: RecompensasOrderByWithRelationInput | RecompensasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecompensasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recompensas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recompensas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Recompensas
    **/
    _count?: true | RecompensasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecompensasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecompensasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecompensasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecompensasMaxAggregateInputType
  }

  export type GetRecompensasAggregateType<T extends RecompensasAggregateArgs> = {
        [P in keyof T & keyof AggregateRecompensas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecompensas[P]>
      : GetScalarType<T[P], AggregateRecompensas[P]>
  }




  export type RecompensasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecompensasWhereInput
    orderBy?: RecompensasOrderByWithAggregationInput | RecompensasOrderByWithAggregationInput[]
    by: RecompensasScalarFieldEnum[] | RecompensasScalarFieldEnum
    having?: RecompensasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecompensasCountAggregateInputType | true
    _avg?: RecompensasAvgAggregateInputType
    _sum?: RecompensasSumAggregateInputType
    _min?: RecompensasMinAggregateInputType
    _max?: RecompensasMaxAggregateInputType
  }

  export type RecompensasGroupByOutputType = {
    id: number
    usuarioId: number
    descricao: string
    valor: number
    status: $Enums.enum_Recompensas_status | null
    createdAt: Date
    updatedAt: Date
    _count: RecompensasCountAggregateOutputType | null
    _avg: RecompensasAvgAggregateOutputType | null
    _sum: RecompensasSumAggregateOutputType | null
    _min: RecompensasMinAggregateOutputType | null
    _max: RecompensasMaxAggregateOutputType | null
  }

  type GetRecompensasGroupByPayload<T extends RecompensasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecompensasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecompensasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecompensasGroupByOutputType[P]>
            : GetScalarType<T[P], RecompensasGroupByOutputType[P]>
        }
      >
    >


  export type RecompensasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    descricao?: boolean
    valor?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Usuarios?: boolean | UsuariosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recompensas"]>

  export type RecompensasSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    descricao?: boolean
    valor?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Usuarios?: boolean | UsuariosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recompensas"]>

  export type RecompensasSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    descricao?: boolean
    valor?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Usuarios?: boolean | UsuariosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recompensas"]>

  export type RecompensasSelectScalar = {
    id?: boolean
    usuarioId?: boolean
    descricao?: boolean
    valor?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RecompensasOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "usuarioId" | "descricao" | "valor" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["recompensas"]>
  export type RecompensasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Usuarios?: boolean | UsuariosDefaultArgs<ExtArgs>
  }
  export type RecompensasIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Usuarios?: boolean | UsuariosDefaultArgs<ExtArgs>
  }
  export type RecompensasIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Usuarios?: boolean | UsuariosDefaultArgs<ExtArgs>
  }

  export type $RecompensasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Recompensas"
    objects: {
      Usuarios: Prisma.$UsuariosPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      usuarioId: number
      descricao: string
      valor: number
      status: $Enums.enum_Recompensas_status | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["recompensas"]>
    composites: {}
  }

  type RecompensasGetPayload<S extends boolean | null | undefined | RecompensasDefaultArgs> = $Result.GetResult<Prisma.$RecompensasPayload, S>

  type RecompensasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RecompensasFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RecompensasCountAggregateInputType | true
    }

  export interface RecompensasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Recompensas'], meta: { name: 'Recompensas' } }
    /**
     * Find zero or one Recompensas that matches the filter.
     * @param {RecompensasFindUniqueArgs} args - Arguments to find a Recompensas
     * @example
     * // Get one Recompensas
     * const recompensas = await prisma.recompensas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecompensasFindUniqueArgs>(args: SelectSubset<T, RecompensasFindUniqueArgs<ExtArgs>>): Prisma__RecompensasClient<$Result.GetResult<Prisma.$RecompensasPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Recompensas that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RecompensasFindUniqueOrThrowArgs} args - Arguments to find a Recompensas
     * @example
     * // Get one Recompensas
     * const recompensas = await prisma.recompensas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecompensasFindUniqueOrThrowArgs>(args: SelectSubset<T, RecompensasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecompensasClient<$Result.GetResult<Prisma.$RecompensasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Recompensas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecompensasFindFirstArgs} args - Arguments to find a Recompensas
     * @example
     * // Get one Recompensas
     * const recompensas = await prisma.recompensas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecompensasFindFirstArgs>(args?: SelectSubset<T, RecompensasFindFirstArgs<ExtArgs>>): Prisma__RecompensasClient<$Result.GetResult<Prisma.$RecompensasPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Recompensas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecompensasFindFirstOrThrowArgs} args - Arguments to find a Recompensas
     * @example
     * // Get one Recompensas
     * const recompensas = await prisma.recompensas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecompensasFindFirstOrThrowArgs>(args?: SelectSubset<T, RecompensasFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecompensasClient<$Result.GetResult<Prisma.$RecompensasPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Recompensas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecompensasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Recompensas
     * const recompensas = await prisma.recompensas.findMany()
     * 
     * // Get first 10 Recompensas
     * const recompensas = await prisma.recompensas.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recompensasWithIdOnly = await prisma.recompensas.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecompensasFindManyArgs>(args?: SelectSubset<T, RecompensasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecompensasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Recompensas.
     * @param {RecompensasCreateArgs} args - Arguments to create a Recompensas.
     * @example
     * // Create one Recompensas
     * const Recompensas = await prisma.recompensas.create({
     *   data: {
     *     // ... data to create a Recompensas
     *   }
     * })
     * 
     */
    create<T extends RecompensasCreateArgs>(args: SelectSubset<T, RecompensasCreateArgs<ExtArgs>>): Prisma__RecompensasClient<$Result.GetResult<Prisma.$RecompensasPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Recompensas.
     * @param {RecompensasCreateManyArgs} args - Arguments to create many Recompensas.
     * @example
     * // Create many Recompensas
     * const recompensas = await prisma.recompensas.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecompensasCreateManyArgs>(args?: SelectSubset<T, RecompensasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Recompensas and returns the data saved in the database.
     * @param {RecompensasCreateManyAndReturnArgs} args - Arguments to create many Recompensas.
     * @example
     * // Create many Recompensas
     * const recompensas = await prisma.recompensas.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Recompensas and only return the `id`
     * const recompensasWithIdOnly = await prisma.recompensas.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecompensasCreateManyAndReturnArgs>(args?: SelectSubset<T, RecompensasCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecompensasPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Recompensas.
     * @param {RecompensasDeleteArgs} args - Arguments to delete one Recompensas.
     * @example
     * // Delete one Recompensas
     * const Recompensas = await prisma.recompensas.delete({
     *   where: {
     *     // ... filter to delete one Recompensas
     *   }
     * })
     * 
     */
    delete<T extends RecompensasDeleteArgs>(args: SelectSubset<T, RecompensasDeleteArgs<ExtArgs>>): Prisma__RecompensasClient<$Result.GetResult<Prisma.$RecompensasPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Recompensas.
     * @param {RecompensasUpdateArgs} args - Arguments to update one Recompensas.
     * @example
     * // Update one Recompensas
     * const recompensas = await prisma.recompensas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecompensasUpdateArgs>(args: SelectSubset<T, RecompensasUpdateArgs<ExtArgs>>): Prisma__RecompensasClient<$Result.GetResult<Prisma.$RecompensasPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Recompensas.
     * @param {RecompensasDeleteManyArgs} args - Arguments to filter Recompensas to delete.
     * @example
     * // Delete a few Recompensas
     * const { count } = await prisma.recompensas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecompensasDeleteManyArgs>(args?: SelectSubset<T, RecompensasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recompensas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecompensasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Recompensas
     * const recompensas = await prisma.recompensas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecompensasUpdateManyArgs>(args: SelectSubset<T, RecompensasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recompensas and returns the data updated in the database.
     * @param {RecompensasUpdateManyAndReturnArgs} args - Arguments to update many Recompensas.
     * @example
     * // Update many Recompensas
     * const recompensas = await prisma.recompensas.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Recompensas and only return the `id`
     * const recompensasWithIdOnly = await prisma.recompensas.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RecompensasUpdateManyAndReturnArgs>(args: SelectSubset<T, RecompensasUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecompensasPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Recompensas.
     * @param {RecompensasUpsertArgs} args - Arguments to update or create a Recompensas.
     * @example
     * // Update or create a Recompensas
     * const recompensas = await prisma.recompensas.upsert({
     *   create: {
     *     // ... data to create a Recompensas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Recompensas we want to update
     *   }
     * })
     */
    upsert<T extends RecompensasUpsertArgs>(args: SelectSubset<T, RecompensasUpsertArgs<ExtArgs>>): Prisma__RecompensasClient<$Result.GetResult<Prisma.$RecompensasPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Recompensas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecompensasCountArgs} args - Arguments to filter Recompensas to count.
     * @example
     * // Count the number of Recompensas
     * const count = await prisma.recompensas.count({
     *   where: {
     *     // ... the filter for the Recompensas we want to count
     *   }
     * })
    **/
    count<T extends RecompensasCountArgs>(
      args?: Subset<T, RecompensasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecompensasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Recompensas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecompensasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecompensasAggregateArgs>(args: Subset<T, RecompensasAggregateArgs>): Prisma.PrismaPromise<GetRecompensasAggregateType<T>>

    /**
     * Group by Recompensas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecompensasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecompensasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecompensasGroupByArgs['orderBy'] }
        : { orderBy?: RecompensasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecompensasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecompensasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Recompensas model
   */
  readonly fields: RecompensasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Recompensas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecompensasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Usuarios<T extends UsuariosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuariosDefaultArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Recompensas model
   */
  interface RecompensasFieldRefs {
    readonly id: FieldRef<"Recompensas", 'Int'>
    readonly usuarioId: FieldRef<"Recompensas", 'Int'>
    readonly descricao: FieldRef<"Recompensas", 'String'>
    readonly valor: FieldRef<"Recompensas", 'Float'>
    readonly status: FieldRef<"Recompensas", 'enum_Recompensas_status'>
    readonly createdAt: FieldRef<"Recompensas", 'DateTime'>
    readonly updatedAt: FieldRef<"Recompensas", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Recompensas findUnique
   */
  export type RecompensasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recompensas
     */
    select?: RecompensasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recompensas
     */
    omit?: RecompensasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecompensasInclude<ExtArgs> | null
    /**
     * Filter, which Recompensas to fetch.
     */
    where: RecompensasWhereUniqueInput
  }

  /**
   * Recompensas findUniqueOrThrow
   */
  export type RecompensasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recompensas
     */
    select?: RecompensasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recompensas
     */
    omit?: RecompensasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecompensasInclude<ExtArgs> | null
    /**
     * Filter, which Recompensas to fetch.
     */
    where: RecompensasWhereUniqueInput
  }

  /**
   * Recompensas findFirst
   */
  export type RecompensasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recompensas
     */
    select?: RecompensasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recompensas
     */
    omit?: RecompensasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecompensasInclude<ExtArgs> | null
    /**
     * Filter, which Recompensas to fetch.
     */
    where?: RecompensasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recompensas to fetch.
     */
    orderBy?: RecompensasOrderByWithRelationInput | RecompensasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recompensas.
     */
    cursor?: RecompensasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recompensas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recompensas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recompensas.
     */
    distinct?: RecompensasScalarFieldEnum | RecompensasScalarFieldEnum[]
  }

  /**
   * Recompensas findFirstOrThrow
   */
  export type RecompensasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recompensas
     */
    select?: RecompensasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recompensas
     */
    omit?: RecompensasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecompensasInclude<ExtArgs> | null
    /**
     * Filter, which Recompensas to fetch.
     */
    where?: RecompensasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recompensas to fetch.
     */
    orderBy?: RecompensasOrderByWithRelationInput | RecompensasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recompensas.
     */
    cursor?: RecompensasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recompensas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recompensas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recompensas.
     */
    distinct?: RecompensasScalarFieldEnum | RecompensasScalarFieldEnum[]
  }

  /**
   * Recompensas findMany
   */
  export type RecompensasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recompensas
     */
    select?: RecompensasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recompensas
     */
    omit?: RecompensasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecompensasInclude<ExtArgs> | null
    /**
     * Filter, which Recompensas to fetch.
     */
    where?: RecompensasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recompensas to fetch.
     */
    orderBy?: RecompensasOrderByWithRelationInput | RecompensasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Recompensas.
     */
    cursor?: RecompensasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recompensas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recompensas.
     */
    skip?: number
    distinct?: RecompensasScalarFieldEnum | RecompensasScalarFieldEnum[]
  }

  /**
   * Recompensas create
   */
  export type RecompensasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recompensas
     */
    select?: RecompensasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recompensas
     */
    omit?: RecompensasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecompensasInclude<ExtArgs> | null
    /**
     * The data needed to create a Recompensas.
     */
    data: XOR<RecompensasCreateInput, RecompensasUncheckedCreateInput>
  }

  /**
   * Recompensas createMany
   */
  export type RecompensasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Recompensas.
     */
    data: RecompensasCreateManyInput | RecompensasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Recompensas createManyAndReturn
   */
  export type RecompensasCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recompensas
     */
    select?: RecompensasSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Recompensas
     */
    omit?: RecompensasOmit<ExtArgs> | null
    /**
     * The data used to create many Recompensas.
     */
    data: RecompensasCreateManyInput | RecompensasCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecompensasIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Recompensas update
   */
  export type RecompensasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recompensas
     */
    select?: RecompensasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recompensas
     */
    omit?: RecompensasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecompensasInclude<ExtArgs> | null
    /**
     * The data needed to update a Recompensas.
     */
    data: XOR<RecompensasUpdateInput, RecompensasUncheckedUpdateInput>
    /**
     * Choose, which Recompensas to update.
     */
    where: RecompensasWhereUniqueInput
  }

  /**
   * Recompensas updateMany
   */
  export type RecompensasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Recompensas.
     */
    data: XOR<RecompensasUpdateManyMutationInput, RecompensasUncheckedUpdateManyInput>
    /**
     * Filter which Recompensas to update
     */
    where?: RecompensasWhereInput
    /**
     * Limit how many Recompensas to update.
     */
    limit?: number
  }

  /**
   * Recompensas updateManyAndReturn
   */
  export type RecompensasUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recompensas
     */
    select?: RecompensasSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Recompensas
     */
    omit?: RecompensasOmit<ExtArgs> | null
    /**
     * The data used to update Recompensas.
     */
    data: XOR<RecompensasUpdateManyMutationInput, RecompensasUncheckedUpdateManyInput>
    /**
     * Filter which Recompensas to update
     */
    where?: RecompensasWhereInput
    /**
     * Limit how many Recompensas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecompensasIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Recompensas upsert
   */
  export type RecompensasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recompensas
     */
    select?: RecompensasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recompensas
     */
    omit?: RecompensasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecompensasInclude<ExtArgs> | null
    /**
     * The filter to search for the Recompensas to update in case it exists.
     */
    where: RecompensasWhereUniqueInput
    /**
     * In case the Recompensas found by the `where` argument doesn't exist, create a new Recompensas with this data.
     */
    create: XOR<RecompensasCreateInput, RecompensasUncheckedCreateInput>
    /**
     * In case the Recompensas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecompensasUpdateInput, RecompensasUncheckedUpdateInput>
  }

  /**
   * Recompensas delete
   */
  export type RecompensasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recompensas
     */
    select?: RecompensasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recompensas
     */
    omit?: RecompensasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecompensasInclude<ExtArgs> | null
    /**
     * Filter which Recompensas to delete.
     */
    where: RecompensasWhereUniqueInput
  }

  /**
   * Recompensas deleteMany
   */
  export type RecompensasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Recompensas to delete
     */
    where?: RecompensasWhereInput
    /**
     * Limit how many Recompensas to delete.
     */
    limit?: number
  }

  /**
   * Recompensas without action
   */
  export type RecompensasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recompensas
     */
    select?: RecompensasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recompensas
     */
    omit?: RecompensasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecompensasInclude<ExtArgs> | null
  }


  /**
   * Model Saques
   */

  export type AggregateSaques = {
    _count: SaquesCountAggregateOutputType | null
    _avg: SaquesAvgAggregateOutputType | null
    _sum: SaquesSumAggregateOutputType | null
    _min: SaquesMinAggregateOutputType | null
    _max: SaquesMaxAggregateOutputType | null
  }

  export type SaquesAvgAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    valor: Decimal | null
  }

  export type SaquesSumAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    valor: Decimal | null
  }

  export type SaquesMinAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    valor: Decimal | null
    status: $Enums.enum_Saques_status | null
    tipo: $Enums.enum_Saques_tipo | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SaquesMaxAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    valor: Decimal | null
    status: $Enums.enum_Saques_status | null
    tipo: $Enums.enum_Saques_tipo | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SaquesCountAggregateOutputType = {
    id: number
    usuarioId: number
    valor: number
    status: number
    tipo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SaquesAvgAggregateInputType = {
    id?: true
    usuarioId?: true
    valor?: true
  }

  export type SaquesSumAggregateInputType = {
    id?: true
    usuarioId?: true
    valor?: true
  }

  export type SaquesMinAggregateInputType = {
    id?: true
    usuarioId?: true
    valor?: true
    status?: true
    tipo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SaquesMaxAggregateInputType = {
    id?: true
    usuarioId?: true
    valor?: true
    status?: true
    tipo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SaquesCountAggregateInputType = {
    id?: true
    usuarioId?: true
    valor?: true
    status?: true
    tipo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SaquesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Saques to aggregate.
     */
    where?: SaquesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Saques to fetch.
     */
    orderBy?: SaquesOrderByWithRelationInput | SaquesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SaquesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Saques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Saques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Saques
    **/
    _count?: true | SaquesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SaquesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SaquesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SaquesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SaquesMaxAggregateInputType
  }

  export type GetSaquesAggregateType<T extends SaquesAggregateArgs> = {
        [P in keyof T & keyof AggregateSaques]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSaques[P]>
      : GetScalarType<T[P], AggregateSaques[P]>
  }




  export type SaquesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaquesWhereInput
    orderBy?: SaquesOrderByWithAggregationInput | SaquesOrderByWithAggregationInput[]
    by: SaquesScalarFieldEnum[] | SaquesScalarFieldEnum
    having?: SaquesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SaquesCountAggregateInputType | true
    _avg?: SaquesAvgAggregateInputType
    _sum?: SaquesSumAggregateInputType
    _min?: SaquesMinAggregateInputType
    _max?: SaquesMaxAggregateInputType
  }

  export type SaquesGroupByOutputType = {
    id: number
    usuarioId: number
    valor: Decimal
    status: $Enums.enum_Saques_status | null
    tipo: $Enums.enum_Saques_tipo
    createdAt: Date
    updatedAt: Date
    _count: SaquesCountAggregateOutputType | null
    _avg: SaquesAvgAggregateOutputType | null
    _sum: SaquesSumAggregateOutputType | null
    _min: SaquesMinAggregateOutputType | null
    _max: SaquesMaxAggregateOutputType | null
  }

  type GetSaquesGroupByPayload<T extends SaquesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SaquesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SaquesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SaquesGroupByOutputType[P]>
            : GetScalarType<T[P], SaquesGroupByOutputType[P]>
        }
      >
    >


  export type SaquesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    valor?: boolean
    status?: boolean
    tipo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Usuarios?: boolean | UsuariosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saques"]>

  export type SaquesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    valor?: boolean
    status?: boolean
    tipo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Usuarios?: boolean | UsuariosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saques"]>

  export type SaquesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    valor?: boolean
    status?: boolean
    tipo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Usuarios?: boolean | UsuariosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saques"]>

  export type SaquesSelectScalar = {
    id?: boolean
    usuarioId?: boolean
    valor?: boolean
    status?: boolean
    tipo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SaquesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "usuarioId" | "valor" | "status" | "tipo" | "createdAt" | "updatedAt", ExtArgs["result"]["saques"]>
  export type SaquesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Usuarios?: boolean | UsuariosDefaultArgs<ExtArgs>
  }
  export type SaquesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Usuarios?: boolean | UsuariosDefaultArgs<ExtArgs>
  }
  export type SaquesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Usuarios?: boolean | UsuariosDefaultArgs<ExtArgs>
  }

  export type $SaquesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Saques"
    objects: {
      Usuarios: Prisma.$UsuariosPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      usuarioId: number
      valor: Prisma.Decimal
      status: $Enums.enum_Saques_status | null
      tipo: $Enums.enum_Saques_tipo
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["saques"]>
    composites: {}
  }

  type SaquesGetPayload<S extends boolean | null | undefined | SaquesDefaultArgs> = $Result.GetResult<Prisma.$SaquesPayload, S>

  type SaquesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SaquesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SaquesCountAggregateInputType | true
    }

  export interface SaquesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Saques'], meta: { name: 'Saques' } }
    /**
     * Find zero or one Saques that matches the filter.
     * @param {SaquesFindUniqueArgs} args - Arguments to find a Saques
     * @example
     * // Get one Saques
     * const saques = await prisma.saques.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SaquesFindUniqueArgs>(args: SelectSubset<T, SaquesFindUniqueArgs<ExtArgs>>): Prisma__SaquesClient<$Result.GetResult<Prisma.$SaquesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Saques that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SaquesFindUniqueOrThrowArgs} args - Arguments to find a Saques
     * @example
     * // Get one Saques
     * const saques = await prisma.saques.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SaquesFindUniqueOrThrowArgs>(args: SelectSubset<T, SaquesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SaquesClient<$Result.GetResult<Prisma.$SaquesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Saques that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaquesFindFirstArgs} args - Arguments to find a Saques
     * @example
     * // Get one Saques
     * const saques = await prisma.saques.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SaquesFindFirstArgs>(args?: SelectSubset<T, SaquesFindFirstArgs<ExtArgs>>): Prisma__SaquesClient<$Result.GetResult<Prisma.$SaquesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Saques that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaquesFindFirstOrThrowArgs} args - Arguments to find a Saques
     * @example
     * // Get one Saques
     * const saques = await prisma.saques.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SaquesFindFirstOrThrowArgs>(args?: SelectSubset<T, SaquesFindFirstOrThrowArgs<ExtArgs>>): Prisma__SaquesClient<$Result.GetResult<Prisma.$SaquesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Saques that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaquesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Saques
     * const saques = await prisma.saques.findMany()
     * 
     * // Get first 10 Saques
     * const saques = await prisma.saques.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const saquesWithIdOnly = await prisma.saques.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SaquesFindManyArgs>(args?: SelectSubset<T, SaquesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaquesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Saques.
     * @param {SaquesCreateArgs} args - Arguments to create a Saques.
     * @example
     * // Create one Saques
     * const Saques = await prisma.saques.create({
     *   data: {
     *     // ... data to create a Saques
     *   }
     * })
     * 
     */
    create<T extends SaquesCreateArgs>(args: SelectSubset<T, SaquesCreateArgs<ExtArgs>>): Prisma__SaquesClient<$Result.GetResult<Prisma.$SaquesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Saques.
     * @param {SaquesCreateManyArgs} args - Arguments to create many Saques.
     * @example
     * // Create many Saques
     * const saques = await prisma.saques.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SaquesCreateManyArgs>(args?: SelectSubset<T, SaquesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Saques and returns the data saved in the database.
     * @param {SaquesCreateManyAndReturnArgs} args - Arguments to create many Saques.
     * @example
     * // Create many Saques
     * const saques = await prisma.saques.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Saques and only return the `id`
     * const saquesWithIdOnly = await prisma.saques.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SaquesCreateManyAndReturnArgs>(args?: SelectSubset<T, SaquesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaquesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Saques.
     * @param {SaquesDeleteArgs} args - Arguments to delete one Saques.
     * @example
     * // Delete one Saques
     * const Saques = await prisma.saques.delete({
     *   where: {
     *     // ... filter to delete one Saques
     *   }
     * })
     * 
     */
    delete<T extends SaquesDeleteArgs>(args: SelectSubset<T, SaquesDeleteArgs<ExtArgs>>): Prisma__SaquesClient<$Result.GetResult<Prisma.$SaquesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Saques.
     * @param {SaquesUpdateArgs} args - Arguments to update one Saques.
     * @example
     * // Update one Saques
     * const saques = await prisma.saques.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SaquesUpdateArgs>(args: SelectSubset<T, SaquesUpdateArgs<ExtArgs>>): Prisma__SaquesClient<$Result.GetResult<Prisma.$SaquesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Saques.
     * @param {SaquesDeleteManyArgs} args - Arguments to filter Saques to delete.
     * @example
     * // Delete a few Saques
     * const { count } = await prisma.saques.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SaquesDeleteManyArgs>(args?: SelectSubset<T, SaquesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Saques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaquesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Saques
     * const saques = await prisma.saques.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SaquesUpdateManyArgs>(args: SelectSubset<T, SaquesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Saques and returns the data updated in the database.
     * @param {SaquesUpdateManyAndReturnArgs} args - Arguments to update many Saques.
     * @example
     * // Update many Saques
     * const saques = await prisma.saques.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Saques and only return the `id`
     * const saquesWithIdOnly = await prisma.saques.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SaquesUpdateManyAndReturnArgs>(args: SelectSubset<T, SaquesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaquesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Saques.
     * @param {SaquesUpsertArgs} args - Arguments to update or create a Saques.
     * @example
     * // Update or create a Saques
     * const saques = await prisma.saques.upsert({
     *   create: {
     *     // ... data to create a Saques
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Saques we want to update
     *   }
     * })
     */
    upsert<T extends SaquesUpsertArgs>(args: SelectSubset<T, SaquesUpsertArgs<ExtArgs>>): Prisma__SaquesClient<$Result.GetResult<Prisma.$SaquesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Saques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaquesCountArgs} args - Arguments to filter Saques to count.
     * @example
     * // Count the number of Saques
     * const count = await prisma.saques.count({
     *   where: {
     *     // ... the filter for the Saques we want to count
     *   }
     * })
    **/
    count<T extends SaquesCountArgs>(
      args?: Subset<T, SaquesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SaquesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Saques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaquesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SaquesAggregateArgs>(args: Subset<T, SaquesAggregateArgs>): Prisma.PrismaPromise<GetSaquesAggregateType<T>>

    /**
     * Group by Saques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaquesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SaquesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SaquesGroupByArgs['orderBy'] }
        : { orderBy?: SaquesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SaquesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaquesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Saques model
   */
  readonly fields: SaquesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Saques.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SaquesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Usuarios<T extends UsuariosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuariosDefaultArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Saques model
   */
  interface SaquesFieldRefs {
    readonly id: FieldRef<"Saques", 'Int'>
    readonly usuarioId: FieldRef<"Saques", 'Int'>
    readonly valor: FieldRef<"Saques", 'Decimal'>
    readonly status: FieldRef<"Saques", 'enum_Saques_status'>
    readonly tipo: FieldRef<"Saques", 'enum_Saques_tipo'>
    readonly createdAt: FieldRef<"Saques", 'DateTime'>
    readonly updatedAt: FieldRef<"Saques", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Saques findUnique
   */
  export type SaquesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Saques
     */
    select?: SaquesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Saques
     */
    omit?: SaquesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaquesInclude<ExtArgs> | null
    /**
     * Filter, which Saques to fetch.
     */
    where: SaquesWhereUniqueInput
  }

  /**
   * Saques findUniqueOrThrow
   */
  export type SaquesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Saques
     */
    select?: SaquesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Saques
     */
    omit?: SaquesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaquesInclude<ExtArgs> | null
    /**
     * Filter, which Saques to fetch.
     */
    where: SaquesWhereUniqueInput
  }

  /**
   * Saques findFirst
   */
  export type SaquesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Saques
     */
    select?: SaquesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Saques
     */
    omit?: SaquesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaquesInclude<ExtArgs> | null
    /**
     * Filter, which Saques to fetch.
     */
    where?: SaquesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Saques to fetch.
     */
    orderBy?: SaquesOrderByWithRelationInput | SaquesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Saques.
     */
    cursor?: SaquesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Saques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Saques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Saques.
     */
    distinct?: SaquesScalarFieldEnum | SaquesScalarFieldEnum[]
  }

  /**
   * Saques findFirstOrThrow
   */
  export type SaquesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Saques
     */
    select?: SaquesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Saques
     */
    omit?: SaquesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaquesInclude<ExtArgs> | null
    /**
     * Filter, which Saques to fetch.
     */
    where?: SaquesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Saques to fetch.
     */
    orderBy?: SaquesOrderByWithRelationInput | SaquesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Saques.
     */
    cursor?: SaquesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Saques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Saques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Saques.
     */
    distinct?: SaquesScalarFieldEnum | SaquesScalarFieldEnum[]
  }

  /**
   * Saques findMany
   */
  export type SaquesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Saques
     */
    select?: SaquesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Saques
     */
    omit?: SaquesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaquesInclude<ExtArgs> | null
    /**
     * Filter, which Saques to fetch.
     */
    where?: SaquesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Saques to fetch.
     */
    orderBy?: SaquesOrderByWithRelationInput | SaquesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Saques.
     */
    cursor?: SaquesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Saques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Saques.
     */
    skip?: number
    distinct?: SaquesScalarFieldEnum | SaquesScalarFieldEnum[]
  }

  /**
   * Saques create
   */
  export type SaquesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Saques
     */
    select?: SaquesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Saques
     */
    omit?: SaquesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaquesInclude<ExtArgs> | null
    /**
     * The data needed to create a Saques.
     */
    data: XOR<SaquesCreateInput, SaquesUncheckedCreateInput>
  }

  /**
   * Saques createMany
   */
  export type SaquesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Saques.
     */
    data: SaquesCreateManyInput | SaquesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Saques createManyAndReturn
   */
  export type SaquesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Saques
     */
    select?: SaquesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Saques
     */
    omit?: SaquesOmit<ExtArgs> | null
    /**
     * The data used to create many Saques.
     */
    data: SaquesCreateManyInput | SaquesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaquesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Saques update
   */
  export type SaquesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Saques
     */
    select?: SaquesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Saques
     */
    omit?: SaquesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaquesInclude<ExtArgs> | null
    /**
     * The data needed to update a Saques.
     */
    data: XOR<SaquesUpdateInput, SaquesUncheckedUpdateInput>
    /**
     * Choose, which Saques to update.
     */
    where: SaquesWhereUniqueInput
  }

  /**
   * Saques updateMany
   */
  export type SaquesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Saques.
     */
    data: XOR<SaquesUpdateManyMutationInput, SaquesUncheckedUpdateManyInput>
    /**
     * Filter which Saques to update
     */
    where?: SaquesWhereInput
    /**
     * Limit how many Saques to update.
     */
    limit?: number
  }

  /**
   * Saques updateManyAndReturn
   */
  export type SaquesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Saques
     */
    select?: SaquesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Saques
     */
    omit?: SaquesOmit<ExtArgs> | null
    /**
     * The data used to update Saques.
     */
    data: XOR<SaquesUpdateManyMutationInput, SaquesUncheckedUpdateManyInput>
    /**
     * Filter which Saques to update
     */
    where?: SaquesWhereInput
    /**
     * Limit how many Saques to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaquesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Saques upsert
   */
  export type SaquesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Saques
     */
    select?: SaquesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Saques
     */
    omit?: SaquesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaquesInclude<ExtArgs> | null
    /**
     * The filter to search for the Saques to update in case it exists.
     */
    where: SaquesWhereUniqueInput
    /**
     * In case the Saques found by the `where` argument doesn't exist, create a new Saques with this data.
     */
    create: XOR<SaquesCreateInput, SaquesUncheckedCreateInput>
    /**
     * In case the Saques was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SaquesUpdateInput, SaquesUncheckedUpdateInput>
  }

  /**
   * Saques delete
   */
  export type SaquesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Saques
     */
    select?: SaquesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Saques
     */
    omit?: SaquesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaquesInclude<ExtArgs> | null
    /**
     * Filter which Saques to delete.
     */
    where: SaquesWhereUniqueInput
  }

  /**
   * Saques deleteMany
   */
  export type SaquesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Saques to delete
     */
    where?: SaquesWhereInput
    /**
     * Limit how many Saques to delete.
     */
    limit?: number
  }

  /**
   * Saques without action
   */
  export type SaquesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Saques
     */
    select?: SaquesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Saques
     */
    omit?: SaquesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaquesInclude<ExtArgs> | null
  }


  /**
   * Model Transacaos
   */

  export type AggregateTransacaos = {
    _count: TransacaosCountAggregateOutputType | null
    _avg: TransacaosAvgAggregateOutputType | null
    _sum: TransacaosSumAggregateOutputType | null
    _min: TransacaosMinAggregateOutputType | null
    _max: TransacaosMaxAggregateOutputType | null
  }

  export type TransacaosAvgAggregateOutputType = {
    id: number | null
    usuario_id: number | null
    valor: number | null
  }

  export type TransacaosSumAggregateOutputType = {
    id: number | null
    usuario_id: number | null
    valor: number | null
  }

  export type TransacaosMinAggregateOutputType = {
    id: number | null
    usuario_id: number | null
    tipo: $Enums.enum_Transacaos_tipo | null
    valor: number | null
    data: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransacaosMaxAggregateOutputType = {
    id: number | null
    usuario_id: number | null
    tipo: $Enums.enum_Transacaos_tipo | null
    valor: number | null
    data: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransacaosCountAggregateOutputType = {
    id: number
    usuario_id: number
    tipo: number
    valor: number
    data: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransacaosAvgAggregateInputType = {
    id?: true
    usuario_id?: true
    valor?: true
  }

  export type TransacaosSumAggregateInputType = {
    id?: true
    usuario_id?: true
    valor?: true
  }

  export type TransacaosMinAggregateInputType = {
    id?: true
    usuario_id?: true
    tipo?: true
    valor?: true
    data?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransacaosMaxAggregateInputType = {
    id?: true
    usuario_id?: true
    tipo?: true
    valor?: true
    data?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransacaosCountAggregateInputType = {
    id?: true
    usuario_id?: true
    tipo?: true
    valor?: true
    data?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransacaosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transacaos to aggregate.
     */
    where?: TransacaosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transacaos to fetch.
     */
    orderBy?: TransacaosOrderByWithRelationInput | TransacaosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransacaosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transacaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transacaos
    **/
    _count?: true | TransacaosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransacaosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransacaosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransacaosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransacaosMaxAggregateInputType
  }

  export type GetTransacaosAggregateType<T extends TransacaosAggregateArgs> = {
        [P in keyof T & keyof AggregateTransacaos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransacaos[P]>
      : GetScalarType<T[P], AggregateTransacaos[P]>
  }




  export type TransacaosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransacaosWhereInput
    orderBy?: TransacaosOrderByWithAggregationInput | TransacaosOrderByWithAggregationInput[]
    by: TransacaosScalarFieldEnum[] | TransacaosScalarFieldEnum
    having?: TransacaosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransacaosCountAggregateInputType | true
    _avg?: TransacaosAvgAggregateInputType
    _sum?: TransacaosSumAggregateInputType
    _min?: TransacaosMinAggregateInputType
    _max?: TransacaosMaxAggregateInputType
  }

  export type TransacaosGroupByOutputType = {
    id: number
    usuario_id: number
    tipo: $Enums.enum_Transacaos_tipo
    valor: number
    data: Date
    createdAt: Date
    updatedAt: Date
    _count: TransacaosCountAggregateOutputType | null
    _avg: TransacaosAvgAggregateOutputType | null
    _sum: TransacaosSumAggregateOutputType | null
    _min: TransacaosMinAggregateOutputType | null
    _max: TransacaosMaxAggregateOutputType | null
  }

  type GetTransacaosGroupByPayload<T extends TransacaosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransacaosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransacaosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransacaosGroupByOutputType[P]>
            : GetScalarType<T[P], TransacaosGroupByOutputType[P]>
        }
      >
    >


  export type TransacaosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    tipo?: boolean
    valor?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Usuarios?: boolean | UsuariosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transacaos"]>

  export type TransacaosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    tipo?: boolean
    valor?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Usuarios?: boolean | UsuariosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transacaos"]>

  export type TransacaosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    tipo?: boolean
    valor?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Usuarios?: boolean | UsuariosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transacaos"]>

  export type TransacaosSelectScalar = {
    id?: boolean
    usuario_id?: boolean
    tipo?: boolean
    valor?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransacaosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "usuario_id" | "tipo" | "valor" | "data" | "createdAt" | "updatedAt", ExtArgs["result"]["transacaos"]>
  export type TransacaosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Usuarios?: boolean | UsuariosDefaultArgs<ExtArgs>
  }
  export type TransacaosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Usuarios?: boolean | UsuariosDefaultArgs<ExtArgs>
  }
  export type TransacaosIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Usuarios?: boolean | UsuariosDefaultArgs<ExtArgs>
  }

  export type $TransacaosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transacaos"
    objects: {
      Usuarios: Prisma.$UsuariosPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      usuario_id: number
      tipo: $Enums.enum_Transacaos_tipo
      valor: number
      data: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transacaos"]>
    composites: {}
  }

  type TransacaosGetPayload<S extends boolean | null | undefined | TransacaosDefaultArgs> = $Result.GetResult<Prisma.$TransacaosPayload, S>

  type TransacaosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransacaosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransacaosCountAggregateInputType | true
    }

  export interface TransacaosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transacaos'], meta: { name: 'Transacaos' } }
    /**
     * Find zero or one Transacaos that matches the filter.
     * @param {TransacaosFindUniqueArgs} args - Arguments to find a Transacaos
     * @example
     * // Get one Transacaos
     * const transacaos = await prisma.transacaos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransacaosFindUniqueArgs>(args: SelectSubset<T, TransacaosFindUniqueArgs<ExtArgs>>): Prisma__TransacaosClient<$Result.GetResult<Prisma.$TransacaosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transacaos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransacaosFindUniqueOrThrowArgs} args - Arguments to find a Transacaos
     * @example
     * // Get one Transacaos
     * const transacaos = await prisma.transacaos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransacaosFindUniqueOrThrowArgs>(args: SelectSubset<T, TransacaosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransacaosClient<$Result.GetResult<Prisma.$TransacaosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transacaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransacaosFindFirstArgs} args - Arguments to find a Transacaos
     * @example
     * // Get one Transacaos
     * const transacaos = await prisma.transacaos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransacaosFindFirstArgs>(args?: SelectSubset<T, TransacaosFindFirstArgs<ExtArgs>>): Prisma__TransacaosClient<$Result.GetResult<Prisma.$TransacaosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transacaos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransacaosFindFirstOrThrowArgs} args - Arguments to find a Transacaos
     * @example
     * // Get one Transacaos
     * const transacaos = await prisma.transacaos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransacaosFindFirstOrThrowArgs>(args?: SelectSubset<T, TransacaosFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransacaosClient<$Result.GetResult<Prisma.$TransacaosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transacaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransacaosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transacaos
     * const transacaos = await prisma.transacaos.findMany()
     * 
     * // Get first 10 Transacaos
     * const transacaos = await prisma.transacaos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transacaosWithIdOnly = await prisma.transacaos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransacaosFindManyArgs>(args?: SelectSubset<T, TransacaosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransacaosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transacaos.
     * @param {TransacaosCreateArgs} args - Arguments to create a Transacaos.
     * @example
     * // Create one Transacaos
     * const Transacaos = await prisma.transacaos.create({
     *   data: {
     *     // ... data to create a Transacaos
     *   }
     * })
     * 
     */
    create<T extends TransacaosCreateArgs>(args: SelectSubset<T, TransacaosCreateArgs<ExtArgs>>): Prisma__TransacaosClient<$Result.GetResult<Prisma.$TransacaosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transacaos.
     * @param {TransacaosCreateManyArgs} args - Arguments to create many Transacaos.
     * @example
     * // Create many Transacaos
     * const transacaos = await prisma.transacaos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransacaosCreateManyArgs>(args?: SelectSubset<T, TransacaosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transacaos and returns the data saved in the database.
     * @param {TransacaosCreateManyAndReturnArgs} args - Arguments to create many Transacaos.
     * @example
     * // Create many Transacaos
     * const transacaos = await prisma.transacaos.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transacaos and only return the `id`
     * const transacaosWithIdOnly = await prisma.transacaos.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransacaosCreateManyAndReturnArgs>(args?: SelectSubset<T, TransacaosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransacaosPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transacaos.
     * @param {TransacaosDeleteArgs} args - Arguments to delete one Transacaos.
     * @example
     * // Delete one Transacaos
     * const Transacaos = await prisma.transacaos.delete({
     *   where: {
     *     // ... filter to delete one Transacaos
     *   }
     * })
     * 
     */
    delete<T extends TransacaosDeleteArgs>(args: SelectSubset<T, TransacaosDeleteArgs<ExtArgs>>): Prisma__TransacaosClient<$Result.GetResult<Prisma.$TransacaosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transacaos.
     * @param {TransacaosUpdateArgs} args - Arguments to update one Transacaos.
     * @example
     * // Update one Transacaos
     * const transacaos = await prisma.transacaos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransacaosUpdateArgs>(args: SelectSubset<T, TransacaosUpdateArgs<ExtArgs>>): Prisma__TransacaosClient<$Result.GetResult<Prisma.$TransacaosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transacaos.
     * @param {TransacaosDeleteManyArgs} args - Arguments to filter Transacaos to delete.
     * @example
     * // Delete a few Transacaos
     * const { count } = await prisma.transacaos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransacaosDeleteManyArgs>(args?: SelectSubset<T, TransacaosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransacaosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transacaos
     * const transacaos = await prisma.transacaos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransacaosUpdateManyArgs>(args: SelectSubset<T, TransacaosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transacaos and returns the data updated in the database.
     * @param {TransacaosUpdateManyAndReturnArgs} args - Arguments to update many Transacaos.
     * @example
     * // Update many Transacaos
     * const transacaos = await prisma.transacaos.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transacaos and only return the `id`
     * const transacaosWithIdOnly = await prisma.transacaos.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransacaosUpdateManyAndReturnArgs>(args: SelectSubset<T, TransacaosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransacaosPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transacaos.
     * @param {TransacaosUpsertArgs} args - Arguments to update or create a Transacaos.
     * @example
     * // Update or create a Transacaos
     * const transacaos = await prisma.transacaos.upsert({
     *   create: {
     *     // ... data to create a Transacaos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transacaos we want to update
     *   }
     * })
     */
    upsert<T extends TransacaosUpsertArgs>(args: SelectSubset<T, TransacaosUpsertArgs<ExtArgs>>): Prisma__TransacaosClient<$Result.GetResult<Prisma.$TransacaosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransacaosCountArgs} args - Arguments to filter Transacaos to count.
     * @example
     * // Count the number of Transacaos
     * const count = await prisma.transacaos.count({
     *   where: {
     *     // ... the filter for the Transacaos we want to count
     *   }
     * })
    **/
    count<T extends TransacaosCountArgs>(
      args?: Subset<T, TransacaosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransacaosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransacaosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransacaosAggregateArgs>(args: Subset<T, TransacaosAggregateArgs>): Prisma.PrismaPromise<GetTransacaosAggregateType<T>>

    /**
     * Group by Transacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransacaosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransacaosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransacaosGroupByArgs['orderBy'] }
        : { orderBy?: TransacaosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransacaosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransacaosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transacaos model
   */
  readonly fields: TransacaosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transacaos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransacaosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Usuarios<T extends UsuariosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuariosDefaultArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transacaos model
   */
  interface TransacaosFieldRefs {
    readonly id: FieldRef<"Transacaos", 'Int'>
    readonly usuario_id: FieldRef<"Transacaos", 'Int'>
    readonly tipo: FieldRef<"Transacaos", 'enum_Transacaos_tipo'>
    readonly valor: FieldRef<"Transacaos", 'Float'>
    readonly data: FieldRef<"Transacaos", 'DateTime'>
    readonly createdAt: FieldRef<"Transacaos", 'DateTime'>
    readonly updatedAt: FieldRef<"Transacaos", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transacaos findUnique
   */
  export type TransacaosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transacaos
     */
    select?: TransacaosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transacaos
     */
    omit?: TransacaosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransacaosInclude<ExtArgs> | null
    /**
     * Filter, which Transacaos to fetch.
     */
    where: TransacaosWhereUniqueInput
  }

  /**
   * Transacaos findUniqueOrThrow
   */
  export type TransacaosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transacaos
     */
    select?: TransacaosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transacaos
     */
    omit?: TransacaosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransacaosInclude<ExtArgs> | null
    /**
     * Filter, which Transacaos to fetch.
     */
    where: TransacaosWhereUniqueInput
  }

  /**
   * Transacaos findFirst
   */
  export type TransacaosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transacaos
     */
    select?: TransacaosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transacaos
     */
    omit?: TransacaosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransacaosInclude<ExtArgs> | null
    /**
     * Filter, which Transacaos to fetch.
     */
    where?: TransacaosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transacaos to fetch.
     */
    orderBy?: TransacaosOrderByWithRelationInput | TransacaosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transacaos.
     */
    cursor?: TransacaosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transacaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transacaos.
     */
    distinct?: TransacaosScalarFieldEnum | TransacaosScalarFieldEnum[]
  }

  /**
   * Transacaos findFirstOrThrow
   */
  export type TransacaosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transacaos
     */
    select?: TransacaosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transacaos
     */
    omit?: TransacaosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransacaosInclude<ExtArgs> | null
    /**
     * Filter, which Transacaos to fetch.
     */
    where?: TransacaosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transacaos to fetch.
     */
    orderBy?: TransacaosOrderByWithRelationInput | TransacaosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transacaos.
     */
    cursor?: TransacaosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transacaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transacaos.
     */
    distinct?: TransacaosScalarFieldEnum | TransacaosScalarFieldEnum[]
  }

  /**
   * Transacaos findMany
   */
  export type TransacaosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transacaos
     */
    select?: TransacaosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transacaos
     */
    omit?: TransacaosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransacaosInclude<ExtArgs> | null
    /**
     * Filter, which Transacaos to fetch.
     */
    where?: TransacaosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transacaos to fetch.
     */
    orderBy?: TransacaosOrderByWithRelationInput | TransacaosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transacaos.
     */
    cursor?: TransacaosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transacaos.
     */
    skip?: number
    distinct?: TransacaosScalarFieldEnum | TransacaosScalarFieldEnum[]
  }

  /**
   * Transacaos create
   */
  export type TransacaosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transacaos
     */
    select?: TransacaosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transacaos
     */
    omit?: TransacaosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransacaosInclude<ExtArgs> | null
    /**
     * The data needed to create a Transacaos.
     */
    data: XOR<TransacaosCreateInput, TransacaosUncheckedCreateInput>
  }

  /**
   * Transacaos createMany
   */
  export type TransacaosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transacaos.
     */
    data: TransacaosCreateManyInput | TransacaosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transacaos createManyAndReturn
   */
  export type TransacaosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transacaos
     */
    select?: TransacaosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transacaos
     */
    omit?: TransacaosOmit<ExtArgs> | null
    /**
     * The data used to create many Transacaos.
     */
    data: TransacaosCreateManyInput | TransacaosCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransacaosIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transacaos update
   */
  export type TransacaosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transacaos
     */
    select?: TransacaosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transacaos
     */
    omit?: TransacaosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransacaosInclude<ExtArgs> | null
    /**
     * The data needed to update a Transacaos.
     */
    data: XOR<TransacaosUpdateInput, TransacaosUncheckedUpdateInput>
    /**
     * Choose, which Transacaos to update.
     */
    where: TransacaosWhereUniqueInput
  }

  /**
   * Transacaos updateMany
   */
  export type TransacaosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transacaos.
     */
    data: XOR<TransacaosUpdateManyMutationInput, TransacaosUncheckedUpdateManyInput>
    /**
     * Filter which Transacaos to update
     */
    where?: TransacaosWhereInput
    /**
     * Limit how many Transacaos to update.
     */
    limit?: number
  }

  /**
   * Transacaos updateManyAndReturn
   */
  export type TransacaosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transacaos
     */
    select?: TransacaosSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transacaos
     */
    omit?: TransacaosOmit<ExtArgs> | null
    /**
     * The data used to update Transacaos.
     */
    data: XOR<TransacaosUpdateManyMutationInput, TransacaosUncheckedUpdateManyInput>
    /**
     * Filter which Transacaos to update
     */
    where?: TransacaosWhereInput
    /**
     * Limit how many Transacaos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransacaosIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transacaos upsert
   */
  export type TransacaosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transacaos
     */
    select?: TransacaosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transacaos
     */
    omit?: TransacaosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransacaosInclude<ExtArgs> | null
    /**
     * The filter to search for the Transacaos to update in case it exists.
     */
    where: TransacaosWhereUniqueInput
    /**
     * In case the Transacaos found by the `where` argument doesn't exist, create a new Transacaos with this data.
     */
    create: XOR<TransacaosCreateInput, TransacaosUncheckedCreateInput>
    /**
     * In case the Transacaos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransacaosUpdateInput, TransacaosUncheckedUpdateInput>
  }

  /**
   * Transacaos delete
   */
  export type TransacaosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transacaos
     */
    select?: TransacaosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transacaos
     */
    omit?: TransacaosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransacaosInclude<ExtArgs> | null
    /**
     * Filter which Transacaos to delete.
     */
    where: TransacaosWhereUniqueInput
  }

  /**
   * Transacaos deleteMany
   */
  export type TransacaosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transacaos to delete
     */
    where?: TransacaosWhereInput
    /**
     * Limit how many Transacaos to delete.
     */
    limit?: number
  }

  /**
   * Transacaos without action
   */
  export type TransacaosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transacaos
     */
    select?: TransacaosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transacaos
     */
    omit?: TransacaosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransacaosInclude<ExtArgs> | null
  }


  /**
   * Model Usuarios
   */

  export type AggregateUsuarios = {
    _count: UsuariosCountAggregateOutputType | null
    _avg: UsuariosAvgAggregateOutputType | null
    _sum: UsuariosSumAggregateOutputType | null
    _min: UsuariosMinAggregateOutputType | null
    _max: UsuariosMaxAggregateOutputType | null
  }

  export type UsuariosAvgAggregateOutputType = {
    id: number | null
  }

  export type UsuariosSumAggregateOutputType = {
    id: number | null
  }

  export type UsuariosMinAggregateOutputType = {
    id: number | null
    nome: string | null
    email: string | null
    cpf: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsuariosMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    email: string | null
    cpf: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsuariosCountAggregateOutputType = {
    id: number
    nome: number
    email: number
    cpf: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UsuariosAvgAggregateInputType = {
    id?: true
  }

  export type UsuariosSumAggregateInputType = {
    id?: true
  }

  export type UsuariosMinAggregateInputType = {
    id?: true
    nome?: true
    email?: true
    cpf?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsuariosMaxAggregateInputType = {
    id?: true
    nome?: true
    email?: true
    cpf?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsuariosCountAggregateInputType = {
    id?: true
    nome?: true
    email?: true
    cpf?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UsuariosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuarios to aggregate.
     */
    where?: UsuariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuariosOrderByWithRelationInput | UsuariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsuariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Usuarios
    **/
    _count?: true | UsuariosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuariosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuariosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuariosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuariosMaxAggregateInputType
  }

  export type GetUsuariosAggregateType<T extends UsuariosAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuarios]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuarios[P]>
      : GetScalarType<T[P], AggregateUsuarios[P]>
  }




  export type UsuariosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuariosWhereInput
    orderBy?: UsuariosOrderByWithAggregationInput | UsuariosOrderByWithAggregationInput[]
    by: UsuariosScalarFieldEnum[] | UsuariosScalarFieldEnum
    having?: UsuariosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuariosCountAggregateInputType | true
    _avg?: UsuariosAvgAggregateInputType
    _sum?: UsuariosSumAggregateInputType
    _min?: UsuariosMinAggregateInputType
    _max?: UsuariosMaxAggregateInputType
  }

  export type UsuariosGroupByOutputType = {
    id: number
    nome: string
    email: string
    cpf: string | null
    createdAt: Date
    updatedAt: Date
    _count: UsuariosCountAggregateOutputType | null
    _avg: UsuariosAvgAggregateOutputType | null
    _sum: UsuariosSumAggregateOutputType | null
    _min: UsuariosMinAggregateOutputType | null
    _max: UsuariosMaxAggregateOutputType | null
  }

  type GetUsuariosGroupByPayload<T extends UsuariosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuariosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuariosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuariosGroupByOutputType[P]>
            : GetScalarType<T[P], UsuariosGroupByOutputType[P]>
        }
      >
    >


  export type UsuariosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    email?: boolean
    cpf?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Indicacaos_Indicacaos_indicadoIdToUsuarios?: boolean | Usuarios$Indicacaos_Indicacaos_indicadoIdToUsuariosArgs<ExtArgs>
    Indicacaos_Indicacaos_indicanteIdToUsuarios?: boolean | Usuarios$Indicacaos_Indicacaos_indicanteIdToUsuariosArgs<ExtArgs>
    Recompensas?: boolean | Usuarios$RecompensasArgs<ExtArgs>
    Saques?: boolean | Usuarios$SaquesArgs<ExtArgs>
    Transacaos?: boolean | Usuarios$TransacaosArgs<ExtArgs>
    _count?: boolean | UsuariosCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuarios"]>

  export type UsuariosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    email?: boolean
    cpf?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["usuarios"]>

  export type UsuariosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    email?: boolean
    cpf?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["usuarios"]>

  export type UsuariosSelectScalar = {
    id?: boolean
    nome?: boolean
    email?: boolean
    cpf?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UsuariosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nome" | "email" | "cpf" | "createdAt" | "updatedAt", ExtArgs["result"]["usuarios"]>
  export type UsuariosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Indicacaos_Indicacaos_indicadoIdToUsuarios?: boolean | Usuarios$Indicacaos_Indicacaos_indicadoIdToUsuariosArgs<ExtArgs>
    Indicacaos_Indicacaos_indicanteIdToUsuarios?: boolean | Usuarios$Indicacaos_Indicacaos_indicanteIdToUsuariosArgs<ExtArgs>
    Recompensas?: boolean | Usuarios$RecompensasArgs<ExtArgs>
    Saques?: boolean | Usuarios$SaquesArgs<ExtArgs>
    Transacaos?: boolean | Usuarios$TransacaosArgs<ExtArgs>
    _count?: boolean | UsuariosCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UsuariosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UsuariosIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UsuariosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Usuarios"
    objects: {
      Indicacaos_Indicacaos_indicadoIdToUsuarios: Prisma.$IndicacaosPayload<ExtArgs>[]
      Indicacaos_Indicacaos_indicanteIdToUsuarios: Prisma.$IndicacaosPayload<ExtArgs>[]
      Recompensas: Prisma.$RecompensasPayload<ExtArgs>[]
      Saques: Prisma.$SaquesPayload<ExtArgs>[]
      Transacaos: Prisma.$TransacaosPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      email: string
      cpf: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["usuarios"]>
    composites: {}
  }

  type UsuariosGetPayload<S extends boolean | null | undefined | UsuariosDefaultArgs> = $Result.GetResult<Prisma.$UsuariosPayload, S>

  type UsuariosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UsuariosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsuariosCountAggregateInputType | true
    }

  export interface UsuariosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Usuarios'], meta: { name: 'Usuarios' } }
    /**
     * Find zero or one Usuarios that matches the filter.
     * @param {UsuariosFindUniqueArgs} args - Arguments to find a Usuarios
     * @example
     * // Get one Usuarios
     * const usuarios = await prisma.usuarios.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsuariosFindUniqueArgs>(args: SelectSubset<T, UsuariosFindUniqueArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Usuarios that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UsuariosFindUniqueOrThrowArgs} args - Arguments to find a Usuarios
     * @example
     * // Get one Usuarios
     * const usuarios = await prisma.usuarios.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsuariosFindUniqueOrThrowArgs>(args: SelectSubset<T, UsuariosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosFindFirstArgs} args - Arguments to find a Usuarios
     * @example
     * // Get one Usuarios
     * const usuarios = await prisma.usuarios.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsuariosFindFirstArgs>(args?: SelectSubset<T, UsuariosFindFirstArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Usuarios that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosFindFirstOrThrowArgs} args - Arguments to find a Usuarios
     * @example
     * // Get one Usuarios
     * const usuarios = await prisma.usuarios.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsuariosFindFirstOrThrowArgs>(args?: SelectSubset<T, UsuariosFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuarios.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuarios.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuariosWithIdOnly = await prisma.usuarios.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsuariosFindManyArgs>(args?: SelectSubset<T, UsuariosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Usuarios.
     * @param {UsuariosCreateArgs} args - Arguments to create a Usuarios.
     * @example
     * // Create one Usuarios
     * const Usuarios = await prisma.usuarios.create({
     *   data: {
     *     // ... data to create a Usuarios
     *   }
     * })
     * 
     */
    create<T extends UsuariosCreateArgs>(args: SelectSubset<T, UsuariosCreateArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Usuarios.
     * @param {UsuariosCreateManyArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuarios = await prisma.usuarios.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsuariosCreateManyArgs>(args?: SelectSubset<T, UsuariosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Usuarios and returns the data saved in the database.
     * @param {UsuariosCreateManyAndReturnArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuarios = await prisma.usuarios.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Usuarios and only return the `id`
     * const usuariosWithIdOnly = await prisma.usuarios.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsuariosCreateManyAndReturnArgs>(args?: SelectSubset<T, UsuariosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Usuarios.
     * @param {UsuariosDeleteArgs} args - Arguments to delete one Usuarios.
     * @example
     * // Delete one Usuarios
     * const Usuarios = await prisma.usuarios.delete({
     *   where: {
     *     // ... filter to delete one Usuarios
     *   }
     * })
     * 
     */
    delete<T extends UsuariosDeleteArgs>(args: SelectSubset<T, UsuariosDeleteArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Usuarios.
     * @param {UsuariosUpdateArgs} args - Arguments to update one Usuarios.
     * @example
     * // Update one Usuarios
     * const usuarios = await prisma.usuarios.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsuariosUpdateArgs>(args: SelectSubset<T, UsuariosUpdateArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Usuarios.
     * @param {UsuariosDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuarios.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsuariosDeleteManyArgs>(args?: SelectSubset<T, UsuariosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuarios = await prisma.usuarios.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsuariosUpdateManyArgs>(args: SelectSubset<T, UsuariosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios and returns the data updated in the database.
     * @param {UsuariosUpdateManyAndReturnArgs} args - Arguments to update many Usuarios.
     * @example
     * // Update many Usuarios
     * const usuarios = await prisma.usuarios.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Usuarios and only return the `id`
     * const usuariosWithIdOnly = await prisma.usuarios.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UsuariosUpdateManyAndReturnArgs>(args: SelectSubset<T, UsuariosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Usuarios.
     * @param {UsuariosUpsertArgs} args - Arguments to update or create a Usuarios.
     * @example
     * // Update or create a Usuarios
     * const usuarios = await prisma.usuarios.upsert({
     *   create: {
     *     // ... data to create a Usuarios
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuarios we want to update
     *   }
     * })
     */
    upsert<T extends UsuariosUpsertArgs>(args: SelectSubset<T, UsuariosUpsertArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuarios.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends UsuariosCountArgs>(
      args?: Subset<T, UsuariosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuariosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuariosAggregateArgs>(args: Subset<T, UsuariosAggregateArgs>): Prisma.PrismaPromise<GetUsuariosAggregateType<T>>

    /**
     * Group by Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuariosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuariosGroupByArgs['orderBy'] }
        : { orderBy?: UsuariosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuariosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuariosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Usuarios model
   */
  readonly fields: UsuariosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Usuarios.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsuariosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Indicacaos_Indicacaos_indicadoIdToUsuarios<T extends Usuarios$Indicacaos_Indicacaos_indicadoIdToUsuariosArgs<ExtArgs> = {}>(args?: Subset<T, Usuarios$Indicacaos_Indicacaos_indicadoIdToUsuariosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicacaosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Indicacaos_Indicacaos_indicanteIdToUsuarios<T extends Usuarios$Indicacaos_Indicacaos_indicanteIdToUsuariosArgs<ExtArgs> = {}>(args?: Subset<T, Usuarios$Indicacaos_Indicacaos_indicanteIdToUsuariosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicacaosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Recompensas<T extends Usuarios$RecompensasArgs<ExtArgs> = {}>(args?: Subset<T, Usuarios$RecompensasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecompensasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Saques<T extends Usuarios$SaquesArgs<ExtArgs> = {}>(args?: Subset<T, Usuarios$SaquesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaquesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Transacaos<T extends Usuarios$TransacaosArgs<ExtArgs> = {}>(args?: Subset<T, Usuarios$TransacaosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransacaosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Usuarios model
   */
  interface UsuariosFieldRefs {
    readonly id: FieldRef<"Usuarios", 'Int'>
    readonly nome: FieldRef<"Usuarios", 'String'>
    readonly email: FieldRef<"Usuarios", 'String'>
    readonly cpf: FieldRef<"Usuarios", 'String'>
    readonly createdAt: FieldRef<"Usuarios", 'DateTime'>
    readonly updatedAt: FieldRef<"Usuarios", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Usuarios findUnique
   */
  export type UsuariosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuarios
     */
    omit?: UsuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuariosInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where: UsuariosWhereUniqueInput
  }

  /**
   * Usuarios findUniqueOrThrow
   */
  export type UsuariosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuarios
     */
    omit?: UsuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuariosInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where: UsuariosWhereUniqueInput
  }

  /**
   * Usuarios findFirst
   */
  export type UsuariosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuarios
     */
    omit?: UsuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuariosInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuariosOrderByWithRelationInput | UsuariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuariosScalarFieldEnum | UsuariosScalarFieldEnum[]
  }

  /**
   * Usuarios findFirstOrThrow
   */
  export type UsuariosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuarios
     */
    omit?: UsuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuariosInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuariosOrderByWithRelationInput | UsuariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuariosScalarFieldEnum | UsuariosScalarFieldEnum[]
  }

  /**
   * Usuarios findMany
   */
  export type UsuariosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuarios
     */
    omit?: UsuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuariosInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuariosOrderByWithRelationInput | UsuariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Usuarios.
     */
    cursor?: UsuariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    distinct?: UsuariosScalarFieldEnum | UsuariosScalarFieldEnum[]
  }

  /**
   * Usuarios create
   */
  export type UsuariosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuarios
     */
    omit?: UsuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuariosInclude<ExtArgs> | null
    /**
     * The data needed to create a Usuarios.
     */
    data: XOR<UsuariosCreateInput, UsuariosUncheckedCreateInput>
  }

  /**
   * Usuarios createMany
   */
  export type UsuariosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Usuarios.
     */
    data: UsuariosCreateManyInput | UsuariosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Usuarios createManyAndReturn
   */
  export type UsuariosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Usuarios
     */
    omit?: UsuariosOmit<ExtArgs> | null
    /**
     * The data used to create many Usuarios.
     */
    data: UsuariosCreateManyInput | UsuariosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Usuarios update
   */
  export type UsuariosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuarios
     */
    omit?: UsuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuariosInclude<ExtArgs> | null
    /**
     * The data needed to update a Usuarios.
     */
    data: XOR<UsuariosUpdateInput, UsuariosUncheckedUpdateInput>
    /**
     * Choose, which Usuarios to update.
     */
    where: UsuariosWhereUniqueInput
  }

  /**
   * Usuarios updateMany
   */
  export type UsuariosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuariosUpdateManyMutationInput, UsuariosUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuariosWhereInput
    /**
     * Limit how many Usuarios to update.
     */
    limit?: number
  }

  /**
   * Usuarios updateManyAndReturn
   */
  export type UsuariosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Usuarios
     */
    omit?: UsuariosOmit<ExtArgs> | null
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuariosUpdateManyMutationInput, UsuariosUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuariosWhereInput
    /**
     * Limit how many Usuarios to update.
     */
    limit?: number
  }

  /**
   * Usuarios upsert
   */
  export type UsuariosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuarios
     */
    omit?: UsuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuariosInclude<ExtArgs> | null
    /**
     * The filter to search for the Usuarios to update in case it exists.
     */
    where: UsuariosWhereUniqueInput
    /**
     * In case the Usuarios found by the `where` argument doesn't exist, create a new Usuarios with this data.
     */
    create: XOR<UsuariosCreateInput, UsuariosUncheckedCreateInput>
    /**
     * In case the Usuarios was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsuariosUpdateInput, UsuariosUncheckedUpdateInput>
  }

  /**
   * Usuarios delete
   */
  export type UsuariosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuarios
     */
    omit?: UsuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuariosInclude<ExtArgs> | null
    /**
     * Filter which Usuarios to delete.
     */
    where: UsuariosWhereUniqueInput
  }

  /**
   * Usuarios deleteMany
   */
  export type UsuariosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuarios to delete
     */
    where?: UsuariosWhereInput
    /**
     * Limit how many Usuarios to delete.
     */
    limit?: number
  }

  /**
   * Usuarios.Indicacaos_Indicacaos_indicadoIdToUsuarios
   */
  export type Usuarios$Indicacaos_Indicacaos_indicadoIdToUsuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicacaos
     */
    select?: IndicacaosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Indicacaos
     */
    omit?: IndicacaosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicacaosInclude<ExtArgs> | null
    where?: IndicacaosWhereInput
    orderBy?: IndicacaosOrderByWithRelationInput | IndicacaosOrderByWithRelationInput[]
    cursor?: IndicacaosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IndicacaosScalarFieldEnum | IndicacaosScalarFieldEnum[]
  }

  /**
   * Usuarios.Indicacaos_Indicacaos_indicanteIdToUsuarios
   */
  export type Usuarios$Indicacaos_Indicacaos_indicanteIdToUsuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicacaos
     */
    select?: IndicacaosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Indicacaos
     */
    omit?: IndicacaosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicacaosInclude<ExtArgs> | null
    where?: IndicacaosWhereInput
    orderBy?: IndicacaosOrderByWithRelationInput | IndicacaosOrderByWithRelationInput[]
    cursor?: IndicacaosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IndicacaosScalarFieldEnum | IndicacaosScalarFieldEnum[]
  }

  /**
   * Usuarios.Recompensas
   */
  export type Usuarios$RecompensasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recompensas
     */
    select?: RecompensasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recompensas
     */
    omit?: RecompensasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecompensasInclude<ExtArgs> | null
    where?: RecompensasWhereInput
    orderBy?: RecompensasOrderByWithRelationInput | RecompensasOrderByWithRelationInput[]
    cursor?: RecompensasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecompensasScalarFieldEnum | RecompensasScalarFieldEnum[]
  }

  /**
   * Usuarios.Saques
   */
  export type Usuarios$SaquesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Saques
     */
    select?: SaquesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Saques
     */
    omit?: SaquesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaquesInclude<ExtArgs> | null
    where?: SaquesWhereInput
    orderBy?: SaquesOrderByWithRelationInput | SaquesOrderByWithRelationInput[]
    cursor?: SaquesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaquesScalarFieldEnum | SaquesScalarFieldEnum[]
  }

  /**
   * Usuarios.Transacaos
   */
  export type Usuarios$TransacaosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transacaos
     */
    select?: TransacaosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transacaos
     */
    omit?: TransacaosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransacaosInclude<ExtArgs> | null
    where?: TransacaosWhereInput
    orderBy?: TransacaosOrderByWithRelationInput | TransacaosOrderByWithRelationInput[]
    cursor?: TransacaosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransacaosScalarFieldEnum | TransacaosScalarFieldEnum[]
  }

  /**
   * Usuarios without action
   */
  export type UsuariosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuarios
     */
    omit?: UsuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuariosInclude<ExtArgs> | null
  }


  /**
   * Model Veiculos
   */

  export type AggregateVeiculos = {
    _count: VeiculosCountAggregateOutputType | null
    _avg: VeiculosAvgAggregateOutputType | null
    _sum: VeiculosSumAggregateOutputType | null
    _min: VeiculosMinAggregateOutputType | null
    _max: VeiculosMaxAggregateOutputType | null
  }

  export type VeiculosAvgAggregateOutputType = {
    id: number | null
    motorista_id: number | null
    ano: number | null
  }

  export type VeiculosSumAggregateOutputType = {
    id: number | null
    motorista_id: number | null
    ano: number | null
  }

  export type VeiculosMinAggregateOutputType = {
    id: number | null
    motorista_id: number | null
    modelo: string | null
    placa: string | null
    ano: number | null
    categoria: $Enums.enum_Veiculos_categoria | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VeiculosMaxAggregateOutputType = {
    id: number | null
    motorista_id: number | null
    modelo: string | null
    placa: string | null
    ano: number | null
    categoria: $Enums.enum_Veiculos_categoria | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VeiculosCountAggregateOutputType = {
    id: number
    motorista_id: number
    modelo: number
    placa: number
    ano: number
    categoria: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VeiculosAvgAggregateInputType = {
    id?: true
    motorista_id?: true
    ano?: true
  }

  export type VeiculosSumAggregateInputType = {
    id?: true
    motorista_id?: true
    ano?: true
  }

  export type VeiculosMinAggregateInputType = {
    id?: true
    motorista_id?: true
    modelo?: true
    placa?: true
    ano?: true
    categoria?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VeiculosMaxAggregateInputType = {
    id?: true
    motorista_id?: true
    modelo?: true
    placa?: true
    ano?: true
    categoria?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VeiculosCountAggregateInputType = {
    id?: true
    motorista_id?: true
    modelo?: true
    placa?: true
    ano?: true
    categoria?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VeiculosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Veiculos to aggregate.
     */
    where?: VeiculosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Veiculos to fetch.
     */
    orderBy?: VeiculosOrderByWithRelationInput | VeiculosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VeiculosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Veiculos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Veiculos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Veiculos
    **/
    _count?: true | VeiculosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VeiculosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VeiculosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VeiculosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VeiculosMaxAggregateInputType
  }

  export type GetVeiculosAggregateType<T extends VeiculosAggregateArgs> = {
        [P in keyof T & keyof AggregateVeiculos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVeiculos[P]>
      : GetScalarType<T[P], AggregateVeiculos[P]>
  }




  export type VeiculosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VeiculosWhereInput
    orderBy?: VeiculosOrderByWithAggregationInput | VeiculosOrderByWithAggregationInput[]
    by: VeiculosScalarFieldEnum[] | VeiculosScalarFieldEnum
    having?: VeiculosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VeiculosCountAggregateInputType | true
    _avg?: VeiculosAvgAggregateInputType
    _sum?: VeiculosSumAggregateInputType
    _min?: VeiculosMinAggregateInputType
    _max?: VeiculosMaxAggregateInputType
  }

  export type VeiculosGroupByOutputType = {
    id: number
    motorista_id: number
    modelo: string
    placa: string
    ano: number
    categoria: $Enums.enum_Veiculos_categoria | null
    createdAt: Date
    updatedAt: Date
    _count: VeiculosCountAggregateOutputType | null
    _avg: VeiculosAvgAggregateOutputType | null
    _sum: VeiculosSumAggregateOutputType | null
    _min: VeiculosMinAggregateOutputType | null
    _max: VeiculosMaxAggregateOutputType | null
  }

  type GetVeiculosGroupByPayload<T extends VeiculosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VeiculosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VeiculosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VeiculosGroupByOutputType[P]>
            : GetScalarType<T[P], VeiculosGroupByOutputType[P]>
        }
      >
    >


  export type VeiculosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    motorista_id?: boolean
    modelo?: boolean
    placa?: boolean
    ano?: boolean
    categoria?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["veiculos"]>

  export type VeiculosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    motorista_id?: boolean
    modelo?: boolean
    placa?: boolean
    ano?: boolean
    categoria?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["veiculos"]>

  export type VeiculosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    motorista_id?: boolean
    modelo?: boolean
    placa?: boolean
    ano?: boolean
    categoria?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["veiculos"]>

  export type VeiculosSelectScalar = {
    id?: boolean
    motorista_id?: boolean
    modelo?: boolean
    placa?: boolean
    ano?: boolean
    categoria?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VeiculosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "motorista_id" | "modelo" | "placa" | "ano" | "categoria" | "createdAt" | "updatedAt", ExtArgs["result"]["veiculos"]>

  export type $VeiculosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Veiculos"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      motorista_id: number
      modelo: string
      placa: string
      ano: number
      categoria: $Enums.enum_Veiculos_categoria | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["veiculos"]>
    composites: {}
  }

  type VeiculosGetPayload<S extends boolean | null | undefined | VeiculosDefaultArgs> = $Result.GetResult<Prisma.$VeiculosPayload, S>

  type VeiculosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VeiculosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VeiculosCountAggregateInputType | true
    }

  export interface VeiculosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Veiculos'], meta: { name: 'Veiculos' } }
    /**
     * Find zero or one Veiculos that matches the filter.
     * @param {VeiculosFindUniqueArgs} args - Arguments to find a Veiculos
     * @example
     * // Get one Veiculos
     * const veiculos = await prisma.veiculos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VeiculosFindUniqueArgs>(args: SelectSubset<T, VeiculosFindUniqueArgs<ExtArgs>>): Prisma__VeiculosClient<$Result.GetResult<Prisma.$VeiculosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Veiculos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VeiculosFindUniqueOrThrowArgs} args - Arguments to find a Veiculos
     * @example
     * // Get one Veiculos
     * const veiculos = await prisma.veiculos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VeiculosFindUniqueOrThrowArgs>(args: SelectSubset<T, VeiculosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VeiculosClient<$Result.GetResult<Prisma.$VeiculosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Veiculos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VeiculosFindFirstArgs} args - Arguments to find a Veiculos
     * @example
     * // Get one Veiculos
     * const veiculos = await prisma.veiculos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VeiculosFindFirstArgs>(args?: SelectSubset<T, VeiculosFindFirstArgs<ExtArgs>>): Prisma__VeiculosClient<$Result.GetResult<Prisma.$VeiculosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Veiculos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VeiculosFindFirstOrThrowArgs} args - Arguments to find a Veiculos
     * @example
     * // Get one Veiculos
     * const veiculos = await prisma.veiculos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VeiculosFindFirstOrThrowArgs>(args?: SelectSubset<T, VeiculosFindFirstOrThrowArgs<ExtArgs>>): Prisma__VeiculosClient<$Result.GetResult<Prisma.$VeiculosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Veiculos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VeiculosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Veiculos
     * const veiculos = await prisma.veiculos.findMany()
     * 
     * // Get first 10 Veiculos
     * const veiculos = await prisma.veiculos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const veiculosWithIdOnly = await prisma.veiculos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VeiculosFindManyArgs>(args?: SelectSubset<T, VeiculosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VeiculosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Veiculos.
     * @param {VeiculosCreateArgs} args - Arguments to create a Veiculos.
     * @example
     * // Create one Veiculos
     * const Veiculos = await prisma.veiculos.create({
     *   data: {
     *     // ... data to create a Veiculos
     *   }
     * })
     * 
     */
    create<T extends VeiculosCreateArgs>(args: SelectSubset<T, VeiculosCreateArgs<ExtArgs>>): Prisma__VeiculosClient<$Result.GetResult<Prisma.$VeiculosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Veiculos.
     * @param {VeiculosCreateManyArgs} args - Arguments to create many Veiculos.
     * @example
     * // Create many Veiculos
     * const veiculos = await prisma.veiculos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VeiculosCreateManyArgs>(args?: SelectSubset<T, VeiculosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Veiculos and returns the data saved in the database.
     * @param {VeiculosCreateManyAndReturnArgs} args - Arguments to create many Veiculos.
     * @example
     * // Create many Veiculos
     * const veiculos = await prisma.veiculos.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Veiculos and only return the `id`
     * const veiculosWithIdOnly = await prisma.veiculos.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VeiculosCreateManyAndReturnArgs>(args?: SelectSubset<T, VeiculosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VeiculosPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Veiculos.
     * @param {VeiculosDeleteArgs} args - Arguments to delete one Veiculos.
     * @example
     * // Delete one Veiculos
     * const Veiculos = await prisma.veiculos.delete({
     *   where: {
     *     // ... filter to delete one Veiculos
     *   }
     * })
     * 
     */
    delete<T extends VeiculosDeleteArgs>(args: SelectSubset<T, VeiculosDeleteArgs<ExtArgs>>): Prisma__VeiculosClient<$Result.GetResult<Prisma.$VeiculosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Veiculos.
     * @param {VeiculosUpdateArgs} args - Arguments to update one Veiculos.
     * @example
     * // Update one Veiculos
     * const veiculos = await prisma.veiculos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VeiculosUpdateArgs>(args: SelectSubset<T, VeiculosUpdateArgs<ExtArgs>>): Prisma__VeiculosClient<$Result.GetResult<Prisma.$VeiculosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Veiculos.
     * @param {VeiculosDeleteManyArgs} args - Arguments to filter Veiculos to delete.
     * @example
     * // Delete a few Veiculos
     * const { count } = await prisma.veiculos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VeiculosDeleteManyArgs>(args?: SelectSubset<T, VeiculosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Veiculos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VeiculosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Veiculos
     * const veiculos = await prisma.veiculos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VeiculosUpdateManyArgs>(args: SelectSubset<T, VeiculosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Veiculos and returns the data updated in the database.
     * @param {VeiculosUpdateManyAndReturnArgs} args - Arguments to update many Veiculos.
     * @example
     * // Update many Veiculos
     * const veiculos = await prisma.veiculos.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Veiculos and only return the `id`
     * const veiculosWithIdOnly = await prisma.veiculos.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VeiculosUpdateManyAndReturnArgs>(args: SelectSubset<T, VeiculosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VeiculosPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Veiculos.
     * @param {VeiculosUpsertArgs} args - Arguments to update or create a Veiculos.
     * @example
     * // Update or create a Veiculos
     * const veiculos = await prisma.veiculos.upsert({
     *   create: {
     *     // ... data to create a Veiculos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Veiculos we want to update
     *   }
     * })
     */
    upsert<T extends VeiculosUpsertArgs>(args: SelectSubset<T, VeiculosUpsertArgs<ExtArgs>>): Prisma__VeiculosClient<$Result.GetResult<Prisma.$VeiculosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Veiculos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VeiculosCountArgs} args - Arguments to filter Veiculos to count.
     * @example
     * // Count the number of Veiculos
     * const count = await prisma.veiculos.count({
     *   where: {
     *     // ... the filter for the Veiculos we want to count
     *   }
     * })
    **/
    count<T extends VeiculosCountArgs>(
      args?: Subset<T, VeiculosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VeiculosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Veiculos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VeiculosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VeiculosAggregateArgs>(args: Subset<T, VeiculosAggregateArgs>): Prisma.PrismaPromise<GetVeiculosAggregateType<T>>

    /**
     * Group by Veiculos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VeiculosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VeiculosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VeiculosGroupByArgs['orderBy'] }
        : { orderBy?: VeiculosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VeiculosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVeiculosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Veiculos model
   */
  readonly fields: VeiculosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Veiculos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VeiculosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Veiculos model
   */
  interface VeiculosFieldRefs {
    readonly id: FieldRef<"Veiculos", 'Int'>
    readonly motorista_id: FieldRef<"Veiculos", 'Int'>
    readonly modelo: FieldRef<"Veiculos", 'String'>
    readonly placa: FieldRef<"Veiculos", 'String'>
    readonly ano: FieldRef<"Veiculos", 'Int'>
    readonly categoria: FieldRef<"Veiculos", 'enum_Veiculos_categoria'>
    readonly createdAt: FieldRef<"Veiculos", 'DateTime'>
    readonly updatedAt: FieldRef<"Veiculos", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Veiculos findUnique
   */
  export type VeiculosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Veiculos
     */
    select?: VeiculosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Veiculos
     */
    omit?: VeiculosOmit<ExtArgs> | null
    /**
     * Filter, which Veiculos to fetch.
     */
    where: VeiculosWhereUniqueInput
  }

  /**
   * Veiculos findUniqueOrThrow
   */
  export type VeiculosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Veiculos
     */
    select?: VeiculosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Veiculos
     */
    omit?: VeiculosOmit<ExtArgs> | null
    /**
     * Filter, which Veiculos to fetch.
     */
    where: VeiculosWhereUniqueInput
  }

  /**
   * Veiculos findFirst
   */
  export type VeiculosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Veiculos
     */
    select?: VeiculosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Veiculos
     */
    omit?: VeiculosOmit<ExtArgs> | null
    /**
     * Filter, which Veiculos to fetch.
     */
    where?: VeiculosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Veiculos to fetch.
     */
    orderBy?: VeiculosOrderByWithRelationInput | VeiculosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Veiculos.
     */
    cursor?: VeiculosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Veiculos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Veiculos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Veiculos.
     */
    distinct?: VeiculosScalarFieldEnum | VeiculosScalarFieldEnum[]
  }

  /**
   * Veiculos findFirstOrThrow
   */
  export type VeiculosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Veiculos
     */
    select?: VeiculosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Veiculos
     */
    omit?: VeiculosOmit<ExtArgs> | null
    /**
     * Filter, which Veiculos to fetch.
     */
    where?: VeiculosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Veiculos to fetch.
     */
    orderBy?: VeiculosOrderByWithRelationInput | VeiculosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Veiculos.
     */
    cursor?: VeiculosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Veiculos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Veiculos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Veiculos.
     */
    distinct?: VeiculosScalarFieldEnum | VeiculosScalarFieldEnum[]
  }

  /**
   * Veiculos findMany
   */
  export type VeiculosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Veiculos
     */
    select?: VeiculosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Veiculos
     */
    omit?: VeiculosOmit<ExtArgs> | null
    /**
     * Filter, which Veiculos to fetch.
     */
    where?: VeiculosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Veiculos to fetch.
     */
    orderBy?: VeiculosOrderByWithRelationInput | VeiculosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Veiculos.
     */
    cursor?: VeiculosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Veiculos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Veiculos.
     */
    skip?: number
    distinct?: VeiculosScalarFieldEnum | VeiculosScalarFieldEnum[]
  }

  /**
   * Veiculos create
   */
  export type VeiculosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Veiculos
     */
    select?: VeiculosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Veiculos
     */
    omit?: VeiculosOmit<ExtArgs> | null
    /**
     * The data needed to create a Veiculos.
     */
    data: XOR<VeiculosCreateInput, VeiculosUncheckedCreateInput>
  }

  /**
   * Veiculos createMany
   */
  export type VeiculosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Veiculos.
     */
    data: VeiculosCreateManyInput | VeiculosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Veiculos createManyAndReturn
   */
  export type VeiculosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Veiculos
     */
    select?: VeiculosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Veiculos
     */
    omit?: VeiculosOmit<ExtArgs> | null
    /**
     * The data used to create many Veiculos.
     */
    data: VeiculosCreateManyInput | VeiculosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Veiculos update
   */
  export type VeiculosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Veiculos
     */
    select?: VeiculosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Veiculos
     */
    omit?: VeiculosOmit<ExtArgs> | null
    /**
     * The data needed to update a Veiculos.
     */
    data: XOR<VeiculosUpdateInput, VeiculosUncheckedUpdateInput>
    /**
     * Choose, which Veiculos to update.
     */
    where: VeiculosWhereUniqueInput
  }

  /**
   * Veiculos updateMany
   */
  export type VeiculosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Veiculos.
     */
    data: XOR<VeiculosUpdateManyMutationInput, VeiculosUncheckedUpdateManyInput>
    /**
     * Filter which Veiculos to update
     */
    where?: VeiculosWhereInput
    /**
     * Limit how many Veiculos to update.
     */
    limit?: number
  }

  /**
   * Veiculos updateManyAndReturn
   */
  export type VeiculosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Veiculos
     */
    select?: VeiculosSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Veiculos
     */
    omit?: VeiculosOmit<ExtArgs> | null
    /**
     * The data used to update Veiculos.
     */
    data: XOR<VeiculosUpdateManyMutationInput, VeiculosUncheckedUpdateManyInput>
    /**
     * Filter which Veiculos to update
     */
    where?: VeiculosWhereInput
    /**
     * Limit how many Veiculos to update.
     */
    limit?: number
  }

  /**
   * Veiculos upsert
   */
  export type VeiculosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Veiculos
     */
    select?: VeiculosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Veiculos
     */
    omit?: VeiculosOmit<ExtArgs> | null
    /**
     * The filter to search for the Veiculos to update in case it exists.
     */
    where: VeiculosWhereUniqueInput
    /**
     * In case the Veiculos found by the `where` argument doesn't exist, create a new Veiculos with this data.
     */
    create: XOR<VeiculosCreateInput, VeiculosUncheckedCreateInput>
    /**
     * In case the Veiculos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VeiculosUpdateInput, VeiculosUncheckedUpdateInput>
  }

  /**
   * Veiculos delete
   */
  export type VeiculosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Veiculos
     */
    select?: VeiculosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Veiculos
     */
    omit?: VeiculosOmit<ExtArgs> | null
    /**
     * Filter which Veiculos to delete.
     */
    where: VeiculosWhereUniqueInput
  }

  /**
   * Veiculos deleteMany
   */
  export type VeiculosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Veiculos to delete
     */
    where?: VeiculosWhereInput
    /**
     * Limit how many Veiculos to delete.
     */
    limit?: number
  }

  /**
   * Veiculos without action
   */
  export type VeiculosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Veiculos
     */
    select?: VeiculosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Veiculos
     */
    omit?: VeiculosOmit<ExtArgs> | null
  }


  /**
   * Model agenda_corridas
   */

  export type AggregateAgenda_corridas = {
    _count: Agenda_corridasCountAggregateOutputType | null
    _avg: Agenda_corridasAvgAggregateOutputType | null
    _sum: Agenda_corridasSumAggregateOutputType | null
    _min: Agenda_corridasMinAggregateOutputType | null
    _max: Agenda_corridasMaxAggregateOutputType | null
  }

  export type Agenda_corridasAvgAggregateOutputType = {
    id: number | null
    passageiro_id: number | null
    motorista_id: number | null
    valor_previsto: number | null
  }

  export type Agenda_corridasSumAggregateOutputType = {
    id: number | null
    passageiro_id: number | null
    motorista_id: number | null
    valor_previsto: number | null
  }

  export type Agenda_corridasMinAggregateOutputType = {
    id: number | null
    passageiro_id: number | null
    categoria: $Enums.enum_agenda_corridas_categoria | null
    endereco_origem: string | null
    endereco_destino: string | null
    data_hora: Date | null
    status: $Enums.enum_agenda_corridas_status | null
    motorista_id: number | null
    valor_previsto: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Agenda_corridasMaxAggregateOutputType = {
    id: number | null
    passageiro_id: number | null
    categoria: $Enums.enum_agenda_corridas_categoria | null
    endereco_origem: string | null
    endereco_destino: string | null
    data_hora: Date | null
    status: $Enums.enum_agenda_corridas_status | null
    motorista_id: number | null
    valor_previsto: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Agenda_corridasCountAggregateOutputType = {
    id: number
    passageiro_id: number
    categoria: number
    endereco_origem: number
    endereco_destino: number
    data_hora: number
    status: number
    motorista_id: number
    valor_previsto: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Agenda_corridasAvgAggregateInputType = {
    id?: true
    passageiro_id?: true
    motorista_id?: true
    valor_previsto?: true
  }

  export type Agenda_corridasSumAggregateInputType = {
    id?: true
    passageiro_id?: true
    motorista_id?: true
    valor_previsto?: true
  }

  export type Agenda_corridasMinAggregateInputType = {
    id?: true
    passageiro_id?: true
    categoria?: true
    endereco_origem?: true
    endereco_destino?: true
    data_hora?: true
    status?: true
    motorista_id?: true
    valor_previsto?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Agenda_corridasMaxAggregateInputType = {
    id?: true
    passageiro_id?: true
    categoria?: true
    endereco_origem?: true
    endereco_destino?: true
    data_hora?: true
    status?: true
    motorista_id?: true
    valor_previsto?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Agenda_corridasCountAggregateInputType = {
    id?: true
    passageiro_id?: true
    categoria?: true
    endereco_origem?: true
    endereco_destino?: true
    data_hora?: true
    status?: true
    motorista_id?: true
    valor_previsto?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Agenda_corridasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which agenda_corridas to aggregate.
     */
    where?: agenda_corridasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agenda_corridas to fetch.
     */
    orderBy?: agenda_corridasOrderByWithRelationInput | agenda_corridasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: agenda_corridasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agenda_corridas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agenda_corridas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned agenda_corridas
    **/
    _count?: true | Agenda_corridasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Agenda_corridasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Agenda_corridasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Agenda_corridasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Agenda_corridasMaxAggregateInputType
  }

  export type GetAgenda_corridasAggregateType<T extends Agenda_corridasAggregateArgs> = {
        [P in keyof T & keyof AggregateAgenda_corridas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgenda_corridas[P]>
      : GetScalarType<T[P], AggregateAgenda_corridas[P]>
  }




  export type agenda_corridasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: agenda_corridasWhereInput
    orderBy?: agenda_corridasOrderByWithAggregationInput | agenda_corridasOrderByWithAggregationInput[]
    by: Agenda_corridasScalarFieldEnum[] | Agenda_corridasScalarFieldEnum
    having?: agenda_corridasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Agenda_corridasCountAggregateInputType | true
    _avg?: Agenda_corridasAvgAggregateInputType
    _sum?: Agenda_corridasSumAggregateInputType
    _min?: Agenda_corridasMinAggregateInputType
    _max?: Agenda_corridasMaxAggregateInputType
  }

  export type Agenda_corridasGroupByOutputType = {
    id: number
    passageiro_id: number
    categoria: $Enums.enum_agenda_corridas_categoria
    endereco_origem: string
    endereco_destino: string
    data_hora: Date
    status: $Enums.enum_agenda_corridas_status | null
    motorista_id: number | null
    valor_previsto: number | null
    createdAt: Date
    updatedAt: Date
    _count: Agenda_corridasCountAggregateOutputType | null
    _avg: Agenda_corridasAvgAggregateOutputType | null
    _sum: Agenda_corridasSumAggregateOutputType | null
    _min: Agenda_corridasMinAggregateOutputType | null
    _max: Agenda_corridasMaxAggregateOutputType | null
  }

  type GetAgenda_corridasGroupByPayload<T extends agenda_corridasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Agenda_corridasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Agenda_corridasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Agenda_corridasGroupByOutputType[P]>
            : GetScalarType<T[P], Agenda_corridasGroupByOutputType[P]>
        }
      >
    >


  export type agenda_corridasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    passageiro_id?: boolean
    categoria?: boolean
    endereco_origem?: boolean
    endereco_destino?: boolean
    data_hora?: boolean
    status?: boolean
    motorista_id?: boolean
    valor_previsto?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["agenda_corridas"]>

  export type agenda_corridasSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    passageiro_id?: boolean
    categoria?: boolean
    endereco_origem?: boolean
    endereco_destino?: boolean
    data_hora?: boolean
    status?: boolean
    motorista_id?: boolean
    valor_previsto?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["agenda_corridas"]>

  export type agenda_corridasSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    passageiro_id?: boolean
    categoria?: boolean
    endereco_origem?: boolean
    endereco_destino?: boolean
    data_hora?: boolean
    status?: boolean
    motorista_id?: boolean
    valor_previsto?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["agenda_corridas"]>

  export type agenda_corridasSelectScalar = {
    id?: boolean
    passageiro_id?: boolean
    categoria?: boolean
    endereco_origem?: boolean
    endereco_destino?: boolean
    data_hora?: boolean
    status?: boolean
    motorista_id?: boolean
    valor_previsto?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type agenda_corridasOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "passageiro_id" | "categoria" | "endereco_origem" | "endereco_destino" | "data_hora" | "status" | "motorista_id" | "valor_previsto" | "createdAt" | "updatedAt", ExtArgs["result"]["agenda_corridas"]>

  export type $agenda_corridasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "agenda_corridas"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      passageiro_id: number
      categoria: $Enums.enum_agenda_corridas_categoria
      endereco_origem: string
      endereco_destino: string
      data_hora: Date
      status: $Enums.enum_agenda_corridas_status | null
      motorista_id: number | null
      valor_previsto: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["agenda_corridas"]>
    composites: {}
  }

  type agenda_corridasGetPayload<S extends boolean | null | undefined | agenda_corridasDefaultArgs> = $Result.GetResult<Prisma.$agenda_corridasPayload, S>

  type agenda_corridasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<agenda_corridasFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Agenda_corridasCountAggregateInputType | true
    }

  export interface agenda_corridasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['agenda_corridas'], meta: { name: 'agenda_corridas' } }
    /**
     * Find zero or one Agenda_corridas that matches the filter.
     * @param {agenda_corridasFindUniqueArgs} args - Arguments to find a Agenda_corridas
     * @example
     * // Get one Agenda_corridas
     * const agenda_corridas = await prisma.agenda_corridas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends agenda_corridasFindUniqueArgs>(args: SelectSubset<T, agenda_corridasFindUniqueArgs<ExtArgs>>): Prisma__agenda_corridasClient<$Result.GetResult<Prisma.$agenda_corridasPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Agenda_corridas that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {agenda_corridasFindUniqueOrThrowArgs} args - Arguments to find a Agenda_corridas
     * @example
     * // Get one Agenda_corridas
     * const agenda_corridas = await prisma.agenda_corridas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends agenda_corridasFindUniqueOrThrowArgs>(args: SelectSubset<T, agenda_corridasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__agenda_corridasClient<$Result.GetResult<Prisma.$agenda_corridasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agenda_corridas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agenda_corridasFindFirstArgs} args - Arguments to find a Agenda_corridas
     * @example
     * // Get one Agenda_corridas
     * const agenda_corridas = await prisma.agenda_corridas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends agenda_corridasFindFirstArgs>(args?: SelectSubset<T, agenda_corridasFindFirstArgs<ExtArgs>>): Prisma__agenda_corridasClient<$Result.GetResult<Prisma.$agenda_corridasPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agenda_corridas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agenda_corridasFindFirstOrThrowArgs} args - Arguments to find a Agenda_corridas
     * @example
     * // Get one Agenda_corridas
     * const agenda_corridas = await prisma.agenda_corridas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends agenda_corridasFindFirstOrThrowArgs>(args?: SelectSubset<T, agenda_corridasFindFirstOrThrowArgs<ExtArgs>>): Prisma__agenda_corridasClient<$Result.GetResult<Prisma.$agenda_corridasPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Agenda_corridas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agenda_corridasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Agenda_corridas
     * const agenda_corridas = await prisma.agenda_corridas.findMany()
     * 
     * // Get first 10 Agenda_corridas
     * const agenda_corridas = await prisma.agenda_corridas.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agenda_corridasWithIdOnly = await prisma.agenda_corridas.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends agenda_corridasFindManyArgs>(args?: SelectSubset<T, agenda_corridasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$agenda_corridasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Agenda_corridas.
     * @param {agenda_corridasCreateArgs} args - Arguments to create a Agenda_corridas.
     * @example
     * // Create one Agenda_corridas
     * const Agenda_corridas = await prisma.agenda_corridas.create({
     *   data: {
     *     // ... data to create a Agenda_corridas
     *   }
     * })
     * 
     */
    create<T extends agenda_corridasCreateArgs>(args: SelectSubset<T, agenda_corridasCreateArgs<ExtArgs>>): Prisma__agenda_corridasClient<$Result.GetResult<Prisma.$agenda_corridasPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Agenda_corridas.
     * @param {agenda_corridasCreateManyArgs} args - Arguments to create many Agenda_corridas.
     * @example
     * // Create many Agenda_corridas
     * const agenda_corridas = await prisma.agenda_corridas.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends agenda_corridasCreateManyArgs>(args?: SelectSubset<T, agenda_corridasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Agenda_corridas and returns the data saved in the database.
     * @param {agenda_corridasCreateManyAndReturnArgs} args - Arguments to create many Agenda_corridas.
     * @example
     * // Create many Agenda_corridas
     * const agenda_corridas = await prisma.agenda_corridas.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Agenda_corridas and only return the `id`
     * const agenda_corridasWithIdOnly = await prisma.agenda_corridas.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends agenda_corridasCreateManyAndReturnArgs>(args?: SelectSubset<T, agenda_corridasCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$agenda_corridasPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Agenda_corridas.
     * @param {agenda_corridasDeleteArgs} args - Arguments to delete one Agenda_corridas.
     * @example
     * // Delete one Agenda_corridas
     * const Agenda_corridas = await prisma.agenda_corridas.delete({
     *   where: {
     *     // ... filter to delete one Agenda_corridas
     *   }
     * })
     * 
     */
    delete<T extends agenda_corridasDeleteArgs>(args: SelectSubset<T, agenda_corridasDeleteArgs<ExtArgs>>): Prisma__agenda_corridasClient<$Result.GetResult<Prisma.$agenda_corridasPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Agenda_corridas.
     * @param {agenda_corridasUpdateArgs} args - Arguments to update one Agenda_corridas.
     * @example
     * // Update one Agenda_corridas
     * const agenda_corridas = await prisma.agenda_corridas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends agenda_corridasUpdateArgs>(args: SelectSubset<T, agenda_corridasUpdateArgs<ExtArgs>>): Prisma__agenda_corridasClient<$Result.GetResult<Prisma.$agenda_corridasPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Agenda_corridas.
     * @param {agenda_corridasDeleteManyArgs} args - Arguments to filter Agenda_corridas to delete.
     * @example
     * // Delete a few Agenda_corridas
     * const { count } = await prisma.agenda_corridas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends agenda_corridasDeleteManyArgs>(args?: SelectSubset<T, agenda_corridasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agenda_corridas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agenda_corridasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Agenda_corridas
     * const agenda_corridas = await prisma.agenda_corridas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends agenda_corridasUpdateManyArgs>(args: SelectSubset<T, agenda_corridasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agenda_corridas and returns the data updated in the database.
     * @param {agenda_corridasUpdateManyAndReturnArgs} args - Arguments to update many Agenda_corridas.
     * @example
     * // Update many Agenda_corridas
     * const agenda_corridas = await prisma.agenda_corridas.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Agenda_corridas and only return the `id`
     * const agenda_corridasWithIdOnly = await prisma.agenda_corridas.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends agenda_corridasUpdateManyAndReturnArgs>(args: SelectSubset<T, agenda_corridasUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$agenda_corridasPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Agenda_corridas.
     * @param {agenda_corridasUpsertArgs} args - Arguments to update or create a Agenda_corridas.
     * @example
     * // Update or create a Agenda_corridas
     * const agenda_corridas = await prisma.agenda_corridas.upsert({
     *   create: {
     *     // ... data to create a Agenda_corridas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Agenda_corridas we want to update
     *   }
     * })
     */
    upsert<T extends agenda_corridasUpsertArgs>(args: SelectSubset<T, agenda_corridasUpsertArgs<ExtArgs>>): Prisma__agenda_corridasClient<$Result.GetResult<Prisma.$agenda_corridasPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Agenda_corridas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agenda_corridasCountArgs} args - Arguments to filter Agenda_corridas to count.
     * @example
     * // Count the number of Agenda_corridas
     * const count = await prisma.agenda_corridas.count({
     *   where: {
     *     // ... the filter for the Agenda_corridas we want to count
     *   }
     * })
    **/
    count<T extends agenda_corridasCountArgs>(
      args?: Subset<T, agenda_corridasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Agenda_corridasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Agenda_corridas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Agenda_corridasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Agenda_corridasAggregateArgs>(args: Subset<T, Agenda_corridasAggregateArgs>): Prisma.PrismaPromise<GetAgenda_corridasAggregateType<T>>

    /**
     * Group by Agenda_corridas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agenda_corridasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends agenda_corridasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: agenda_corridasGroupByArgs['orderBy'] }
        : { orderBy?: agenda_corridasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, agenda_corridasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgenda_corridasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the agenda_corridas model
   */
  readonly fields: agenda_corridasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for agenda_corridas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__agenda_corridasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the agenda_corridas model
   */
  interface agenda_corridasFieldRefs {
    readonly id: FieldRef<"agenda_corridas", 'Int'>
    readonly passageiro_id: FieldRef<"agenda_corridas", 'Int'>
    readonly categoria: FieldRef<"agenda_corridas", 'enum_agenda_corridas_categoria'>
    readonly endereco_origem: FieldRef<"agenda_corridas", 'String'>
    readonly endereco_destino: FieldRef<"agenda_corridas", 'String'>
    readonly data_hora: FieldRef<"agenda_corridas", 'DateTime'>
    readonly status: FieldRef<"agenda_corridas", 'enum_agenda_corridas_status'>
    readonly motorista_id: FieldRef<"agenda_corridas", 'Int'>
    readonly valor_previsto: FieldRef<"agenda_corridas", 'Float'>
    readonly createdAt: FieldRef<"agenda_corridas", 'DateTime'>
    readonly updatedAt: FieldRef<"agenda_corridas", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * agenda_corridas findUnique
   */
  export type agenda_corridasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agenda_corridas
     */
    select?: agenda_corridasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agenda_corridas
     */
    omit?: agenda_corridasOmit<ExtArgs> | null
    /**
     * Filter, which agenda_corridas to fetch.
     */
    where: agenda_corridasWhereUniqueInput
  }

  /**
   * agenda_corridas findUniqueOrThrow
   */
  export type agenda_corridasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agenda_corridas
     */
    select?: agenda_corridasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agenda_corridas
     */
    omit?: agenda_corridasOmit<ExtArgs> | null
    /**
     * Filter, which agenda_corridas to fetch.
     */
    where: agenda_corridasWhereUniqueInput
  }

  /**
   * agenda_corridas findFirst
   */
  export type agenda_corridasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agenda_corridas
     */
    select?: agenda_corridasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agenda_corridas
     */
    omit?: agenda_corridasOmit<ExtArgs> | null
    /**
     * Filter, which agenda_corridas to fetch.
     */
    where?: agenda_corridasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agenda_corridas to fetch.
     */
    orderBy?: agenda_corridasOrderByWithRelationInput | agenda_corridasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for agenda_corridas.
     */
    cursor?: agenda_corridasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agenda_corridas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agenda_corridas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of agenda_corridas.
     */
    distinct?: Agenda_corridasScalarFieldEnum | Agenda_corridasScalarFieldEnum[]
  }

  /**
   * agenda_corridas findFirstOrThrow
   */
  export type agenda_corridasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agenda_corridas
     */
    select?: agenda_corridasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agenda_corridas
     */
    omit?: agenda_corridasOmit<ExtArgs> | null
    /**
     * Filter, which agenda_corridas to fetch.
     */
    where?: agenda_corridasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agenda_corridas to fetch.
     */
    orderBy?: agenda_corridasOrderByWithRelationInput | agenda_corridasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for agenda_corridas.
     */
    cursor?: agenda_corridasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agenda_corridas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agenda_corridas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of agenda_corridas.
     */
    distinct?: Agenda_corridasScalarFieldEnum | Agenda_corridasScalarFieldEnum[]
  }

  /**
   * agenda_corridas findMany
   */
  export type agenda_corridasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agenda_corridas
     */
    select?: agenda_corridasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agenda_corridas
     */
    omit?: agenda_corridasOmit<ExtArgs> | null
    /**
     * Filter, which agenda_corridas to fetch.
     */
    where?: agenda_corridasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agenda_corridas to fetch.
     */
    orderBy?: agenda_corridasOrderByWithRelationInput | agenda_corridasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing agenda_corridas.
     */
    cursor?: agenda_corridasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agenda_corridas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agenda_corridas.
     */
    skip?: number
    distinct?: Agenda_corridasScalarFieldEnum | Agenda_corridasScalarFieldEnum[]
  }

  /**
   * agenda_corridas create
   */
  export type agenda_corridasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agenda_corridas
     */
    select?: agenda_corridasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agenda_corridas
     */
    omit?: agenda_corridasOmit<ExtArgs> | null
    /**
     * The data needed to create a agenda_corridas.
     */
    data: XOR<agenda_corridasCreateInput, agenda_corridasUncheckedCreateInput>
  }

  /**
   * agenda_corridas createMany
   */
  export type agenda_corridasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many agenda_corridas.
     */
    data: agenda_corridasCreateManyInput | agenda_corridasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * agenda_corridas createManyAndReturn
   */
  export type agenda_corridasCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agenda_corridas
     */
    select?: agenda_corridasSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the agenda_corridas
     */
    omit?: agenda_corridasOmit<ExtArgs> | null
    /**
     * The data used to create many agenda_corridas.
     */
    data: agenda_corridasCreateManyInput | agenda_corridasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * agenda_corridas update
   */
  export type agenda_corridasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agenda_corridas
     */
    select?: agenda_corridasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agenda_corridas
     */
    omit?: agenda_corridasOmit<ExtArgs> | null
    /**
     * The data needed to update a agenda_corridas.
     */
    data: XOR<agenda_corridasUpdateInput, agenda_corridasUncheckedUpdateInput>
    /**
     * Choose, which agenda_corridas to update.
     */
    where: agenda_corridasWhereUniqueInput
  }

  /**
   * agenda_corridas updateMany
   */
  export type agenda_corridasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update agenda_corridas.
     */
    data: XOR<agenda_corridasUpdateManyMutationInput, agenda_corridasUncheckedUpdateManyInput>
    /**
     * Filter which agenda_corridas to update
     */
    where?: agenda_corridasWhereInput
    /**
     * Limit how many agenda_corridas to update.
     */
    limit?: number
  }

  /**
   * agenda_corridas updateManyAndReturn
   */
  export type agenda_corridasUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agenda_corridas
     */
    select?: agenda_corridasSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the agenda_corridas
     */
    omit?: agenda_corridasOmit<ExtArgs> | null
    /**
     * The data used to update agenda_corridas.
     */
    data: XOR<agenda_corridasUpdateManyMutationInput, agenda_corridasUncheckedUpdateManyInput>
    /**
     * Filter which agenda_corridas to update
     */
    where?: agenda_corridasWhereInput
    /**
     * Limit how many agenda_corridas to update.
     */
    limit?: number
  }

  /**
   * agenda_corridas upsert
   */
  export type agenda_corridasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agenda_corridas
     */
    select?: agenda_corridasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agenda_corridas
     */
    omit?: agenda_corridasOmit<ExtArgs> | null
    /**
     * The filter to search for the agenda_corridas to update in case it exists.
     */
    where: agenda_corridasWhereUniqueInput
    /**
     * In case the agenda_corridas found by the `where` argument doesn't exist, create a new agenda_corridas with this data.
     */
    create: XOR<agenda_corridasCreateInput, agenda_corridasUncheckedCreateInput>
    /**
     * In case the agenda_corridas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<agenda_corridasUpdateInput, agenda_corridasUncheckedUpdateInput>
  }

  /**
   * agenda_corridas delete
   */
  export type agenda_corridasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agenda_corridas
     */
    select?: agenda_corridasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agenda_corridas
     */
    omit?: agenda_corridasOmit<ExtArgs> | null
    /**
     * Filter which agenda_corridas to delete.
     */
    where: agenda_corridasWhereUniqueInput
  }

  /**
   * agenda_corridas deleteMany
   */
  export type agenda_corridasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which agenda_corridas to delete
     */
    where?: agenda_corridasWhereInput
    /**
     * Limit how many agenda_corridas to delete.
     */
    limit?: number
  }

  /**
   * agenda_corridas without action
   */
  export type agenda_corridasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agenda_corridas
     */
    select?: agenda_corridasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agenda_corridas
     */
    omit?: agenda_corridasOmit<ExtArgs> | null
  }


  /**
   * Model avaliacoes
   */

  export type AggregateAvaliacoes = {
    _count: AvaliacoesCountAggregateOutputType | null
    _avg: AvaliacoesAvgAggregateOutputType | null
    _sum: AvaliacoesSumAggregateOutputType | null
    _min: AvaliacoesMinAggregateOutputType | null
    _max: AvaliacoesMaxAggregateOutputType | null
  }

  export type AvaliacoesAvgAggregateOutputType = {
    id: number | null
    avaliador_id: number | null
    avaliado_id: number | null
    nota: number | null
  }

  export type AvaliacoesSumAggregateOutputType = {
    id: number | null
    avaliador_id: number | null
    avaliado_id: number | null
    nota: number | null
  }

  export type AvaliacoesMinAggregateOutputType = {
    id: number | null
    avaliador_id: number | null
    avaliado_id: number | null
    tipo: $Enums.enum_avaliacoes_tipo | null
    nota: number | null
    comentario: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AvaliacoesMaxAggregateOutputType = {
    id: number | null
    avaliador_id: number | null
    avaliado_id: number | null
    tipo: $Enums.enum_avaliacoes_tipo | null
    nota: number | null
    comentario: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AvaliacoesCountAggregateOutputType = {
    id: number
    avaliador_id: number
    avaliado_id: number
    tipo: number
    nota: number
    comentario: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AvaliacoesAvgAggregateInputType = {
    id?: true
    avaliador_id?: true
    avaliado_id?: true
    nota?: true
  }

  export type AvaliacoesSumAggregateInputType = {
    id?: true
    avaliador_id?: true
    avaliado_id?: true
    nota?: true
  }

  export type AvaliacoesMinAggregateInputType = {
    id?: true
    avaliador_id?: true
    avaliado_id?: true
    tipo?: true
    nota?: true
    comentario?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AvaliacoesMaxAggregateInputType = {
    id?: true
    avaliador_id?: true
    avaliado_id?: true
    tipo?: true
    nota?: true
    comentario?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AvaliacoesCountAggregateInputType = {
    id?: true
    avaliador_id?: true
    avaliado_id?: true
    tipo?: true
    nota?: true
    comentario?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AvaliacoesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which avaliacoes to aggregate.
     */
    where?: avaliacoesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of avaliacoes to fetch.
     */
    orderBy?: avaliacoesOrderByWithRelationInput | avaliacoesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: avaliacoesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` avaliacoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` avaliacoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned avaliacoes
    **/
    _count?: true | AvaliacoesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AvaliacoesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AvaliacoesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AvaliacoesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AvaliacoesMaxAggregateInputType
  }

  export type GetAvaliacoesAggregateType<T extends AvaliacoesAggregateArgs> = {
        [P in keyof T & keyof AggregateAvaliacoes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAvaliacoes[P]>
      : GetScalarType<T[P], AggregateAvaliacoes[P]>
  }




  export type avaliacoesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: avaliacoesWhereInput
    orderBy?: avaliacoesOrderByWithAggregationInput | avaliacoesOrderByWithAggregationInput[]
    by: AvaliacoesScalarFieldEnum[] | AvaliacoesScalarFieldEnum
    having?: avaliacoesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AvaliacoesCountAggregateInputType | true
    _avg?: AvaliacoesAvgAggregateInputType
    _sum?: AvaliacoesSumAggregateInputType
    _min?: AvaliacoesMinAggregateInputType
    _max?: AvaliacoesMaxAggregateInputType
  }

  export type AvaliacoesGroupByOutputType = {
    id: number
    avaliador_id: number
    avaliado_id: number
    tipo: $Enums.enum_avaliacoes_tipo
    nota: number
    comentario: string | null
    createdAt: Date
    updatedAt: Date
    _count: AvaliacoesCountAggregateOutputType | null
    _avg: AvaliacoesAvgAggregateOutputType | null
    _sum: AvaliacoesSumAggregateOutputType | null
    _min: AvaliacoesMinAggregateOutputType | null
    _max: AvaliacoesMaxAggregateOutputType | null
  }

  type GetAvaliacoesGroupByPayload<T extends avaliacoesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AvaliacoesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AvaliacoesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AvaliacoesGroupByOutputType[P]>
            : GetScalarType<T[P], AvaliacoesGroupByOutputType[P]>
        }
      >
    >


  export type avaliacoesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    avaliador_id?: boolean
    avaliado_id?: boolean
    tipo?: boolean
    nota?: boolean
    comentario?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["avaliacoes"]>

  export type avaliacoesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    avaliador_id?: boolean
    avaliado_id?: boolean
    tipo?: boolean
    nota?: boolean
    comentario?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["avaliacoes"]>

  export type avaliacoesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    avaliador_id?: boolean
    avaliado_id?: boolean
    tipo?: boolean
    nota?: boolean
    comentario?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["avaliacoes"]>

  export type avaliacoesSelectScalar = {
    id?: boolean
    avaliador_id?: boolean
    avaliado_id?: boolean
    tipo?: boolean
    nota?: boolean
    comentario?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type avaliacoesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "avaliador_id" | "avaliado_id" | "tipo" | "nota" | "comentario" | "createdAt" | "updatedAt", ExtArgs["result"]["avaliacoes"]>

  export type $avaliacoesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "avaliacoes"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      avaliador_id: number
      avaliado_id: number
      tipo: $Enums.enum_avaliacoes_tipo
      nota: number
      comentario: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["avaliacoes"]>
    composites: {}
  }

  type avaliacoesGetPayload<S extends boolean | null | undefined | avaliacoesDefaultArgs> = $Result.GetResult<Prisma.$avaliacoesPayload, S>

  type avaliacoesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<avaliacoesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AvaliacoesCountAggregateInputType | true
    }

  export interface avaliacoesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['avaliacoes'], meta: { name: 'avaliacoes' } }
    /**
     * Find zero or one Avaliacoes that matches the filter.
     * @param {avaliacoesFindUniqueArgs} args - Arguments to find a Avaliacoes
     * @example
     * // Get one Avaliacoes
     * const avaliacoes = await prisma.avaliacoes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends avaliacoesFindUniqueArgs>(args: SelectSubset<T, avaliacoesFindUniqueArgs<ExtArgs>>): Prisma__avaliacoesClient<$Result.GetResult<Prisma.$avaliacoesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Avaliacoes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {avaliacoesFindUniqueOrThrowArgs} args - Arguments to find a Avaliacoes
     * @example
     * // Get one Avaliacoes
     * const avaliacoes = await prisma.avaliacoes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends avaliacoesFindUniqueOrThrowArgs>(args: SelectSubset<T, avaliacoesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__avaliacoesClient<$Result.GetResult<Prisma.$avaliacoesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Avaliacoes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {avaliacoesFindFirstArgs} args - Arguments to find a Avaliacoes
     * @example
     * // Get one Avaliacoes
     * const avaliacoes = await prisma.avaliacoes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends avaliacoesFindFirstArgs>(args?: SelectSubset<T, avaliacoesFindFirstArgs<ExtArgs>>): Prisma__avaliacoesClient<$Result.GetResult<Prisma.$avaliacoesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Avaliacoes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {avaliacoesFindFirstOrThrowArgs} args - Arguments to find a Avaliacoes
     * @example
     * // Get one Avaliacoes
     * const avaliacoes = await prisma.avaliacoes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends avaliacoesFindFirstOrThrowArgs>(args?: SelectSubset<T, avaliacoesFindFirstOrThrowArgs<ExtArgs>>): Prisma__avaliacoesClient<$Result.GetResult<Prisma.$avaliacoesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Avaliacoes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {avaliacoesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Avaliacoes
     * const avaliacoes = await prisma.avaliacoes.findMany()
     * 
     * // Get first 10 Avaliacoes
     * const avaliacoes = await prisma.avaliacoes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const avaliacoesWithIdOnly = await prisma.avaliacoes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends avaliacoesFindManyArgs>(args?: SelectSubset<T, avaliacoesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$avaliacoesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Avaliacoes.
     * @param {avaliacoesCreateArgs} args - Arguments to create a Avaliacoes.
     * @example
     * // Create one Avaliacoes
     * const Avaliacoes = await prisma.avaliacoes.create({
     *   data: {
     *     // ... data to create a Avaliacoes
     *   }
     * })
     * 
     */
    create<T extends avaliacoesCreateArgs>(args: SelectSubset<T, avaliacoesCreateArgs<ExtArgs>>): Prisma__avaliacoesClient<$Result.GetResult<Prisma.$avaliacoesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Avaliacoes.
     * @param {avaliacoesCreateManyArgs} args - Arguments to create many Avaliacoes.
     * @example
     * // Create many Avaliacoes
     * const avaliacoes = await prisma.avaliacoes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends avaliacoesCreateManyArgs>(args?: SelectSubset<T, avaliacoesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Avaliacoes and returns the data saved in the database.
     * @param {avaliacoesCreateManyAndReturnArgs} args - Arguments to create many Avaliacoes.
     * @example
     * // Create many Avaliacoes
     * const avaliacoes = await prisma.avaliacoes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Avaliacoes and only return the `id`
     * const avaliacoesWithIdOnly = await prisma.avaliacoes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends avaliacoesCreateManyAndReturnArgs>(args?: SelectSubset<T, avaliacoesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$avaliacoesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Avaliacoes.
     * @param {avaliacoesDeleteArgs} args - Arguments to delete one Avaliacoes.
     * @example
     * // Delete one Avaliacoes
     * const Avaliacoes = await prisma.avaliacoes.delete({
     *   where: {
     *     // ... filter to delete one Avaliacoes
     *   }
     * })
     * 
     */
    delete<T extends avaliacoesDeleteArgs>(args: SelectSubset<T, avaliacoesDeleteArgs<ExtArgs>>): Prisma__avaliacoesClient<$Result.GetResult<Prisma.$avaliacoesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Avaliacoes.
     * @param {avaliacoesUpdateArgs} args - Arguments to update one Avaliacoes.
     * @example
     * // Update one Avaliacoes
     * const avaliacoes = await prisma.avaliacoes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends avaliacoesUpdateArgs>(args: SelectSubset<T, avaliacoesUpdateArgs<ExtArgs>>): Prisma__avaliacoesClient<$Result.GetResult<Prisma.$avaliacoesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Avaliacoes.
     * @param {avaliacoesDeleteManyArgs} args - Arguments to filter Avaliacoes to delete.
     * @example
     * // Delete a few Avaliacoes
     * const { count } = await prisma.avaliacoes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends avaliacoesDeleteManyArgs>(args?: SelectSubset<T, avaliacoesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Avaliacoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {avaliacoesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Avaliacoes
     * const avaliacoes = await prisma.avaliacoes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends avaliacoesUpdateManyArgs>(args: SelectSubset<T, avaliacoesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Avaliacoes and returns the data updated in the database.
     * @param {avaliacoesUpdateManyAndReturnArgs} args - Arguments to update many Avaliacoes.
     * @example
     * // Update many Avaliacoes
     * const avaliacoes = await prisma.avaliacoes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Avaliacoes and only return the `id`
     * const avaliacoesWithIdOnly = await prisma.avaliacoes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends avaliacoesUpdateManyAndReturnArgs>(args: SelectSubset<T, avaliacoesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$avaliacoesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Avaliacoes.
     * @param {avaliacoesUpsertArgs} args - Arguments to update or create a Avaliacoes.
     * @example
     * // Update or create a Avaliacoes
     * const avaliacoes = await prisma.avaliacoes.upsert({
     *   create: {
     *     // ... data to create a Avaliacoes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Avaliacoes we want to update
     *   }
     * })
     */
    upsert<T extends avaliacoesUpsertArgs>(args: SelectSubset<T, avaliacoesUpsertArgs<ExtArgs>>): Prisma__avaliacoesClient<$Result.GetResult<Prisma.$avaliacoesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Avaliacoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {avaliacoesCountArgs} args - Arguments to filter Avaliacoes to count.
     * @example
     * // Count the number of Avaliacoes
     * const count = await prisma.avaliacoes.count({
     *   where: {
     *     // ... the filter for the Avaliacoes we want to count
     *   }
     * })
    **/
    count<T extends avaliacoesCountArgs>(
      args?: Subset<T, avaliacoesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AvaliacoesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Avaliacoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvaliacoesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AvaliacoesAggregateArgs>(args: Subset<T, AvaliacoesAggregateArgs>): Prisma.PrismaPromise<GetAvaliacoesAggregateType<T>>

    /**
     * Group by Avaliacoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {avaliacoesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends avaliacoesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: avaliacoesGroupByArgs['orderBy'] }
        : { orderBy?: avaliacoesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, avaliacoesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAvaliacoesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the avaliacoes model
   */
  readonly fields: avaliacoesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for avaliacoes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__avaliacoesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the avaliacoes model
   */
  interface avaliacoesFieldRefs {
    readonly id: FieldRef<"avaliacoes", 'Int'>
    readonly avaliador_id: FieldRef<"avaliacoes", 'Int'>
    readonly avaliado_id: FieldRef<"avaliacoes", 'Int'>
    readonly tipo: FieldRef<"avaliacoes", 'enum_avaliacoes_tipo'>
    readonly nota: FieldRef<"avaliacoes", 'Float'>
    readonly comentario: FieldRef<"avaliacoes", 'String'>
    readonly createdAt: FieldRef<"avaliacoes", 'DateTime'>
    readonly updatedAt: FieldRef<"avaliacoes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * avaliacoes findUnique
   */
  export type avaliacoesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the avaliacoes
     */
    select?: avaliacoesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the avaliacoes
     */
    omit?: avaliacoesOmit<ExtArgs> | null
    /**
     * Filter, which avaliacoes to fetch.
     */
    where: avaliacoesWhereUniqueInput
  }

  /**
   * avaliacoes findUniqueOrThrow
   */
  export type avaliacoesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the avaliacoes
     */
    select?: avaliacoesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the avaliacoes
     */
    omit?: avaliacoesOmit<ExtArgs> | null
    /**
     * Filter, which avaliacoes to fetch.
     */
    where: avaliacoesWhereUniqueInput
  }

  /**
   * avaliacoes findFirst
   */
  export type avaliacoesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the avaliacoes
     */
    select?: avaliacoesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the avaliacoes
     */
    omit?: avaliacoesOmit<ExtArgs> | null
    /**
     * Filter, which avaliacoes to fetch.
     */
    where?: avaliacoesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of avaliacoes to fetch.
     */
    orderBy?: avaliacoesOrderByWithRelationInput | avaliacoesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for avaliacoes.
     */
    cursor?: avaliacoesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` avaliacoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` avaliacoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of avaliacoes.
     */
    distinct?: AvaliacoesScalarFieldEnum | AvaliacoesScalarFieldEnum[]
  }

  /**
   * avaliacoes findFirstOrThrow
   */
  export type avaliacoesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the avaliacoes
     */
    select?: avaliacoesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the avaliacoes
     */
    omit?: avaliacoesOmit<ExtArgs> | null
    /**
     * Filter, which avaliacoes to fetch.
     */
    where?: avaliacoesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of avaliacoes to fetch.
     */
    orderBy?: avaliacoesOrderByWithRelationInput | avaliacoesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for avaliacoes.
     */
    cursor?: avaliacoesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` avaliacoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` avaliacoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of avaliacoes.
     */
    distinct?: AvaliacoesScalarFieldEnum | AvaliacoesScalarFieldEnum[]
  }

  /**
   * avaliacoes findMany
   */
  export type avaliacoesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the avaliacoes
     */
    select?: avaliacoesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the avaliacoes
     */
    omit?: avaliacoesOmit<ExtArgs> | null
    /**
     * Filter, which avaliacoes to fetch.
     */
    where?: avaliacoesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of avaliacoes to fetch.
     */
    orderBy?: avaliacoesOrderByWithRelationInput | avaliacoesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing avaliacoes.
     */
    cursor?: avaliacoesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` avaliacoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` avaliacoes.
     */
    skip?: number
    distinct?: AvaliacoesScalarFieldEnum | AvaliacoesScalarFieldEnum[]
  }

  /**
   * avaliacoes create
   */
  export type avaliacoesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the avaliacoes
     */
    select?: avaliacoesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the avaliacoes
     */
    omit?: avaliacoesOmit<ExtArgs> | null
    /**
     * The data needed to create a avaliacoes.
     */
    data: XOR<avaliacoesCreateInput, avaliacoesUncheckedCreateInput>
  }

  /**
   * avaliacoes createMany
   */
  export type avaliacoesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many avaliacoes.
     */
    data: avaliacoesCreateManyInput | avaliacoesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * avaliacoes createManyAndReturn
   */
  export type avaliacoesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the avaliacoes
     */
    select?: avaliacoesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the avaliacoes
     */
    omit?: avaliacoesOmit<ExtArgs> | null
    /**
     * The data used to create many avaliacoes.
     */
    data: avaliacoesCreateManyInput | avaliacoesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * avaliacoes update
   */
  export type avaliacoesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the avaliacoes
     */
    select?: avaliacoesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the avaliacoes
     */
    omit?: avaliacoesOmit<ExtArgs> | null
    /**
     * The data needed to update a avaliacoes.
     */
    data: XOR<avaliacoesUpdateInput, avaliacoesUncheckedUpdateInput>
    /**
     * Choose, which avaliacoes to update.
     */
    where: avaliacoesWhereUniqueInput
  }

  /**
   * avaliacoes updateMany
   */
  export type avaliacoesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update avaliacoes.
     */
    data: XOR<avaliacoesUpdateManyMutationInput, avaliacoesUncheckedUpdateManyInput>
    /**
     * Filter which avaliacoes to update
     */
    where?: avaliacoesWhereInput
    /**
     * Limit how many avaliacoes to update.
     */
    limit?: number
  }

  /**
   * avaliacoes updateManyAndReturn
   */
  export type avaliacoesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the avaliacoes
     */
    select?: avaliacoesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the avaliacoes
     */
    omit?: avaliacoesOmit<ExtArgs> | null
    /**
     * The data used to update avaliacoes.
     */
    data: XOR<avaliacoesUpdateManyMutationInput, avaliacoesUncheckedUpdateManyInput>
    /**
     * Filter which avaliacoes to update
     */
    where?: avaliacoesWhereInput
    /**
     * Limit how many avaliacoes to update.
     */
    limit?: number
  }

  /**
   * avaliacoes upsert
   */
  export type avaliacoesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the avaliacoes
     */
    select?: avaliacoesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the avaliacoes
     */
    omit?: avaliacoesOmit<ExtArgs> | null
    /**
     * The filter to search for the avaliacoes to update in case it exists.
     */
    where: avaliacoesWhereUniqueInput
    /**
     * In case the avaliacoes found by the `where` argument doesn't exist, create a new avaliacoes with this data.
     */
    create: XOR<avaliacoesCreateInput, avaliacoesUncheckedCreateInput>
    /**
     * In case the avaliacoes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<avaliacoesUpdateInput, avaliacoesUncheckedUpdateInput>
  }

  /**
   * avaliacoes delete
   */
  export type avaliacoesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the avaliacoes
     */
    select?: avaliacoesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the avaliacoes
     */
    omit?: avaliacoesOmit<ExtArgs> | null
    /**
     * Filter which avaliacoes to delete.
     */
    where: avaliacoesWhereUniqueInput
  }

  /**
   * avaliacoes deleteMany
   */
  export type avaliacoesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which avaliacoes to delete
     */
    where?: avaliacoesWhereInput
    /**
     * Limit how many avaliacoes to delete.
     */
    limit?: number
  }

  /**
   * avaliacoes without action
   */
  export type avaliacoesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the avaliacoes
     */
    select?: avaliacoesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the avaliacoes
     */
    omit?: avaliacoesOmit<ExtArgs> | null
  }


  /**
   * Model bairros_prioridade
   */

  export type AggregateBairros_prioridade = {
    _count: Bairros_prioridadeCountAggregateOutputType | null
    _avg: Bairros_prioridadeAvgAggregateOutputType | null
    _sum: Bairros_prioridadeSumAggregateOutputType | null
    _min: Bairros_prioridadeMinAggregateOutputType | null
    _max: Bairros_prioridadeMaxAggregateOutputType | null
  }

  export type Bairros_prioridadeAvgAggregateOutputType = {
    id: number | null
  }

  export type Bairros_prioridadeSumAggregateOutputType = {
    id: number | null
  }

  export type Bairros_prioridadeMinAggregateOutputType = {
    id: number | null
    nome: string | null
    cidade: string | null
    estado: string | null
    ativo: boolean | null
    tipo_prioridade: $Enums.enum_bairros_prioridade_tipo_prioridade | null
    observacoes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Bairros_prioridadeMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    cidade: string | null
    estado: string | null
    ativo: boolean | null
    tipo_prioridade: $Enums.enum_bairros_prioridade_tipo_prioridade | null
    observacoes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Bairros_prioridadeCountAggregateOutputType = {
    id: number
    nome: number
    cidade: number
    estado: number
    ativo: number
    tipo_prioridade: number
    observacoes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Bairros_prioridadeAvgAggregateInputType = {
    id?: true
  }

  export type Bairros_prioridadeSumAggregateInputType = {
    id?: true
  }

  export type Bairros_prioridadeMinAggregateInputType = {
    id?: true
    nome?: true
    cidade?: true
    estado?: true
    ativo?: true
    tipo_prioridade?: true
    observacoes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Bairros_prioridadeMaxAggregateInputType = {
    id?: true
    nome?: true
    cidade?: true
    estado?: true
    ativo?: true
    tipo_prioridade?: true
    observacoes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Bairros_prioridadeCountAggregateInputType = {
    id?: true
    nome?: true
    cidade?: true
    estado?: true
    ativo?: true
    tipo_prioridade?: true
    observacoes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Bairros_prioridadeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bairros_prioridade to aggregate.
     */
    where?: bairros_prioridadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bairros_prioridades to fetch.
     */
    orderBy?: bairros_prioridadeOrderByWithRelationInput | bairros_prioridadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bairros_prioridadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bairros_prioridades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bairros_prioridades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bairros_prioridades
    **/
    _count?: true | Bairros_prioridadeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Bairros_prioridadeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Bairros_prioridadeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Bairros_prioridadeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Bairros_prioridadeMaxAggregateInputType
  }

  export type GetBairros_prioridadeAggregateType<T extends Bairros_prioridadeAggregateArgs> = {
        [P in keyof T & keyof AggregateBairros_prioridade]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBairros_prioridade[P]>
      : GetScalarType<T[P], AggregateBairros_prioridade[P]>
  }




  export type bairros_prioridadeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bairros_prioridadeWhereInput
    orderBy?: bairros_prioridadeOrderByWithAggregationInput | bairros_prioridadeOrderByWithAggregationInput[]
    by: Bairros_prioridadeScalarFieldEnum[] | Bairros_prioridadeScalarFieldEnum
    having?: bairros_prioridadeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Bairros_prioridadeCountAggregateInputType | true
    _avg?: Bairros_prioridadeAvgAggregateInputType
    _sum?: Bairros_prioridadeSumAggregateInputType
    _min?: Bairros_prioridadeMinAggregateInputType
    _max?: Bairros_prioridadeMaxAggregateInputType
  }

  export type Bairros_prioridadeGroupByOutputType = {
    id: number
    nome: string
    cidade: string
    estado: string
    ativo: boolean | null
    tipo_prioridade: $Enums.enum_bairros_prioridade_tipo_prioridade
    observacoes: string | null
    createdAt: Date
    updatedAt: Date
    _count: Bairros_prioridadeCountAggregateOutputType | null
    _avg: Bairros_prioridadeAvgAggregateOutputType | null
    _sum: Bairros_prioridadeSumAggregateOutputType | null
    _min: Bairros_prioridadeMinAggregateOutputType | null
    _max: Bairros_prioridadeMaxAggregateOutputType | null
  }

  type GetBairros_prioridadeGroupByPayload<T extends bairros_prioridadeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Bairros_prioridadeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Bairros_prioridadeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Bairros_prioridadeGroupByOutputType[P]>
            : GetScalarType<T[P], Bairros_prioridadeGroupByOutputType[P]>
        }
      >
    >


  export type bairros_prioridadeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    cidade?: boolean
    estado?: boolean
    ativo?: boolean
    tipo_prioridade?: boolean
    observacoes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["bairros_prioridade"]>

  export type bairros_prioridadeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    cidade?: boolean
    estado?: boolean
    ativo?: boolean
    tipo_prioridade?: boolean
    observacoes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["bairros_prioridade"]>

  export type bairros_prioridadeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    cidade?: boolean
    estado?: boolean
    ativo?: boolean
    tipo_prioridade?: boolean
    observacoes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["bairros_prioridade"]>

  export type bairros_prioridadeSelectScalar = {
    id?: boolean
    nome?: boolean
    cidade?: boolean
    estado?: boolean
    ativo?: boolean
    tipo_prioridade?: boolean
    observacoes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type bairros_prioridadeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nome" | "cidade" | "estado" | "ativo" | "tipo_prioridade" | "observacoes" | "createdAt" | "updatedAt", ExtArgs["result"]["bairros_prioridade"]>

  export type $bairros_prioridadePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bairros_prioridade"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      cidade: string
      estado: string
      ativo: boolean | null
      tipo_prioridade: $Enums.enum_bairros_prioridade_tipo_prioridade
      observacoes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bairros_prioridade"]>
    composites: {}
  }

  type bairros_prioridadeGetPayload<S extends boolean | null | undefined | bairros_prioridadeDefaultArgs> = $Result.GetResult<Prisma.$bairros_prioridadePayload, S>

  type bairros_prioridadeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<bairros_prioridadeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Bairros_prioridadeCountAggregateInputType | true
    }

  export interface bairros_prioridadeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bairros_prioridade'], meta: { name: 'bairros_prioridade' } }
    /**
     * Find zero or one Bairros_prioridade that matches the filter.
     * @param {bairros_prioridadeFindUniqueArgs} args - Arguments to find a Bairros_prioridade
     * @example
     * // Get one Bairros_prioridade
     * const bairros_prioridade = await prisma.bairros_prioridade.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends bairros_prioridadeFindUniqueArgs>(args: SelectSubset<T, bairros_prioridadeFindUniqueArgs<ExtArgs>>): Prisma__bairros_prioridadeClient<$Result.GetResult<Prisma.$bairros_prioridadePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Bairros_prioridade that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {bairros_prioridadeFindUniqueOrThrowArgs} args - Arguments to find a Bairros_prioridade
     * @example
     * // Get one Bairros_prioridade
     * const bairros_prioridade = await prisma.bairros_prioridade.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends bairros_prioridadeFindUniqueOrThrowArgs>(args: SelectSubset<T, bairros_prioridadeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__bairros_prioridadeClient<$Result.GetResult<Prisma.$bairros_prioridadePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bairros_prioridade that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bairros_prioridadeFindFirstArgs} args - Arguments to find a Bairros_prioridade
     * @example
     * // Get one Bairros_prioridade
     * const bairros_prioridade = await prisma.bairros_prioridade.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends bairros_prioridadeFindFirstArgs>(args?: SelectSubset<T, bairros_prioridadeFindFirstArgs<ExtArgs>>): Prisma__bairros_prioridadeClient<$Result.GetResult<Prisma.$bairros_prioridadePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bairros_prioridade that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bairros_prioridadeFindFirstOrThrowArgs} args - Arguments to find a Bairros_prioridade
     * @example
     * // Get one Bairros_prioridade
     * const bairros_prioridade = await prisma.bairros_prioridade.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends bairros_prioridadeFindFirstOrThrowArgs>(args?: SelectSubset<T, bairros_prioridadeFindFirstOrThrowArgs<ExtArgs>>): Prisma__bairros_prioridadeClient<$Result.GetResult<Prisma.$bairros_prioridadePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bairros_prioridades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bairros_prioridadeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bairros_prioridades
     * const bairros_prioridades = await prisma.bairros_prioridade.findMany()
     * 
     * // Get first 10 Bairros_prioridades
     * const bairros_prioridades = await prisma.bairros_prioridade.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bairros_prioridadeWithIdOnly = await prisma.bairros_prioridade.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends bairros_prioridadeFindManyArgs>(args?: SelectSubset<T, bairros_prioridadeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bairros_prioridadePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Bairros_prioridade.
     * @param {bairros_prioridadeCreateArgs} args - Arguments to create a Bairros_prioridade.
     * @example
     * // Create one Bairros_prioridade
     * const Bairros_prioridade = await prisma.bairros_prioridade.create({
     *   data: {
     *     // ... data to create a Bairros_prioridade
     *   }
     * })
     * 
     */
    create<T extends bairros_prioridadeCreateArgs>(args: SelectSubset<T, bairros_prioridadeCreateArgs<ExtArgs>>): Prisma__bairros_prioridadeClient<$Result.GetResult<Prisma.$bairros_prioridadePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bairros_prioridades.
     * @param {bairros_prioridadeCreateManyArgs} args - Arguments to create many Bairros_prioridades.
     * @example
     * // Create many Bairros_prioridades
     * const bairros_prioridade = await prisma.bairros_prioridade.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends bairros_prioridadeCreateManyArgs>(args?: SelectSubset<T, bairros_prioridadeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bairros_prioridades and returns the data saved in the database.
     * @param {bairros_prioridadeCreateManyAndReturnArgs} args - Arguments to create many Bairros_prioridades.
     * @example
     * // Create many Bairros_prioridades
     * const bairros_prioridade = await prisma.bairros_prioridade.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bairros_prioridades and only return the `id`
     * const bairros_prioridadeWithIdOnly = await prisma.bairros_prioridade.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends bairros_prioridadeCreateManyAndReturnArgs>(args?: SelectSubset<T, bairros_prioridadeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bairros_prioridadePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Bairros_prioridade.
     * @param {bairros_prioridadeDeleteArgs} args - Arguments to delete one Bairros_prioridade.
     * @example
     * // Delete one Bairros_prioridade
     * const Bairros_prioridade = await prisma.bairros_prioridade.delete({
     *   where: {
     *     // ... filter to delete one Bairros_prioridade
     *   }
     * })
     * 
     */
    delete<T extends bairros_prioridadeDeleteArgs>(args: SelectSubset<T, bairros_prioridadeDeleteArgs<ExtArgs>>): Prisma__bairros_prioridadeClient<$Result.GetResult<Prisma.$bairros_prioridadePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Bairros_prioridade.
     * @param {bairros_prioridadeUpdateArgs} args - Arguments to update one Bairros_prioridade.
     * @example
     * // Update one Bairros_prioridade
     * const bairros_prioridade = await prisma.bairros_prioridade.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends bairros_prioridadeUpdateArgs>(args: SelectSubset<T, bairros_prioridadeUpdateArgs<ExtArgs>>): Prisma__bairros_prioridadeClient<$Result.GetResult<Prisma.$bairros_prioridadePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bairros_prioridades.
     * @param {bairros_prioridadeDeleteManyArgs} args - Arguments to filter Bairros_prioridades to delete.
     * @example
     * // Delete a few Bairros_prioridades
     * const { count } = await prisma.bairros_prioridade.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends bairros_prioridadeDeleteManyArgs>(args?: SelectSubset<T, bairros_prioridadeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bairros_prioridades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bairros_prioridadeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bairros_prioridades
     * const bairros_prioridade = await prisma.bairros_prioridade.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends bairros_prioridadeUpdateManyArgs>(args: SelectSubset<T, bairros_prioridadeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bairros_prioridades and returns the data updated in the database.
     * @param {bairros_prioridadeUpdateManyAndReturnArgs} args - Arguments to update many Bairros_prioridades.
     * @example
     * // Update many Bairros_prioridades
     * const bairros_prioridade = await prisma.bairros_prioridade.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bairros_prioridades and only return the `id`
     * const bairros_prioridadeWithIdOnly = await prisma.bairros_prioridade.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends bairros_prioridadeUpdateManyAndReturnArgs>(args: SelectSubset<T, bairros_prioridadeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bairros_prioridadePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Bairros_prioridade.
     * @param {bairros_prioridadeUpsertArgs} args - Arguments to update or create a Bairros_prioridade.
     * @example
     * // Update or create a Bairros_prioridade
     * const bairros_prioridade = await prisma.bairros_prioridade.upsert({
     *   create: {
     *     // ... data to create a Bairros_prioridade
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bairros_prioridade we want to update
     *   }
     * })
     */
    upsert<T extends bairros_prioridadeUpsertArgs>(args: SelectSubset<T, bairros_prioridadeUpsertArgs<ExtArgs>>): Prisma__bairros_prioridadeClient<$Result.GetResult<Prisma.$bairros_prioridadePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bairros_prioridades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bairros_prioridadeCountArgs} args - Arguments to filter Bairros_prioridades to count.
     * @example
     * // Count the number of Bairros_prioridades
     * const count = await prisma.bairros_prioridade.count({
     *   where: {
     *     // ... the filter for the Bairros_prioridades we want to count
     *   }
     * })
    **/
    count<T extends bairros_prioridadeCountArgs>(
      args?: Subset<T, bairros_prioridadeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Bairros_prioridadeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bairros_prioridade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Bairros_prioridadeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Bairros_prioridadeAggregateArgs>(args: Subset<T, Bairros_prioridadeAggregateArgs>): Prisma.PrismaPromise<GetBairros_prioridadeAggregateType<T>>

    /**
     * Group by Bairros_prioridade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bairros_prioridadeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bairros_prioridadeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bairros_prioridadeGroupByArgs['orderBy'] }
        : { orderBy?: bairros_prioridadeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bairros_prioridadeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBairros_prioridadeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bairros_prioridade model
   */
  readonly fields: bairros_prioridadeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bairros_prioridade.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bairros_prioridadeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the bairros_prioridade model
   */
  interface bairros_prioridadeFieldRefs {
    readonly id: FieldRef<"bairros_prioridade", 'Int'>
    readonly nome: FieldRef<"bairros_prioridade", 'String'>
    readonly cidade: FieldRef<"bairros_prioridade", 'String'>
    readonly estado: FieldRef<"bairros_prioridade", 'String'>
    readonly ativo: FieldRef<"bairros_prioridade", 'Boolean'>
    readonly tipo_prioridade: FieldRef<"bairros_prioridade", 'enum_bairros_prioridade_tipo_prioridade'>
    readonly observacoes: FieldRef<"bairros_prioridade", 'String'>
    readonly createdAt: FieldRef<"bairros_prioridade", 'DateTime'>
    readonly updatedAt: FieldRef<"bairros_prioridade", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * bairros_prioridade findUnique
   */
  export type bairros_prioridadeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bairros_prioridade
     */
    select?: bairros_prioridadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bairros_prioridade
     */
    omit?: bairros_prioridadeOmit<ExtArgs> | null
    /**
     * Filter, which bairros_prioridade to fetch.
     */
    where: bairros_prioridadeWhereUniqueInput
  }

  /**
   * bairros_prioridade findUniqueOrThrow
   */
  export type bairros_prioridadeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bairros_prioridade
     */
    select?: bairros_prioridadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bairros_prioridade
     */
    omit?: bairros_prioridadeOmit<ExtArgs> | null
    /**
     * Filter, which bairros_prioridade to fetch.
     */
    where: bairros_prioridadeWhereUniqueInput
  }

  /**
   * bairros_prioridade findFirst
   */
  export type bairros_prioridadeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bairros_prioridade
     */
    select?: bairros_prioridadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bairros_prioridade
     */
    omit?: bairros_prioridadeOmit<ExtArgs> | null
    /**
     * Filter, which bairros_prioridade to fetch.
     */
    where?: bairros_prioridadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bairros_prioridades to fetch.
     */
    orderBy?: bairros_prioridadeOrderByWithRelationInput | bairros_prioridadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bairros_prioridades.
     */
    cursor?: bairros_prioridadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bairros_prioridades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bairros_prioridades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bairros_prioridades.
     */
    distinct?: Bairros_prioridadeScalarFieldEnum | Bairros_prioridadeScalarFieldEnum[]
  }

  /**
   * bairros_prioridade findFirstOrThrow
   */
  export type bairros_prioridadeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bairros_prioridade
     */
    select?: bairros_prioridadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bairros_prioridade
     */
    omit?: bairros_prioridadeOmit<ExtArgs> | null
    /**
     * Filter, which bairros_prioridade to fetch.
     */
    where?: bairros_prioridadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bairros_prioridades to fetch.
     */
    orderBy?: bairros_prioridadeOrderByWithRelationInput | bairros_prioridadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bairros_prioridades.
     */
    cursor?: bairros_prioridadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bairros_prioridades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bairros_prioridades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bairros_prioridades.
     */
    distinct?: Bairros_prioridadeScalarFieldEnum | Bairros_prioridadeScalarFieldEnum[]
  }

  /**
   * bairros_prioridade findMany
   */
  export type bairros_prioridadeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bairros_prioridade
     */
    select?: bairros_prioridadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bairros_prioridade
     */
    omit?: bairros_prioridadeOmit<ExtArgs> | null
    /**
     * Filter, which bairros_prioridades to fetch.
     */
    where?: bairros_prioridadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bairros_prioridades to fetch.
     */
    orderBy?: bairros_prioridadeOrderByWithRelationInput | bairros_prioridadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bairros_prioridades.
     */
    cursor?: bairros_prioridadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bairros_prioridades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bairros_prioridades.
     */
    skip?: number
    distinct?: Bairros_prioridadeScalarFieldEnum | Bairros_prioridadeScalarFieldEnum[]
  }

  /**
   * bairros_prioridade create
   */
  export type bairros_prioridadeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bairros_prioridade
     */
    select?: bairros_prioridadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bairros_prioridade
     */
    omit?: bairros_prioridadeOmit<ExtArgs> | null
    /**
     * The data needed to create a bairros_prioridade.
     */
    data: XOR<bairros_prioridadeCreateInput, bairros_prioridadeUncheckedCreateInput>
  }

  /**
   * bairros_prioridade createMany
   */
  export type bairros_prioridadeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bairros_prioridades.
     */
    data: bairros_prioridadeCreateManyInput | bairros_prioridadeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * bairros_prioridade createManyAndReturn
   */
  export type bairros_prioridadeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bairros_prioridade
     */
    select?: bairros_prioridadeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the bairros_prioridade
     */
    omit?: bairros_prioridadeOmit<ExtArgs> | null
    /**
     * The data used to create many bairros_prioridades.
     */
    data: bairros_prioridadeCreateManyInput | bairros_prioridadeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * bairros_prioridade update
   */
  export type bairros_prioridadeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bairros_prioridade
     */
    select?: bairros_prioridadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bairros_prioridade
     */
    omit?: bairros_prioridadeOmit<ExtArgs> | null
    /**
     * The data needed to update a bairros_prioridade.
     */
    data: XOR<bairros_prioridadeUpdateInput, bairros_prioridadeUncheckedUpdateInput>
    /**
     * Choose, which bairros_prioridade to update.
     */
    where: bairros_prioridadeWhereUniqueInput
  }

  /**
   * bairros_prioridade updateMany
   */
  export type bairros_prioridadeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bairros_prioridades.
     */
    data: XOR<bairros_prioridadeUpdateManyMutationInput, bairros_prioridadeUncheckedUpdateManyInput>
    /**
     * Filter which bairros_prioridades to update
     */
    where?: bairros_prioridadeWhereInput
    /**
     * Limit how many bairros_prioridades to update.
     */
    limit?: number
  }

  /**
   * bairros_prioridade updateManyAndReturn
   */
  export type bairros_prioridadeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bairros_prioridade
     */
    select?: bairros_prioridadeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the bairros_prioridade
     */
    omit?: bairros_prioridadeOmit<ExtArgs> | null
    /**
     * The data used to update bairros_prioridades.
     */
    data: XOR<bairros_prioridadeUpdateManyMutationInput, bairros_prioridadeUncheckedUpdateManyInput>
    /**
     * Filter which bairros_prioridades to update
     */
    where?: bairros_prioridadeWhereInput
    /**
     * Limit how many bairros_prioridades to update.
     */
    limit?: number
  }

  /**
   * bairros_prioridade upsert
   */
  export type bairros_prioridadeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bairros_prioridade
     */
    select?: bairros_prioridadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bairros_prioridade
     */
    omit?: bairros_prioridadeOmit<ExtArgs> | null
    /**
     * The filter to search for the bairros_prioridade to update in case it exists.
     */
    where: bairros_prioridadeWhereUniqueInput
    /**
     * In case the bairros_prioridade found by the `where` argument doesn't exist, create a new bairros_prioridade with this data.
     */
    create: XOR<bairros_prioridadeCreateInput, bairros_prioridadeUncheckedCreateInput>
    /**
     * In case the bairros_prioridade was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bairros_prioridadeUpdateInput, bairros_prioridadeUncheckedUpdateInput>
  }

  /**
   * bairros_prioridade delete
   */
  export type bairros_prioridadeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bairros_prioridade
     */
    select?: bairros_prioridadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bairros_prioridade
     */
    omit?: bairros_prioridadeOmit<ExtArgs> | null
    /**
     * Filter which bairros_prioridade to delete.
     */
    where: bairros_prioridadeWhereUniqueInput
  }

  /**
   * bairros_prioridade deleteMany
   */
  export type bairros_prioridadeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bairros_prioridades to delete
     */
    where?: bairros_prioridadeWhereInput
    /**
     * Limit how many bairros_prioridades to delete.
     */
    limit?: number
  }

  /**
   * bairros_prioridade without action
   */
  export type bairros_prioridadeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bairros_prioridade
     */
    select?: bairros_prioridadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bairros_prioridade
     */
    omit?: bairros_prioridadeOmit<ExtArgs> | null
  }


  /**
   * Model carteiras
   */

  export type AggregateCarteiras = {
    _count: CarteirasCountAggregateOutputType | null
    _avg: CarteirasAvgAggregateOutputType | null
    _sum: CarteirasSumAggregateOutputType | null
    _min: CarteirasMinAggregateOutputType | null
    _max: CarteirasMaxAggregateOutputType | null
  }

  export type CarteirasAvgAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    saldo: Decimal | null
  }

  export type CarteirasSumAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    saldo: Decimal | null
  }

  export type CarteirasMinAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    saldo: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CarteirasMaxAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    saldo: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CarteirasCountAggregateOutputType = {
    id: number
    usuarioId: number
    saldo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CarteirasAvgAggregateInputType = {
    id?: true
    usuarioId?: true
    saldo?: true
  }

  export type CarteirasSumAggregateInputType = {
    id?: true
    usuarioId?: true
    saldo?: true
  }

  export type CarteirasMinAggregateInputType = {
    id?: true
    usuarioId?: true
    saldo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CarteirasMaxAggregateInputType = {
    id?: true
    usuarioId?: true
    saldo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CarteirasCountAggregateInputType = {
    id?: true
    usuarioId?: true
    saldo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CarteirasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which carteiras to aggregate.
     */
    where?: carteirasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of carteiras to fetch.
     */
    orderBy?: carteirasOrderByWithRelationInput | carteirasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: carteirasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` carteiras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` carteiras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned carteiras
    **/
    _count?: true | CarteirasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CarteirasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CarteirasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CarteirasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CarteirasMaxAggregateInputType
  }

  export type GetCarteirasAggregateType<T extends CarteirasAggregateArgs> = {
        [P in keyof T & keyof AggregateCarteiras]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCarteiras[P]>
      : GetScalarType<T[P], AggregateCarteiras[P]>
  }




  export type carteirasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: carteirasWhereInput
    orderBy?: carteirasOrderByWithAggregationInput | carteirasOrderByWithAggregationInput[]
    by: CarteirasScalarFieldEnum[] | CarteirasScalarFieldEnum
    having?: carteirasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CarteirasCountAggregateInputType | true
    _avg?: CarteirasAvgAggregateInputType
    _sum?: CarteirasSumAggregateInputType
    _min?: CarteirasMinAggregateInputType
    _max?: CarteirasMaxAggregateInputType
  }

  export type CarteirasGroupByOutputType = {
    id: number
    usuarioId: number
    saldo: Decimal | null
    createdAt: Date
    updatedAt: Date
    _count: CarteirasCountAggregateOutputType | null
    _avg: CarteirasAvgAggregateOutputType | null
    _sum: CarteirasSumAggregateOutputType | null
    _min: CarteirasMinAggregateOutputType | null
    _max: CarteirasMaxAggregateOutputType | null
  }

  type GetCarteirasGroupByPayload<T extends carteirasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CarteirasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CarteirasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CarteirasGroupByOutputType[P]>
            : GetScalarType<T[P], CarteirasGroupByOutputType[P]>
        }
      >
    >


  export type carteirasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    tipo?: boolean
    saldo?: boolean
    ultima_atualizacao?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["carteiras"]>

  export type carteirasSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    tipo?: boolean
    saldo?: boolean
    ultima_atualizacao?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["carteiras"]>

  export type carteirasSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    tipo?: boolean
    saldo?: boolean
    ultima_atualizacao?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["carteiras"]>

  export type carteirasSelectScalar = {
    id?: boolean
    usuario_id?: boolean
    tipo?: boolean
    saldo?: boolean
    ultima_atualizacao?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type carteirasOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "usuario_id" | "tipo" | "saldo" | "ultima_atualizacao" | "createdAt" | "updatedAt", ExtArgs["result"]["carteiras"]>

  export type $carteirasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "carteiras"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      usuario_id: number
      tipo: $Enums.enum_carteiras_tipo
      saldo: number
      ultima_atualizacao: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["carteiras"]>
    composites: {}
  }

  type carteirasGetPayload<S extends boolean | null | undefined | carteirasDefaultArgs> = $Result.GetResult<Prisma.$carteirasPayload, S>

  type carteirasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<carteirasFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CarteirasCountAggregateInputType | true
    }

  export interface carteirasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['carteiras'], meta: { name: 'carteiras' } }
    /**
     * Find zero or one Carteiras that matches the filter.
     * @param {carteirasFindUniqueArgs} args - Arguments to find a Carteiras
     * @example
     * // Get one Carteiras
     * const carteiras = await prisma.carteiras.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends carteirasFindUniqueArgs>(args: SelectSubset<T, carteirasFindUniqueArgs<ExtArgs>>): Prisma__carteirasClient<$Result.GetResult<Prisma.$carteirasPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Carteiras that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {carteirasFindUniqueOrThrowArgs} args - Arguments to find a Carteiras
     * @example
     * // Get one Carteiras
     * const carteiras = await prisma.carteiras.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends carteirasFindUniqueOrThrowArgs>(args: SelectSubset<T, carteirasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__carteirasClient<$Result.GetResult<Prisma.$carteirasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Carteiras that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {carteirasFindFirstArgs} args - Arguments to find a Carteiras
     * @example
     * // Get one Carteiras
     * const carteiras = await prisma.carteiras.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends carteirasFindFirstArgs>(args?: SelectSubset<T, carteirasFindFirstArgs<ExtArgs>>): Prisma__carteirasClient<$Result.GetResult<Prisma.$carteirasPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Carteiras that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {carteirasFindFirstOrThrowArgs} args - Arguments to find a Carteiras
     * @example
     * // Get one Carteiras
     * const carteiras = await prisma.carteiras.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends carteirasFindFirstOrThrowArgs>(args?: SelectSubset<T, carteirasFindFirstOrThrowArgs<ExtArgs>>): Prisma__carteirasClient<$Result.GetResult<Prisma.$carteirasPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Carteiras that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {carteirasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Carteiras
     * const carteiras = await prisma.carteiras.findMany()
     * 
     * // Get first 10 Carteiras
     * const carteiras = await prisma.carteiras.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const carteirasWithIdOnly = await prisma.carteiras.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends carteirasFindManyArgs>(args?: SelectSubset<T, carteirasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$carteirasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Carteiras.
     * @param {carteirasCreateArgs} args - Arguments to create a Carteiras.
     * @example
     * // Create one Carteiras
     * const Carteiras = await prisma.carteiras.create({
     *   data: {
     *     // ... data to create a Carteiras
     *   }
     * })
     * 
     */
    create<T extends carteirasCreateArgs>(args: SelectSubset<T, carteirasCreateArgs<ExtArgs>>): Prisma__carteirasClient<$Result.GetResult<Prisma.$carteirasPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Carteiras.
     * @param {carteirasCreateManyArgs} args - Arguments to create many Carteiras.
     * @example
     * // Create many Carteiras
     * const carteiras = await prisma.carteiras.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends carteirasCreateManyArgs>(args?: SelectSubset<T, carteirasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Carteiras and returns the data saved in the database.
     * @param {carteirasCreateManyAndReturnArgs} args - Arguments to create many Carteiras.
     * @example
     * // Create many Carteiras
     * const carteiras = await prisma.carteiras.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Carteiras and only return the `id`
     * const carteirasWithIdOnly = await prisma.carteiras.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends carteirasCreateManyAndReturnArgs>(args?: SelectSubset<T, carteirasCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$carteirasPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Carteiras.
     * @param {carteirasDeleteArgs} args - Arguments to delete one Carteiras.
     * @example
     * // Delete one Carteiras
     * const Carteiras = await prisma.carteiras.delete({
     *   where: {
     *     // ... filter to delete one Carteiras
     *   }
     * })
     * 
     */
    delete<T extends carteirasDeleteArgs>(args: SelectSubset<T, carteirasDeleteArgs<ExtArgs>>): Prisma__carteirasClient<$Result.GetResult<Prisma.$carteirasPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Carteiras.
     * @param {carteirasUpdateArgs} args - Arguments to update one Carteiras.
     * @example
     * // Update one Carteiras
     * const carteiras = await prisma.carteiras.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends carteirasUpdateArgs>(args: SelectSubset<T, carteirasUpdateArgs<ExtArgs>>): Prisma__carteirasClient<$Result.GetResult<Prisma.$carteirasPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Carteiras.
     * @param {carteirasDeleteManyArgs} args - Arguments to filter Carteiras to delete.
     * @example
     * // Delete a few Carteiras
     * const { count } = await prisma.carteiras.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends carteirasDeleteManyArgs>(args?: SelectSubset<T, carteirasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Carteiras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {carteirasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Carteiras
     * const carteiras = await prisma.carteiras.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends carteirasUpdateManyArgs>(args: SelectSubset<T, carteirasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Carteiras and returns the data updated in the database.
     * @param {carteirasUpdateManyAndReturnArgs} args - Arguments to update many Carteiras.
     * @example
     * // Update many Carteiras
     * const carteiras = await prisma.carteiras.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Carteiras and only return the `id`
     * const carteirasWithIdOnly = await prisma.carteiras.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends carteirasUpdateManyAndReturnArgs>(args: SelectSubset<T, carteirasUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$carteirasPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Carteiras.
     * @param {carteirasUpsertArgs} args - Arguments to update or create a Carteiras.
     * @example
     * // Update or create a Carteiras
     * const carteiras = await prisma.carteiras.upsert({
     *   create: {
     *     // ... data to create a Carteiras
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Carteiras we want to update
     *   }
     * })
     */
    upsert<T extends carteirasUpsertArgs>(args: SelectSubset<T, carteirasUpsertArgs<ExtArgs>>): Prisma__carteirasClient<$Result.GetResult<Prisma.$carteirasPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Carteiras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {carteirasCountArgs} args - Arguments to filter Carteiras to count.
     * @example
     * // Count the number of Carteiras
     * const count = await prisma.carteiras.count({
     *   where: {
     *     // ... the filter for the Carteiras we want to count
     *   }
     * })
    **/
    count<T extends carteirasCountArgs>(
      args?: Subset<T, carteirasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CarteirasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Carteiras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarteirasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CarteirasAggregateArgs>(args: Subset<T, CarteirasAggregateArgs>): Prisma.PrismaPromise<GetCarteirasAggregateType<T>>

    /**
     * Group by Carteiras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {carteirasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends carteirasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: carteirasGroupByArgs['orderBy'] }
        : { orderBy?: carteirasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, carteirasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCarteirasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the carteiras model
   */
  readonly fields: carteirasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for carteiras.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__carteirasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the carteiras model
   */
  interface carteirasFieldRefs {
    readonly id: FieldRef<"carteiras", 'Int'>
    readonly usuario_id: FieldRef<"carteiras", 'Int'>
    readonly tipo: FieldRef<"carteiras", 'enum_carteiras_tipo'>
    readonly saldo: FieldRef<"carteiras", 'Float'>
    readonly ultima_atualizacao: FieldRef<"carteiras", 'DateTime'>
    readonly createdAt: FieldRef<"carteiras", 'DateTime'>
    readonly updatedAt: FieldRef<"carteiras", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * carteiras findUnique
   */
  export type carteirasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the carteiras
     */
    select?: carteirasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the carteiras
     */
    omit?: carteirasOmit<ExtArgs> | null
    /**
     * Filter, which carteiras to fetch.
     */
    where: carteirasWhereUniqueInput
  }

  /**
   * carteiras findUniqueOrThrow
   */
  export type carteirasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the carteiras
     */
    select?: carteirasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the carteiras
     */
    omit?: carteirasOmit<ExtArgs> | null
    /**
     * Filter, which carteiras to fetch.
     */
    where: carteirasWhereUniqueInput
  }

  /**
   * carteiras findFirst
   */
  export type carteirasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the carteiras
     */
    select?: carteirasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the carteiras
     */
    omit?: carteirasOmit<ExtArgs> | null
    /**
     * Filter, which carteiras to fetch.
     */
    where?: carteirasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of carteiras to fetch.
     */
    orderBy?: carteirasOrderByWithRelationInput | carteirasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for carteiras.
     */
    cursor?: carteirasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` carteiras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` carteiras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of carteiras.
     */
    distinct?: CarteirasScalarFieldEnum | CarteirasScalarFieldEnum[]
  }

  /**
   * carteiras findFirstOrThrow
   */
  export type carteirasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the carteiras
     */
    select?: carteirasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the carteiras
     */
    omit?: carteirasOmit<ExtArgs> | null
    /**
     * Filter, which carteiras to fetch.
     */
    where?: carteirasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of carteiras to fetch.
     */
    orderBy?: carteirasOrderByWithRelationInput | carteirasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for carteiras.
     */
    cursor?: carteirasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` carteiras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` carteiras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of carteiras.
     */
    distinct?: CarteirasScalarFieldEnum | CarteirasScalarFieldEnum[]
  }

  /**
   * carteiras findMany
   */
  export type carteirasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the carteiras
     */
    select?: carteirasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the carteiras
     */
    omit?: carteirasOmit<ExtArgs> | null
    /**
     * Filter, which carteiras to fetch.
     */
    where?: carteirasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of carteiras to fetch.
     */
    orderBy?: carteirasOrderByWithRelationInput | carteirasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing carteiras.
     */
    cursor?: carteirasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` carteiras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` carteiras.
     */
    skip?: number
    distinct?: CarteirasScalarFieldEnum | CarteirasScalarFieldEnum[]
  }

  /**
   * carteiras create
   */
  export type carteirasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the carteiras
     */
    select?: carteirasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the carteiras
     */
    omit?: carteirasOmit<ExtArgs> | null
    /**
     * The data needed to create a carteiras.
     */
    data: XOR<carteirasCreateInput, carteirasUncheckedCreateInput>
  }

  /**
   * carteiras createMany
   */
  export type carteirasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many carteiras.
     */
    data: carteirasCreateManyInput | carteirasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * carteiras createManyAndReturn
   */
  export type carteirasCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the carteiras
     */
    select?: carteirasSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the carteiras
     */
    omit?: carteirasOmit<ExtArgs> | null
    /**
     * The data used to create many carteiras.
     */
    data: carteirasCreateManyInput | carteirasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * carteiras update
   */
  export type carteirasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the carteiras
     */
    select?: carteirasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the carteiras
     */
    omit?: carteirasOmit<ExtArgs> | null
    /**
     * The data needed to update a carteiras.
     */
    data: XOR<carteirasUpdateInput, carteirasUncheckedUpdateInput>
    /**
     * Choose, which carteiras to update.
     */
    where: carteirasWhereUniqueInput
  }

  /**
   * carteiras updateMany
   */
  export type carteirasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update carteiras.
     */
    data: XOR<carteirasUpdateManyMutationInput, carteirasUncheckedUpdateManyInput>
    /**
     * Filter which carteiras to update
     */
    where?: carteirasWhereInput
    /**
     * Limit how many carteiras to update.
     */
    limit?: number
  }

  /**
   * carteiras updateManyAndReturn
   */
  export type carteirasUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the carteiras
     */
    select?: carteirasSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the carteiras
     */
    omit?: carteirasOmit<ExtArgs> | null
    /**
     * The data used to update carteiras.
     */
    data: XOR<carteirasUpdateManyMutationInput, carteirasUncheckedUpdateManyInput>
    /**
     * Filter which carteiras to update
     */
    where?: carteirasWhereInput
    /**
     * Limit how many carteiras to update.
     */
    limit?: number
  }

  /**
   * carteiras upsert
   */
  export type carteirasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the carteiras
     */
    select?: carteirasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the carteiras
     */
    omit?: carteirasOmit<ExtArgs> | null
    /**
     * The filter to search for the carteiras to update in case it exists.
     */
    where: carteirasWhereUniqueInput
    /**
     * In case the carteiras found by the `where` argument doesn't exist, create a new carteiras with this data.
     */
    create: XOR<carteirasCreateInput, carteirasUncheckedCreateInput>
    /**
     * In case the carteiras was found with the provided `where` argument, update it with this data.
     */
    update: XOR<carteirasUpdateInput, carteirasUncheckedUpdateInput>
  }

  /**
   * carteiras delete
   */
  export type carteirasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the carteiras
     */
    select?: carteirasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the carteiras
     */
    omit?: carteirasOmit<ExtArgs> | null
    /**
     * Filter which carteiras to delete.
     */
    where: carteirasWhereUniqueInput
  }

  /**
   * carteiras deleteMany
   */
  export type carteirasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which carteiras to delete
     */
    where?: carteirasWhereInput
    /**
     * Limit how many carteiras to delete.
     */
    limit?: number
  }

  /**
   * carteiras without action
   */
  export type carteirasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the carteiras
     */
    select?: carteirasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the carteiras
     */
    omit?: carteirasOmit<ExtArgs> | null
  }


  /**
   * Model corridas
   */

  export type AggregateCorridas = {
    _count: CorridasCountAggregateOutputType | null
    _avg: CorridasAvgAggregateOutputType | null
    _sum: CorridasSumAggregateOutputType | null
    _min: CorridasMinAggregateOutputType | null
    _max: CorridasMaxAggregateOutputType | null
  }

  export type CorridasAvgAggregateOutputType = {
    id: number | null
    valor: Decimal | null
    usuarioId: number | null
  }

  export type CorridasSumAggregateOutputType = {
    id: number | null
    valor: Decimal | null
    usuarioId: number | null
  }

  export type CorridasMinAggregateOutputType = {
    id: number | null
    origem: string | null
    destino: string | null
    status: string | null
    valor: Decimal | null
    tipo: $Enums.enum_Corridas_tipo | null
    horarioAgendado: Date | null
    usuarioId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CorridasMaxAggregateOutputType = {
    id: number | null
    origem: string | null
    destino: string | null
    status: string | null
    valor: Decimal | null
    tipo: $Enums.enum_Corridas_tipo | null
    horarioAgendado: Date | null
    usuarioId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CorridasCountAggregateOutputType = {
    id: number
    origem: number
    destino: number
    status: number
    valor: number
    tipo: number
    horarioAgendado: number
    usuarioId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CorridasAvgAggregateInputType = {
    id?: true
    valor?: true
    usuarioId?: true
  }

  export type CorridasSumAggregateInputType = {
    id?: true
    valor?: true
    usuarioId?: true
  }

  export type CorridasMinAggregateInputType = {
    id?: true
    origem?: true
    destino?: true
    status?: true
    valor?: true
    tipo?: true
    horarioAgendado?: true
    usuarioId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CorridasMaxAggregateInputType = {
    id?: true
    origem?: true
    destino?: true
    status?: true
    valor?: true
    tipo?: true
    horarioAgendado?: true
    usuarioId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CorridasCountAggregateInputType = {
    id?: true
    origem?: true
    destino?: true
    status?: true
    valor?: true
    tipo?: true
    horarioAgendado?: true
    usuarioId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CorridasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which corridas to aggregate.
     */
    where?: corridasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of corridas to fetch.
     */
    orderBy?: corridasOrderByWithRelationInput | corridasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: corridasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` corridas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` corridas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned corridas
    **/
    _count?: true | CorridasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CorridasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CorridasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CorridasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CorridasMaxAggregateInputType
  }

  export type GetCorridasAggregateType<T extends CorridasAggregateArgs> = {
        [P in keyof T & keyof AggregateCorridas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCorridas[P]>
      : GetScalarType<T[P], AggregateCorridas[P]>
  }




  export type corridasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: corridasWhereInput
    orderBy?: corridasOrderByWithAggregationInput | corridasOrderByWithAggregationInput[]
    by: CorridasScalarFieldEnum[] | CorridasScalarFieldEnum
    having?: corridasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CorridasCountAggregateInputType | true
    _avg?: CorridasAvgAggregateInputType
    _sum?: CorridasSumAggregateInputType
    _min?: CorridasMinAggregateInputType
    _max?: CorridasMaxAggregateInputType
  }

  export type CorridasGroupByOutputType = {
    id: number
    origem: string | null
    destino: string | null
    status: string | null
    valor: Decimal | null
    tipo: $Enums.enum_Corridas_tipo | null
    horarioAgendado: Date | null
    usuarioId: number | null
    createdAt: Date
    updatedAt: Date
    _count: CorridasCountAggregateOutputType | null
    _avg: CorridasAvgAggregateOutputType | null
    _sum: CorridasSumAggregateOutputType | null
    _min: CorridasMinAggregateOutputType | null
    _max: CorridasMaxAggregateOutputType | null
  }

  type GetCorridasGroupByPayload<T extends corridasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CorridasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CorridasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CorridasGroupByOutputType[P]>
            : GetScalarType<T[P], CorridasGroupByOutputType[P]>
        }
      >
    >


  export type corridasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_motorista?: boolean
    id_passageiro?: boolean
    origem?: boolean
    destino?: boolean
    status?: boolean
    distancia_km?: boolean
    valor_total?: boolean
    forma_pagamento?: boolean
    data_hora?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["corridas"]>

  export type corridasSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_motorista?: boolean
    id_passageiro?: boolean
    origem?: boolean
    destino?: boolean
    status?: boolean
    distancia_km?: boolean
    valor_total?: boolean
    forma_pagamento?: boolean
    data_hora?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["corridas"]>

  export type corridasSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_motorista?: boolean
    id_passageiro?: boolean
    origem?: boolean
    destino?: boolean
    status?: boolean
    distancia_km?: boolean
    valor_total?: boolean
    forma_pagamento?: boolean
    data_hora?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["corridas"]>

  export type corridasSelectScalar = {
    id?: boolean
    id_motorista?: boolean
    id_passageiro?: boolean
    origem?: boolean
    destino?: boolean
    status?: boolean
    distancia_km?: boolean
    valor_total?: boolean
    forma_pagamento?: boolean
    data_hora?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type corridasOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "id_motorista" | "id_passageiro" | "origem" | "destino" | "status" | "distancia_km" | "valor_total" | "forma_pagamento" | "data_hora" | "createdAt" | "updatedAt", ExtArgs["result"]["corridas"]>

  export type $corridasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "corridas"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      id_motorista: number
      id_passageiro: number
      origem: string
      destino: string
      status: $Enums.enum_corridas_status | null
      distancia_km: number
      valor_total: number
      forma_pagamento: $Enums.enum_corridas_forma_pagamento
      data_hora: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["corridas"]>
    composites: {}
  }

  type corridasGetPayload<S extends boolean | null | undefined | corridasDefaultArgs> = $Result.GetResult<Prisma.$corridasPayload, S>

  type corridasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<corridasFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CorridasCountAggregateInputType | true
    }

  export interface corridasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['corridas'], meta: { name: 'corridas' } }
    /**
     * Find zero or one Corridas that matches the filter.
     * @param {corridasFindUniqueArgs} args - Arguments to find a Corridas
     * @example
     * // Get one Corridas
     * const corridas = await prisma.corridas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends corridasFindUniqueArgs>(args: SelectSubset<T, corridasFindUniqueArgs<ExtArgs>>): Prisma__corridasClient<$Result.GetResult<Prisma.$corridasPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Corridas that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {corridasFindUniqueOrThrowArgs} args - Arguments to find a Corridas
     * @example
     * // Get one Corridas
     * const corridas = await prisma.corridas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends corridasFindUniqueOrThrowArgs>(args: SelectSubset<T, corridasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__corridasClient<$Result.GetResult<Prisma.$corridasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Corridas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {corridasFindFirstArgs} args - Arguments to find a Corridas
     * @example
     * // Get one Corridas
     * const corridas = await prisma.corridas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends corridasFindFirstArgs>(args?: SelectSubset<T, corridasFindFirstArgs<ExtArgs>>): Prisma__corridasClient<$Result.GetResult<Prisma.$corridasPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Corridas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {corridasFindFirstOrThrowArgs} args - Arguments to find a Corridas
     * @example
     * // Get one Corridas
     * const corridas = await prisma.corridas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends corridasFindFirstOrThrowArgs>(args?: SelectSubset<T, corridasFindFirstOrThrowArgs<ExtArgs>>): Prisma__corridasClient<$Result.GetResult<Prisma.$corridasPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Corridas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {corridasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Corridas
     * const corridas = await prisma.corridas.findMany()
     * 
     * // Get first 10 Corridas
     * const corridas = await prisma.corridas.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const corridasWithIdOnly = await prisma.corridas.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends corridasFindManyArgs>(args?: SelectSubset<T, corridasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$corridasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Corridas.
     * @param {corridasCreateArgs} args - Arguments to create a Corridas.
     * @example
     * // Create one Corridas
     * const Corridas = await prisma.corridas.create({
     *   data: {
     *     // ... data to create a Corridas
     *   }
     * })
     * 
     */
    create<T extends corridasCreateArgs>(args: SelectSubset<T, corridasCreateArgs<ExtArgs>>): Prisma__corridasClient<$Result.GetResult<Prisma.$corridasPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Corridas.
     * @param {corridasCreateManyArgs} args - Arguments to create many Corridas.
     * @example
     * // Create many Corridas
     * const corridas = await prisma.corridas.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends corridasCreateManyArgs>(args?: SelectSubset<T, corridasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Corridas and returns the data saved in the database.
     * @param {corridasCreateManyAndReturnArgs} args - Arguments to create many Corridas.
     * @example
     * // Create many Corridas
     * const corridas = await prisma.corridas.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Corridas and only return the `id`
     * const corridasWithIdOnly = await prisma.corridas.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends corridasCreateManyAndReturnArgs>(args?: SelectSubset<T, corridasCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$corridasPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Corridas.
     * @param {corridasDeleteArgs} args - Arguments to delete one Corridas.
     * @example
     * // Delete one Corridas
     * const Corridas = await prisma.corridas.delete({
     *   where: {
     *     // ... filter to delete one Corridas
     *   }
     * })
     * 
     */
    delete<T extends corridasDeleteArgs>(args: SelectSubset<T, corridasDeleteArgs<ExtArgs>>): Prisma__corridasClient<$Result.GetResult<Prisma.$corridasPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Corridas.
     * @param {corridasUpdateArgs} args - Arguments to update one Corridas.
     * @example
     * // Update one Corridas
     * const corridas = await prisma.corridas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends corridasUpdateArgs>(args: SelectSubset<T, corridasUpdateArgs<ExtArgs>>): Prisma__corridasClient<$Result.GetResult<Prisma.$corridasPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Corridas.
     * @param {corridasDeleteManyArgs} args - Arguments to filter Corridas to delete.
     * @example
     * // Delete a few Corridas
     * const { count } = await prisma.corridas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends corridasDeleteManyArgs>(args?: SelectSubset<T, corridasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Corridas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {corridasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Corridas
     * const corridas = await prisma.corridas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends corridasUpdateManyArgs>(args: SelectSubset<T, corridasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Corridas and returns the data updated in the database.
     * @param {corridasUpdateManyAndReturnArgs} args - Arguments to update many Corridas.
     * @example
     * // Update many Corridas
     * const corridas = await prisma.corridas.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Corridas and only return the `id`
     * const corridasWithIdOnly = await prisma.corridas.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends corridasUpdateManyAndReturnArgs>(args: SelectSubset<T, corridasUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$corridasPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Corridas.
     * @param {corridasUpsertArgs} args - Arguments to update or create a Corridas.
     * @example
     * // Update or create a Corridas
     * const corridas = await prisma.corridas.upsert({
     *   create: {
     *     // ... data to create a Corridas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Corridas we want to update
     *   }
     * })
     */
    upsert<T extends corridasUpsertArgs>(args: SelectSubset<T, corridasUpsertArgs<ExtArgs>>): Prisma__corridasClient<$Result.GetResult<Prisma.$corridasPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Corridas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {corridasCountArgs} args - Arguments to filter Corridas to count.
     * @example
     * // Count the number of Corridas
     * const count = await prisma.corridas.count({
     *   where: {
     *     // ... the filter for the Corridas we want to count
     *   }
     * })
    **/
    count<T extends corridasCountArgs>(
      args?: Subset<T, corridasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CorridasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Corridas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorridasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CorridasAggregateArgs>(args: Subset<T, CorridasAggregateArgs>): Prisma.PrismaPromise<GetCorridasAggregateType<T>>

    /**
     * Group by Corridas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {corridasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends corridasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: corridasGroupByArgs['orderBy'] }
        : { orderBy?: corridasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, corridasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCorridasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the corridas model
   */
  readonly fields: corridasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for corridas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__corridasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the corridas model
   */
  interface corridasFieldRefs {
    readonly id: FieldRef<"corridas", 'Int'>
    readonly id_motorista: FieldRef<"corridas", 'Int'>
    readonly id_passageiro: FieldRef<"corridas", 'Int'>
    readonly origem: FieldRef<"corridas", 'String'>
    readonly destino: FieldRef<"corridas", 'String'>
    readonly status: FieldRef<"corridas", 'enum_corridas_status'>
    readonly distancia_km: FieldRef<"corridas", 'Float'>
    readonly valor_total: FieldRef<"corridas", 'Float'>
    readonly forma_pagamento: FieldRef<"corridas", 'enum_corridas_forma_pagamento'>
    readonly data_hora: FieldRef<"corridas", 'DateTime'>
    readonly createdAt: FieldRef<"corridas", 'DateTime'>
    readonly updatedAt: FieldRef<"corridas", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * corridas findUnique
   */
  export type corridasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the corridas
     */
    select?: corridasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the corridas
     */
    omit?: corridasOmit<ExtArgs> | null
    /**
     * Filter, which corridas to fetch.
     */
    where: corridasWhereUniqueInput
  }

  /**
   * corridas findUniqueOrThrow
   */
  export type corridasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the corridas
     */
    select?: corridasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the corridas
     */
    omit?: corridasOmit<ExtArgs> | null
    /**
     * Filter, which corridas to fetch.
     */
    where: corridasWhereUniqueInput
  }

  /**
   * corridas findFirst
   */
  export type corridasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the corridas
     */
    select?: corridasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the corridas
     */
    omit?: corridasOmit<ExtArgs> | null
    /**
     * Filter, which corridas to fetch.
     */
    where?: corridasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of corridas to fetch.
     */
    orderBy?: corridasOrderByWithRelationInput | corridasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for corridas.
     */
    cursor?: corridasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` corridas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` corridas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of corridas.
     */
    distinct?: CorridasScalarFieldEnum | CorridasScalarFieldEnum[]
  }

  /**
   * corridas findFirstOrThrow
   */
  export type corridasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the corridas
     */
    select?: corridasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the corridas
     */
    omit?: corridasOmit<ExtArgs> | null
    /**
     * Filter, which corridas to fetch.
     */
    where?: corridasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of corridas to fetch.
     */
    orderBy?: corridasOrderByWithRelationInput | corridasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for corridas.
     */
    cursor?: corridasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` corridas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` corridas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of corridas.
     */
    distinct?: CorridasScalarFieldEnum | CorridasScalarFieldEnum[]
  }

  /**
   * corridas findMany
   */
  export type corridasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the corridas
     */
    select?: corridasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the corridas
     */
    omit?: corridasOmit<ExtArgs> | null
    /**
     * Filter, which corridas to fetch.
     */
    where?: corridasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of corridas to fetch.
     */
    orderBy?: corridasOrderByWithRelationInput | corridasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing corridas.
     */
    cursor?: corridasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` corridas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` corridas.
     */
    skip?: number
    distinct?: CorridasScalarFieldEnum | CorridasScalarFieldEnum[]
  }

  /**
   * corridas create
   */
  export type corridasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the corridas
     */
    select?: corridasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the corridas
     */
    omit?: corridasOmit<ExtArgs> | null
    /**
     * The data needed to create a corridas.
     */
    data: XOR<corridasCreateInput, corridasUncheckedCreateInput>
  }

  /**
   * corridas createMany
   */
  export type corridasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many corridas.
     */
    data: corridasCreateManyInput | corridasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * corridas createManyAndReturn
   */
  export type corridasCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the corridas
     */
    select?: corridasSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the corridas
     */
    omit?: corridasOmit<ExtArgs> | null
    /**
     * The data used to create many corridas.
     */
    data: corridasCreateManyInput | corridasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * corridas update
   */
  export type corridasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the corridas
     */
    select?: corridasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the corridas
     */
    omit?: corridasOmit<ExtArgs> | null
    /**
     * The data needed to update a corridas.
     */
    data: XOR<corridasUpdateInput, corridasUncheckedUpdateInput>
    /**
     * Choose, which corridas to update.
     */
    where: corridasWhereUniqueInput
  }

  /**
   * corridas updateMany
   */
  export type corridasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update corridas.
     */
    data: XOR<corridasUpdateManyMutationInput, corridasUncheckedUpdateManyInput>
    /**
     * Filter which corridas to update
     */
    where?: corridasWhereInput
    /**
     * Limit how many corridas to update.
     */
    limit?: number
  }

  /**
   * corridas updateManyAndReturn
   */
  export type corridasUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the corridas
     */
    select?: corridasSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the corridas
     */
    omit?: corridasOmit<ExtArgs> | null
    /**
     * The data used to update corridas.
     */
    data: XOR<corridasUpdateManyMutationInput, corridasUncheckedUpdateManyInput>
    /**
     * Filter which corridas to update
     */
    where?: corridasWhereInput
    /**
     * Limit how many corridas to update.
     */
    limit?: number
  }

  /**
   * corridas upsert
   */
  export type corridasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the corridas
     */
    select?: corridasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the corridas
     */
    omit?: corridasOmit<ExtArgs> | null
    /**
     * The filter to search for the corridas to update in case it exists.
     */
    where: corridasWhereUniqueInput
    /**
     * In case the corridas found by the `where` argument doesn't exist, create a new corridas with this data.
     */
    create: XOR<corridasCreateInput, corridasUncheckedCreateInput>
    /**
     * In case the corridas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<corridasUpdateInput, corridasUncheckedUpdateInput>
  }

  /**
   * corridas delete
   */
  export type corridasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the corridas
     */
    select?: corridasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the corridas
     */
    omit?: corridasOmit<ExtArgs> | null
    /**
     * Filter which corridas to delete.
     */
    where: corridasWhereUniqueInput
  }

  /**
   * corridas deleteMany
   */
  export type corridasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which corridas to delete
     */
    where?: corridasWhereInput
    /**
     * Limit how many corridas to delete.
     */
    limit?: number
  }

  /**
   * corridas without action
   */
  export type corridasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the corridas
     */
    select?: corridasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the corridas
     */
    omit?: corridasOmit<ExtArgs> | null
  }


  /**
   * Model denuncias
   */

  export type AggregateDenuncias = {
    _count: DenunciasCountAggregateOutputType | null
    _avg: DenunciasAvgAggregateOutputType | null
    _sum: DenunciasSumAggregateOutputType | null
    _min: DenunciasMinAggregateOutputType | null
    _max: DenunciasMaxAggregateOutputType | null
  }

  export type DenunciasAvgAggregateOutputType = {
    id: number | null
    autor_id: number | null
    alvo_id: number | null
    corrida_id: number | null
  }

  export type DenunciasSumAggregateOutputType = {
    id: number | null
    autor_id: number | null
    alvo_id: number | null
    corrida_id: number | null
  }

  export type DenunciasMinAggregateOutputType = {
    id: number | null
    autor_id: number | null
    alvo_id: number | null
    tipo_alvo: $Enums.enum_denuncias_tipo_alvo | null
    corrida_id: number | null
    motivo: string | null
    descricao: string | null
    status: $Enums.enum_denuncias_status | null
    data_denuncia: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DenunciasMaxAggregateOutputType = {
    id: number | null
    autor_id: number | null
    alvo_id: number | null
    tipo_alvo: $Enums.enum_denuncias_tipo_alvo | null
    corrida_id: number | null
    motivo: string | null
    descricao: string | null
    status: $Enums.enum_denuncias_status | null
    data_denuncia: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DenunciasCountAggregateOutputType = {
    id: number
    autor_id: number
    alvo_id: number
    tipo_alvo: number
    corrida_id: number
    motivo: number
    descricao: number
    status: number
    data_denuncia: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DenunciasAvgAggregateInputType = {
    id?: true
    autor_id?: true
    alvo_id?: true
    corrida_id?: true
  }

  export type DenunciasSumAggregateInputType = {
    id?: true
    autor_id?: true
    alvo_id?: true
    corrida_id?: true
  }

  export type DenunciasMinAggregateInputType = {
    id?: true
    autor_id?: true
    alvo_id?: true
    tipo_alvo?: true
    corrida_id?: true
    motivo?: true
    descricao?: true
    status?: true
    data_denuncia?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DenunciasMaxAggregateInputType = {
    id?: true
    autor_id?: true
    alvo_id?: true
    tipo_alvo?: true
    corrida_id?: true
    motivo?: true
    descricao?: true
    status?: true
    data_denuncia?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DenunciasCountAggregateInputType = {
    id?: true
    autor_id?: true
    alvo_id?: true
    tipo_alvo?: true
    corrida_id?: true
    motivo?: true
    descricao?: true
    status?: true
    data_denuncia?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DenunciasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which denuncias to aggregate.
     */
    where?: denunciasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of denuncias to fetch.
     */
    orderBy?: denunciasOrderByWithRelationInput | denunciasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: denunciasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` denuncias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` denuncias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned denuncias
    **/
    _count?: true | DenunciasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DenunciasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DenunciasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DenunciasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DenunciasMaxAggregateInputType
  }

  export type GetDenunciasAggregateType<T extends DenunciasAggregateArgs> = {
        [P in keyof T & keyof AggregateDenuncias]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDenuncias[P]>
      : GetScalarType<T[P], AggregateDenuncias[P]>
  }




  export type denunciasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: denunciasWhereInput
    orderBy?: denunciasOrderByWithAggregationInput | denunciasOrderByWithAggregationInput[]
    by: DenunciasScalarFieldEnum[] | DenunciasScalarFieldEnum
    having?: denunciasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DenunciasCountAggregateInputType | true
    _avg?: DenunciasAvgAggregateInputType
    _sum?: DenunciasSumAggregateInputType
    _min?: DenunciasMinAggregateInputType
    _max?: DenunciasMaxAggregateInputType
  }

  export type DenunciasGroupByOutputType = {
    id: number
    autor_id: number
    alvo_id: number
    tipo_alvo: $Enums.enum_denuncias_tipo_alvo
    corrida_id: number | null
    motivo: string
    descricao: string | null
    status: $Enums.enum_denuncias_status | null
    data_denuncia: Date | null
    createdAt: Date
    updatedAt: Date
    _count: DenunciasCountAggregateOutputType | null
    _avg: DenunciasAvgAggregateOutputType | null
    _sum: DenunciasSumAggregateOutputType | null
    _min: DenunciasMinAggregateOutputType | null
    _max: DenunciasMaxAggregateOutputType | null
  }

  type GetDenunciasGroupByPayload<T extends denunciasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DenunciasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DenunciasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DenunciasGroupByOutputType[P]>
            : GetScalarType<T[P], DenunciasGroupByOutputType[P]>
        }
      >
    >


  export type denunciasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    autor_id?: boolean
    alvo_id?: boolean
    tipo_alvo?: boolean
    corrida_id?: boolean
    motivo?: boolean
    descricao?: boolean
    status?: boolean
    data_denuncia?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["denuncias"]>

  export type denunciasSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    autor_id?: boolean
    alvo_id?: boolean
    tipo_alvo?: boolean
    corrida_id?: boolean
    motivo?: boolean
    descricao?: boolean
    status?: boolean
    data_denuncia?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["denuncias"]>

  export type denunciasSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    autor_id?: boolean
    alvo_id?: boolean
    tipo_alvo?: boolean
    corrida_id?: boolean
    motivo?: boolean
    descricao?: boolean
    status?: boolean
    data_denuncia?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["denuncias"]>

  export type denunciasSelectScalar = {
    id?: boolean
    autor_id?: boolean
    alvo_id?: boolean
    tipo_alvo?: boolean
    corrida_id?: boolean
    motivo?: boolean
    descricao?: boolean
    status?: boolean
    data_denuncia?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type denunciasOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "autor_id" | "alvo_id" | "tipo_alvo" | "corrida_id" | "motivo" | "descricao" | "status" | "data_denuncia" | "createdAt" | "updatedAt", ExtArgs["result"]["denuncias"]>

  export type $denunciasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "denuncias"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      autor_id: number
      alvo_id: number
      tipo_alvo: $Enums.enum_denuncias_tipo_alvo
      corrida_id: number | null
      motivo: string
      descricao: string | null
      status: $Enums.enum_denuncias_status | null
      data_denuncia: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["denuncias"]>
    composites: {}
  }

  type denunciasGetPayload<S extends boolean | null | undefined | denunciasDefaultArgs> = $Result.GetResult<Prisma.$denunciasPayload, S>

  type denunciasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<denunciasFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DenunciasCountAggregateInputType | true
    }

  export interface denunciasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['denuncias'], meta: { name: 'denuncias' } }
    /**
     * Find zero or one Denuncias that matches the filter.
     * @param {denunciasFindUniqueArgs} args - Arguments to find a Denuncias
     * @example
     * // Get one Denuncias
     * const denuncias = await prisma.denuncias.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends denunciasFindUniqueArgs>(args: SelectSubset<T, denunciasFindUniqueArgs<ExtArgs>>): Prisma__denunciasClient<$Result.GetResult<Prisma.$denunciasPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Denuncias that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {denunciasFindUniqueOrThrowArgs} args - Arguments to find a Denuncias
     * @example
     * // Get one Denuncias
     * const denuncias = await prisma.denuncias.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends denunciasFindUniqueOrThrowArgs>(args: SelectSubset<T, denunciasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__denunciasClient<$Result.GetResult<Prisma.$denunciasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Denuncias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {denunciasFindFirstArgs} args - Arguments to find a Denuncias
     * @example
     * // Get one Denuncias
     * const denuncias = await prisma.denuncias.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends denunciasFindFirstArgs>(args?: SelectSubset<T, denunciasFindFirstArgs<ExtArgs>>): Prisma__denunciasClient<$Result.GetResult<Prisma.$denunciasPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Denuncias that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {denunciasFindFirstOrThrowArgs} args - Arguments to find a Denuncias
     * @example
     * // Get one Denuncias
     * const denuncias = await prisma.denuncias.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends denunciasFindFirstOrThrowArgs>(args?: SelectSubset<T, denunciasFindFirstOrThrowArgs<ExtArgs>>): Prisma__denunciasClient<$Result.GetResult<Prisma.$denunciasPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Denuncias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {denunciasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Denuncias
     * const denuncias = await prisma.denuncias.findMany()
     * 
     * // Get first 10 Denuncias
     * const denuncias = await prisma.denuncias.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const denunciasWithIdOnly = await prisma.denuncias.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends denunciasFindManyArgs>(args?: SelectSubset<T, denunciasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$denunciasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Denuncias.
     * @param {denunciasCreateArgs} args - Arguments to create a Denuncias.
     * @example
     * // Create one Denuncias
     * const Denuncias = await prisma.denuncias.create({
     *   data: {
     *     // ... data to create a Denuncias
     *   }
     * })
     * 
     */
    create<T extends denunciasCreateArgs>(args: SelectSubset<T, denunciasCreateArgs<ExtArgs>>): Prisma__denunciasClient<$Result.GetResult<Prisma.$denunciasPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Denuncias.
     * @param {denunciasCreateManyArgs} args - Arguments to create many Denuncias.
     * @example
     * // Create many Denuncias
     * const denuncias = await prisma.denuncias.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends denunciasCreateManyArgs>(args?: SelectSubset<T, denunciasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Denuncias and returns the data saved in the database.
     * @param {denunciasCreateManyAndReturnArgs} args - Arguments to create many Denuncias.
     * @example
     * // Create many Denuncias
     * const denuncias = await prisma.denuncias.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Denuncias and only return the `id`
     * const denunciasWithIdOnly = await prisma.denuncias.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends denunciasCreateManyAndReturnArgs>(args?: SelectSubset<T, denunciasCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$denunciasPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Denuncias.
     * @param {denunciasDeleteArgs} args - Arguments to delete one Denuncias.
     * @example
     * // Delete one Denuncias
     * const Denuncias = await prisma.denuncias.delete({
     *   where: {
     *     // ... filter to delete one Denuncias
     *   }
     * })
     * 
     */
    delete<T extends denunciasDeleteArgs>(args: SelectSubset<T, denunciasDeleteArgs<ExtArgs>>): Prisma__denunciasClient<$Result.GetResult<Prisma.$denunciasPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Denuncias.
     * @param {denunciasUpdateArgs} args - Arguments to update one Denuncias.
     * @example
     * // Update one Denuncias
     * const denuncias = await prisma.denuncias.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends denunciasUpdateArgs>(args: SelectSubset<T, denunciasUpdateArgs<ExtArgs>>): Prisma__denunciasClient<$Result.GetResult<Prisma.$denunciasPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Denuncias.
     * @param {denunciasDeleteManyArgs} args - Arguments to filter Denuncias to delete.
     * @example
     * // Delete a few Denuncias
     * const { count } = await prisma.denuncias.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends denunciasDeleteManyArgs>(args?: SelectSubset<T, denunciasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Denuncias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {denunciasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Denuncias
     * const denuncias = await prisma.denuncias.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends denunciasUpdateManyArgs>(args: SelectSubset<T, denunciasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Denuncias and returns the data updated in the database.
     * @param {denunciasUpdateManyAndReturnArgs} args - Arguments to update many Denuncias.
     * @example
     * // Update many Denuncias
     * const denuncias = await prisma.denuncias.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Denuncias and only return the `id`
     * const denunciasWithIdOnly = await prisma.denuncias.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends denunciasUpdateManyAndReturnArgs>(args: SelectSubset<T, denunciasUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$denunciasPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Denuncias.
     * @param {denunciasUpsertArgs} args - Arguments to update or create a Denuncias.
     * @example
     * // Update or create a Denuncias
     * const denuncias = await prisma.denuncias.upsert({
     *   create: {
     *     // ... data to create a Denuncias
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Denuncias we want to update
     *   }
     * })
     */
    upsert<T extends denunciasUpsertArgs>(args: SelectSubset<T, denunciasUpsertArgs<ExtArgs>>): Prisma__denunciasClient<$Result.GetResult<Prisma.$denunciasPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Denuncias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {denunciasCountArgs} args - Arguments to filter Denuncias to count.
     * @example
     * // Count the number of Denuncias
     * const count = await prisma.denuncias.count({
     *   where: {
     *     // ... the filter for the Denuncias we want to count
     *   }
     * })
    **/
    count<T extends denunciasCountArgs>(
      args?: Subset<T, denunciasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DenunciasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Denuncias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DenunciasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DenunciasAggregateArgs>(args: Subset<T, DenunciasAggregateArgs>): Prisma.PrismaPromise<GetDenunciasAggregateType<T>>

    /**
     * Group by Denuncias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {denunciasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends denunciasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: denunciasGroupByArgs['orderBy'] }
        : { orderBy?: denunciasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, denunciasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDenunciasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the denuncias model
   */
  readonly fields: denunciasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for denuncias.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__denunciasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the denuncias model
   */
  interface denunciasFieldRefs {
    readonly id: FieldRef<"denuncias", 'Int'>
    readonly autor_id: FieldRef<"denuncias", 'Int'>
    readonly alvo_id: FieldRef<"denuncias", 'Int'>
    readonly tipo_alvo: FieldRef<"denuncias", 'enum_denuncias_tipo_alvo'>
    readonly corrida_id: FieldRef<"denuncias", 'Int'>
    readonly motivo: FieldRef<"denuncias", 'String'>
    readonly descricao: FieldRef<"denuncias", 'String'>
    readonly status: FieldRef<"denuncias", 'enum_denuncias_status'>
    readonly data_denuncia: FieldRef<"denuncias", 'DateTime'>
    readonly createdAt: FieldRef<"denuncias", 'DateTime'>
    readonly updatedAt: FieldRef<"denuncias", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * denuncias findUnique
   */
  export type denunciasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the denuncias
     */
    select?: denunciasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the denuncias
     */
    omit?: denunciasOmit<ExtArgs> | null
    /**
     * Filter, which denuncias to fetch.
     */
    where: denunciasWhereUniqueInput
  }

  /**
   * denuncias findUniqueOrThrow
   */
  export type denunciasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the denuncias
     */
    select?: denunciasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the denuncias
     */
    omit?: denunciasOmit<ExtArgs> | null
    /**
     * Filter, which denuncias to fetch.
     */
    where: denunciasWhereUniqueInput
  }

  /**
   * denuncias findFirst
   */
  export type denunciasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the denuncias
     */
    select?: denunciasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the denuncias
     */
    omit?: denunciasOmit<ExtArgs> | null
    /**
     * Filter, which denuncias to fetch.
     */
    where?: denunciasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of denuncias to fetch.
     */
    orderBy?: denunciasOrderByWithRelationInput | denunciasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for denuncias.
     */
    cursor?: denunciasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` denuncias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` denuncias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of denuncias.
     */
    distinct?: DenunciasScalarFieldEnum | DenunciasScalarFieldEnum[]
  }

  /**
   * denuncias findFirstOrThrow
   */
  export type denunciasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the denuncias
     */
    select?: denunciasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the denuncias
     */
    omit?: denunciasOmit<ExtArgs> | null
    /**
     * Filter, which denuncias to fetch.
     */
    where?: denunciasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of denuncias to fetch.
     */
    orderBy?: denunciasOrderByWithRelationInput | denunciasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for denuncias.
     */
    cursor?: denunciasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` denuncias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` denuncias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of denuncias.
     */
    distinct?: DenunciasScalarFieldEnum | DenunciasScalarFieldEnum[]
  }

  /**
   * denuncias findMany
   */
  export type denunciasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the denuncias
     */
    select?: denunciasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the denuncias
     */
    omit?: denunciasOmit<ExtArgs> | null
    /**
     * Filter, which denuncias to fetch.
     */
    where?: denunciasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of denuncias to fetch.
     */
    orderBy?: denunciasOrderByWithRelationInput | denunciasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing denuncias.
     */
    cursor?: denunciasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` denuncias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` denuncias.
     */
    skip?: number
    distinct?: DenunciasScalarFieldEnum | DenunciasScalarFieldEnum[]
  }

  /**
   * denuncias create
   */
  export type denunciasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the denuncias
     */
    select?: denunciasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the denuncias
     */
    omit?: denunciasOmit<ExtArgs> | null
    /**
     * The data needed to create a denuncias.
     */
    data: XOR<denunciasCreateInput, denunciasUncheckedCreateInput>
  }

  /**
   * denuncias createMany
   */
  export type denunciasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many denuncias.
     */
    data: denunciasCreateManyInput | denunciasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * denuncias createManyAndReturn
   */
  export type denunciasCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the denuncias
     */
    select?: denunciasSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the denuncias
     */
    omit?: denunciasOmit<ExtArgs> | null
    /**
     * The data used to create many denuncias.
     */
    data: denunciasCreateManyInput | denunciasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * denuncias update
   */
  export type denunciasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the denuncias
     */
    select?: denunciasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the denuncias
     */
    omit?: denunciasOmit<ExtArgs> | null
    /**
     * The data needed to update a denuncias.
     */
    data: XOR<denunciasUpdateInput, denunciasUncheckedUpdateInput>
    /**
     * Choose, which denuncias to update.
     */
    where: denunciasWhereUniqueInput
  }

  /**
   * denuncias updateMany
   */
  export type denunciasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update denuncias.
     */
    data: XOR<denunciasUpdateManyMutationInput, denunciasUncheckedUpdateManyInput>
    /**
     * Filter which denuncias to update
     */
    where?: denunciasWhereInput
    /**
     * Limit how many denuncias to update.
     */
    limit?: number
  }

  /**
   * denuncias updateManyAndReturn
   */
  export type denunciasUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the denuncias
     */
    select?: denunciasSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the denuncias
     */
    omit?: denunciasOmit<ExtArgs> | null
    /**
     * The data used to update denuncias.
     */
    data: XOR<denunciasUpdateManyMutationInput, denunciasUncheckedUpdateManyInput>
    /**
     * Filter which denuncias to update
     */
    where?: denunciasWhereInput
    /**
     * Limit how many denuncias to update.
     */
    limit?: number
  }

  /**
   * denuncias upsert
   */
  export type denunciasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the denuncias
     */
    select?: denunciasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the denuncias
     */
    omit?: denunciasOmit<ExtArgs> | null
    /**
     * The filter to search for the denuncias to update in case it exists.
     */
    where: denunciasWhereUniqueInput
    /**
     * In case the denuncias found by the `where` argument doesn't exist, create a new denuncias with this data.
     */
    create: XOR<denunciasCreateInput, denunciasUncheckedCreateInput>
    /**
     * In case the denuncias was found with the provided `where` argument, update it with this data.
     */
    update: XOR<denunciasUpdateInput, denunciasUncheckedUpdateInput>
  }

  /**
   * denuncias delete
   */
  export type denunciasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the denuncias
     */
    select?: denunciasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the denuncias
     */
    omit?: denunciasOmit<ExtArgs> | null
    /**
     * Filter which denuncias to delete.
     */
    where: denunciasWhereUniqueInput
  }

  /**
   * denuncias deleteMany
   */
  export type denunciasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which denuncias to delete
     */
    where?: denunciasWhereInput
    /**
     * Limit how many denuncias to delete.
     */
    limit?: number
  }

  /**
   * denuncias without action
   */
  export type denunciasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the denuncias
     */
    select?: denunciasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the denuncias
     */
    omit?: denunciasOmit<ExtArgs> | null
  }


  /**
   * Model documentos
   */

  export type AggregateDocumentos = {
    _count: DocumentosCountAggregateOutputType | null
    _avg: DocumentosAvgAggregateOutputType | null
    _sum: DocumentosSumAggregateOutputType | null
    _min: DocumentosMinAggregateOutputType | null
    _max: DocumentosMaxAggregateOutputType | null
  }

  export type DocumentosAvgAggregateOutputType = {
    id: number | null
    usuario_id: number | null
  }

  export type DocumentosSumAggregateOutputType = {
    id: number | null
    usuario_id: number | null
  }

  export type DocumentosMinAggregateOutputType = {
    id: number | null
    usuario_id: number | null
    tipo_documento: $Enums.enum_Documentos_tipo_documento | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentosMaxAggregateOutputType = {
    id: number | null
    usuario_id: number | null
    tipo_documento: $Enums.enum_Documentos_tipo_documento | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentosCountAggregateOutputType = {
    id: number
    usuario_id: number
    tipo_documento: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DocumentosAvgAggregateInputType = {
    id?: true
    usuario_id?: true
  }

  export type DocumentosSumAggregateInputType = {
    id?: true
    usuario_id?: true
  }

  export type DocumentosMinAggregateInputType = {
    id?: true
    usuario_id?: true
    tipo_documento?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentosMaxAggregateInputType = {
    id?: true
    usuario_id?: true
    tipo_documento?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentosCountAggregateInputType = {
    id?: true
    usuario_id?: true
    tipo_documento?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DocumentosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which documentos to aggregate.
     */
    where?: documentosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of documentos to fetch.
     */
    orderBy?: documentosOrderByWithRelationInput | documentosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: documentosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` documentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` documentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned documentos
    **/
    _count?: true | DocumentosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentosMaxAggregateInputType
  }

  export type GetDocumentosAggregateType<T extends DocumentosAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumentos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumentos[P]>
      : GetScalarType<T[P], AggregateDocumentos[P]>
  }




  export type documentosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: documentosWhereInput
    orderBy?: documentosOrderByWithAggregationInput | documentosOrderByWithAggregationInput[]
    by: DocumentosScalarFieldEnum[] | DocumentosScalarFieldEnum
    having?: documentosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentosCountAggregateInputType | true
    _avg?: DocumentosAvgAggregateInputType
    _sum?: DocumentosSumAggregateInputType
    _min?: DocumentosMinAggregateInputType
    _max?: DocumentosMaxAggregateInputType
  }

  export type DocumentosGroupByOutputType = {
    id: number
    usuario_id: number
    tipo_documento: $Enums.enum_Documentos_tipo_documento
    createdAt: Date
    updatedAt: Date
    _count: DocumentosCountAggregateOutputType | null
    _avg: DocumentosAvgAggregateOutputType | null
    _sum: DocumentosSumAggregateOutputType | null
    _min: DocumentosMinAggregateOutputType | null
    _max: DocumentosMaxAggregateOutputType | null
  }

  type GetDocumentosGroupByPayload<T extends documentosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentosGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentosGroupByOutputType[P]>
        }
      >
    >


  export type documentosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    tipo_documento?: boolean
    arquivo_url?: boolean
    status?: boolean
    motivo_rejeicao?: boolean
    data_envio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["documentos"]>

  export type documentosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    tipo_documento?: boolean
    arquivo_url?: boolean
    status?: boolean
    motivo_rejeicao?: boolean
    data_envio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["documentos"]>

  export type documentosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    tipo_documento?: boolean
    arquivo_url?: boolean
    status?: boolean
    motivo_rejeicao?: boolean
    data_envio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["documentos"]>

  export type documentosSelectScalar = {
    id?: boolean
    usuario_id?: boolean
    tipo_documento?: boolean
    arquivo_url?: boolean
    status?: boolean
    motivo_rejeicao?: boolean
    data_envio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type documentosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "usuario_id" | "tipo_documento" | "arquivo_url" | "status" | "motivo_rejeicao" | "data_envio" | "createdAt" | "updatedAt", ExtArgs["result"]["documentos"]>

  export type $documentosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "documentos"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      usuario_id: number
      tipo_documento: $Enums.enum_documentos_tipo_documento
      arquivo_url: string
      status: $Enums.enum_documentos_status | null
      motivo_rejeicao: string | null
      data_envio: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["documentos"]>
    composites: {}
  }

  type documentosGetPayload<S extends boolean | null | undefined | documentosDefaultArgs> = $Result.GetResult<Prisma.$documentosPayload, S>

  type documentosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<documentosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentosCountAggregateInputType | true
    }

  export interface documentosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['documentos'], meta: { name: 'documentos' } }
    /**
     * Find zero or one Documentos that matches the filter.
     * @param {documentosFindUniqueArgs} args - Arguments to find a Documentos
     * @example
     * // Get one Documentos
     * const documentos = await prisma.documentos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends documentosFindUniqueArgs>(args: SelectSubset<T, documentosFindUniqueArgs<ExtArgs>>): Prisma__documentosClient<$Result.GetResult<Prisma.$documentosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Documentos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {documentosFindUniqueOrThrowArgs} args - Arguments to find a Documentos
     * @example
     * // Get one Documentos
     * const documentos = await prisma.documentos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends documentosFindUniqueOrThrowArgs>(args: SelectSubset<T, documentosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__documentosClient<$Result.GetResult<Prisma.$documentosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Documentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documentosFindFirstArgs} args - Arguments to find a Documentos
     * @example
     * // Get one Documentos
     * const documentos = await prisma.documentos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends documentosFindFirstArgs>(args?: SelectSubset<T, documentosFindFirstArgs<ExtArgs>>): Prisma__documentosClient<$Result.GetResult<Prisma.$documentosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Documentos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documentosFindFirstOrThrowArgs} args - Arguments to find a Documentos
     * @example
     * // Get one Documentos
     * const documentos = await prisma.documentos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends documentosFindFirstOrThrowArgs>(args?: SelectSubset<T, documentosFindFirstOrThrowArgs<ExtArgs>>): Prisma__documentosClient<$Result.GetResult<Prisma.$documentosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Documentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documentosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documentos
     * const documentos = await prisma.documentos.findMany()
     * 
     * // Get first 10 Documentos
     * const documentos = await prisma.documentos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentosWithIdOnly = await prisma.documentos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends documentosFindManyArgs>(args?: SelectSubset<T, documentosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$documentosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Documentos.
     * @param {documentosCreateArgs} args - Arguments to create a Documentos.
     * @example
     * // Create one Documentos
     * const Documentos = await prisma.documentos.create({
     *   data: {
     *     // ... data to create a Documentos
     *   }
     * })
     * 
     */
    create<T extends documentosCreateArgs>(args: SelectSubset<T, documentosCreateArgs<ExtArgs>>): Prisma__documentosClient<$Result.GetResult<Prisma.$documentosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Documentos.
     * @param {documentosCreateManyArgs} args - Arguments to create many Documentos.
     * @example
     * // Create many Documentos
     * const documentos = await prisma.documentos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends documentosCreateManyArgs>(args?: SelectSubset<T, documentosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Documentos and returns the data saved in the database.
     * @param {documentosCreateManyAndReturnArgs} args - Arguments to create many Documentos.
     * @example
     * // Create many Documentos
     * const documentos = await prisma.documentos.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Documentos and only return the `id`
     * const documentosWithIdOnly = await prisma.documentos.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends documentosCreateManyAndReturnArgs>(args?: SelectSubset<T, documentosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$documentosPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Documentos.
     * @param {documentosDeleteArgs} args - Arguments to delete one Documentos.
     * @example
     * // Delete one Documentos
     * const Documentos = await prisma.documentos.delete({
     *   where: {
     *     // ... filter to delete one Documentos
     *   }
     * })
     * 
     */
    delete<T extends documentosDeleteArgs>(args: SelectSubset<T, documentosDeleteArgs<ExtArgs>>): Prisma__documentosClient<$Result.GetResult<Prisma.$documentosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Documentos.
     * @param {documentosUpdateArgs} args - Arguments to update one Documentos.
     * @example
     * // Update one Documentos
     * const documentos = await prisma.documentos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends documentosUpdateArgs>(args: SelectSubset<T, documentosUpdateArgs<ExtArgs>>): Prisma__documentosClient<$Result.GetResult<Prisma.$documentosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Documentos.
     * @param {documentosDeleteManyArgs} args - Arguments to filter Documentos to delete.
     * @example
     * // Delete a few Documentos
     * const { count } = await prisma.documentos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends documentosDeleteManyArgs>(args?: SelectSubset<T, documentosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documentosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documentos
     * const documentos = await prisma.documentos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends documentosUpdateManyArgs>(args: SelectSubset<T, documentosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documentos and returns the data updated in the database.
     * @param {documentosUpdateManyAndReturnArgs} args - Arguments to update many Documentos.
     * @example
     * // Update many Documentos
     * const documentos = await prisma.documentos.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Documentos and only return the `id`
     * const documentosWithIdOnly = await prisma.documentos.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends documentosUpdateManyAndReturnArgs>(args: SelectSubset<T, documentosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$documentosPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Documentos.
     * @param {documentosUpsertArgs} args - Arguments to update or create a Documentos.
     * @example
     * // Update or create a Documentos
     * const documentos = await prisma.documentos.upsert({
     *   create: {
     *     // ... data to create a Documentos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Documentos we want to update
     *   }
     * })
     */
    upsert<T extends documentosUpsertArgs>(args: SelectSubset<T, documentosUpsertArgs<ExtArgs>>): Prisma__documentosClient<$Result.GetResult<Prisma.$documentosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Documentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documentosCountArgs} args - Arguments to filter Documentos to count.
     * @example
     * // Count the number of Documentos
     * const count = await prisma.documentos.count({
     *   where: {
     *     // ... the filter for the Documentos we want to count
     *   }
     * })
    **/
    count<T extends documentosCountArgs>(
      args?: Subset<T, documentosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Documentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentosAggregateArgs>(args: Subset<T, DocumentosAggregateArgs>): Prisma.PrismaPromise<GetDocumentosAggregateType<T>>

    /**
     * Group by Documentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documentosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends documentosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: documentosGroupByArgs['orderBy'] }
        : { orderBy?: documentosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, documentosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the documentos model
   */
  readonly fields: documentosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for documentos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__documentosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the documentos model
   */
  interface documentosFieldRefs {
    readonly id: FieldRef<"documentos", 'Int'>
    readonly usuario_id: FieldRef<"documentos", 'Int'>
    readonly tipo_documento: FieldRef<"documentos", 'enum_documentos_tipo_documento'>
    readonly arquivo_url: FieldRef<"documentos", 'String'>
    readonly status: FieldRef<"documentos", 'enum_documentos_status'>
    readonly motivo_rejeicao: FieldRef<"documentos", 'String'>
    readonly data_envio: FieldRef<"documentos", 'DateTime'>
    readonly createdAt: FieldRef<"documentos", 'DateTime'>
    readonly updatedAt: FieldRef<"documentos", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * documentos findUnique
   */
  export type documentosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documentos
     */
    select?: documentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the documentos
     */
    omit?: documentosOmit<ExtArgs> | null
    /**
     * Filter, which documentos to fetch.
     */
    where: documentosWhereUniqueInput
  }

  /**
   * documentos findUniqueOrThrow
   */
  export type documentosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documentos
     */
    select?: documentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the documentos
     */
    omit?: documentosOmit<ExtArgs> | null
    /**
     * Filter, which documentos to fetch.
     */
    where: documentosWhereUniqueInput
  }

  /**
   * documentos findFirst
   */
  export type documentosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documentos
     */
    select?: documentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the documentos
     */
    omit?: documentosOmit<ExtArgs> | null
    /**
     * Filter, which documentos to fetch.
     */
    where?: documentosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of documentos to fetch.
     */
    orderBy?: documentosOrderByWithRelationInput | documentosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for documentos.
     */
    cursor?: documentosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` documentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` documentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of documentos.
     */
    distinct?: DocumentosScalarFieldEnum | DocumentosScalarFieldEnum[]
  }

  /**
   * documentos findFirstOrThrow
   */
  export type documentosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documentos
     */
    select?: documentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the documentos
     */
    omit?: documentosOmit<ExtArgs> | null
    /**
     * Filter, which documentos to fetch.
     */
    where?: documentosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of documentos to fetch.
     */
    orderBy?: documentosOrderByWithRelationInput | documentosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for documentos.
     */
    cursor?: documentosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` documentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` documentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of documentos.
     */
    distinct?: DocumentosScalarFieldEnum | DocumentosScalarFieldEnum[]
  }

  /**
   * documentos findMany
   */
  export type documentosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documentos
     */
    select?: documentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the documentos
     */
    omit?: documentosOmit<ExtArgs> | null
    /**
     * Filter, which documentos to fetch.
     */
    where?: documentosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of documentos to fetch.
     */
    orderBy?: documentosOrderByWithRelationInput | documentosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing documentos.
     */
    cursor?: documentosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` documentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` documentos.
     */
    skip?: number
    distinct?: DocumentosScalarFieldEnum | DocumentosScalarFieldEnum[]
  }

  /**
   * documentos create
   */
  export type documentosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documentos
     */
    select?: documentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the documentos
     */
    omit?: documentosOmit<ExtArgs> | null
    /**
     * The data needed to create a documentos.
     */
    data: XOR<documentosCreateInput, documentosUncheckedCreateInput>
  }

  /**
   * documentos createMany
   */
  export type documentosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many documentos.
     */
    data: documentosCreateManyInput | documentosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * documentos createManyAndReturn
   */
  export type documentosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documentos
     */
    select?: documentosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the documentos
     */
    omit?: documentosOmit<ExtArgs> | null
    /**
     * The data used to create many documentos.
     */
    data: documentosCreateManyInput | documentosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * documentos update
   */
  export type documentosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documentos
     */
    select?: documentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the documentos
     */
    omit?: documentosOmit<ExtArgs> | null
    /**
     * The data needed to update a documentos.
     */
    data: XOR<documentosUpdateInput, documentosUncheckedUpdateInput>
    /**
     * Choose, which documentos to update.
     */
    where: documentosWhereUniqueInput
  }

  /**
   * documentos updateMany
   */
  export type documentosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update documentos.
     */
    data: XOR<documentosUpdateManyMutationInput, documentosUncheckedUpdateManyInput>
    /**
     * Filter which documentos to update
     */
    where?: documentosWhereInput
    /**
     * Limit how many documentos to update.
     */
    limit?: number
  }

  /**
   * documentos updateManyAndReturn
   */
  export type documentosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documentos
     */
    select?: documentosSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the documentos
     */
    omit?: documentosOmit<ExtArgs> | null
    /**
     * The data used to update documentos.
     */
    data: XOR<documentosUpdateManyMutationInput, documentosUncheckedUpdateManyInput>
    /**
     * Filter which documentos to update
     */
    where?: documentosWhereInput
    /**
     * Limit how many documentos to update.
     */
    limit?: number
  }

  /**
   * documentos upsert
   */
  export type documentosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documentos
     */
    select?: documentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the documentos
     */
    omit?: documentosOmit<ExtArgs> | null
    /**
     * The filter to search for the documentos to update in case it exists.
     */
    where: documentosWhereUniqueInput
    /**
     * In case the documentos found by the `where` argument doesn't exist, create a new documentos with this data.
     */
    create: XOR<documentosCreateInput, documentosUncheckedCreateInput>
    /**
     * In case the documentos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<documentosUpdateInput, documentosUncheckedUpdateInput>
  }

  /**
   * documentos delete
   */
  export type documentosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documentos
     */
    select?: documentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the documentos
     */
    omit?: documentosOmit<ExtArgs> | null
    /**
     * Filter which documentos to delete.
     */
    where: documentosWhereUniqueInput
  }

  /**
   * documentos deleteMany
   */
  export type documentosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which documentos to delete
     */
    where?: documentosWhereInput
    /**
     * Limit how many documentos to delete.
     */
    limit?: number
  }

  /**
   * documentos without action
   */
  export type documentosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documentos
     */
    select?: documentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the documentos
     */
    omit?: documentosOmit<ExtArgs> | null
  }


  /**
   * Model emails_enviados
   */

  export type AggregateEmails_enviados = {
    _count: Emails_enviadosCountAggregateOutputType | null
    _avg: Emails_enviadosAvgAggregateOutputType | null
    _sum: Emails_enviadosSumAggregateOutputType | null
    _min: Emails_enviadosMinAggregateOutputType | null
    _max: Emails_enviadosMaxAggregateOutputType | null
  }

  export type Emails_enviadosAvgAggregateOutputType = {
    id: number | null
    usuario_id: number | null
  }

  export type Emails_enviadosSumAggregateOutputType = {
    id: number | null
    usuario_id: number | null
  }

  export type Emails_enviadosMinAggregateOutputType = {
    id: number | null
    usuario_id: number | null
    email: string | null
    tipo: $Enums.enum_emails_enviados_tipo | null
    titulo: string | null
    conteudo: string | null
    status_envio: $Enums.enum_emails_enviados_status_envio | null
    data_envio: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Emails_enviadosMaxAggregateOutputType = {
    id: number | null
    usuario_id: number | null
    email: string | null
    tipo: $Enums.enum_emails_enviados_tipo | null
    titulo: string | null
    conteudo: string | null
    status_envio: $Enums.enum_emails_enviados_status_envio | null
    data_envio: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Emails_enviadosCountAggregateOutputType = {
    id: number
    usuario_id: number
    email: number
    tipo: number
    titulo: number
    conteudo: number
    status_envio: number
    data_envio: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Emails_enviadosAvgAggregateInputType = {
    id?: true
    usuario_id?: true
  }

  export type Emails_enviadosSumAggregateInputType = {
    id?: true
    usuario_id?: true
  }

  export type Emails_enviadosMinAggregateInputType = {
    id?: true
    usuario_id?: true
    email?: true
    tipo?: true
    titulo?: true
    conteudo?: true
    status_envio?: true
    data_envio?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Emails_enviadosMaxAggregateInputType = {
    id?: true
    usuario_id?: true
    email?: true
    tipo?: true
    titulo?: true
    conteudo?: true
    status_envio?: true
    data_envio?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Emails_enviadosCountAggregateInputType = {
    id?: true
    usuario_id?: true
    email?: true
    tipo?: true
    titulo?: true
    conteudo?: true
    status_envio?: true
    data_envio?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Emails_enviadosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which emails_enviados to aggregate.
     */
    where?: emails_enviadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of emails_enviados to fetch.
     */
    orderBy?: emails_enviadosOrderByWithRelationInput | emails_enviadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: emails_enviadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` emails_enviados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` emails_enviados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned emails_enviados
    **/
    _count?: true | Emails_enviadosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Emails_enviadosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Emails_enviadosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Emails_enviadosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Emails_enviadosMaxAggregateInputType
  }

  export type GetEmails_enviadosAggregateType<T extends Emails_enviadosAggregateArgs> = {
        [P in keyof T & keyof AggregateEmails_enviados]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmails_enviados[P]>
      : GetScalarType<T[P], AggregateEmails_enviados[P]>
  }




  export type emails_enviadosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: emails_enviadosWhereInput
    orderBy?: emails_enviadosOrderByWithAggregationInput | emails_enviadosOrderByWithAggregationInput[]
    by: Emails_enviadosScalarFieldEnum[] | Emails_enviadosScalarFieldEnum
    having?: emails_enviadosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Emails_enviadosCountAggregateInputType | true
    _avg?: Emails_enviadosAvgAggregateInputType
    _sum?: Emails_enviadosSumAggregateInputType
    _min?: Emails_enviadosMinAggregateInputType
    _max?: Emails_enviadosMaxAggregateInputType
  }

  export type Emails_enviadosGroupByOutputType = {
    id: number
    usuario_id: number
    email: string
    tipo: $Enums.enum_emails_enviados_tipo
    titulo: string
    conteudo: string | null
    status_envio: $Enums.enum_emails_enviados_status_envio | null
    data_envio: Date | null
    createdAt: Date
    updatedAt: Date
    _count: Emails_enviadosCountAggregateOutputType | null
    _avg: Emails_enviadosAvgAggregateOutputType | null
    _sum: Emails_enviadosSumAggregateOutputType | null
    _min: Emails_enviadosMinAggregateOutputType | null
    _max: Emails_enviadosMaxAggregateOutputType | null
  }

  type GetEmails_enviadosGroupByPayload<T extends emails_enviadosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Emails_enviadosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Emails_enviadosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Emails_enviadosGroupByOutputType[P]>
            : GetScalarType<T[P], Emails_enviadosGroupByOutputType[P]>
        }
      >
    >


  export type emails_enviadosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    email?: boolean
    tipo?: boolean
    titulo?: boolean
    conteudo?: boolean
    status_envio?: boolean
    data_envio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["emails_enviados"]>

  export type emails_enviadosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    email?: boolean
    tipo?: boolean
    titulo?: boolean
    conteudo?: boolean
    status_envio?: boolean
    data_envio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["emails_enviados"]>

  export type emails_enviadosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    email?: boolean
    tipo?: boolean
    titulo?: boolean
    conteudo?: boolean
    status_envio?: boolean
    data_envio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["emails_enviados"]>

  export type emails_enviadosSelectScalar = {
    id?: boolean
    usuario_id?: boolean
    email?: boolean
    tipo?: boolean
    titulo?: boolean
    conteudo?: boolean
    status_envio?: boolean
    data_envio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type emails_enviadosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "usuario_id" | "email" | "tipo" | "titulo" | "conteudo" | "status_envio" | "data_envio" | "createdAt" | "updatedAt", ExtArgs["result"]["emails_enviados"]>

  export type $emails_enviadosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "emails_enviados"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      usuario_id: number
      email: string
      tipo: $Enums.enum_emails_enviados_tipo
      titulo: string
      conteudo: string | null
      status_envio: $Enums.enum_emails_enviados_status_envio | null
      data_envio: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["emails_enviados"]>
    composites: {}
  }

  type emails_enviadosGetPayload<S extends boolean | null | undefined | emails_enviadosDefaultArgs> = $Result.GetResult<Prisma.$emails_enviadosPayload, S>

  type emails_enviadosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<emails_enviadosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Emails_enviadosCountAggregateInputType | true
    }

  export interface emails_enviadosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['emails_enviados'], meta: { name: 'emails_enviados' } }
    /**
     * Find zero or one Emails_enviados that matches the filter.
     * @param {emails_enviadosFindUniqueArgs} args - Arguments to find a Emails_enviados
     * @example
     * // Get one Emails_enviados
     * const emails_enviados = await prisma.emails_enviados.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends emails_enviadosFindUniqueArgs>(args: SelectSubset<T, emails_enviadosFindUniqueArgs<ExtArgs>>): Prisma__emails_enviadosClient<$Result.GetResult<Prisma.$emails_enviadosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Emails_enviados that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {emails_enviadosFindUniqueOrThrowArgs} args - Arguments to find a Emails_enviados
     * @example
     * // Get one Emails_enviados
     * const emails_enviados = await prisma.emails_enviados.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends emails_enviadosFindUniqueOrThrowArgs>(args: SelectSubset<T, emails_enviadosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__emails_enviadosClient<$Result.GetResult<Prisma.$emails_enviadosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Emails_enviados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {emails_enviadosFindFirstArgs} args - Arguments to find a Emails_enviados
     * @example
     * // Get one Emails_enviados
     * const emails_enviados = await prisma.emails_enviados.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends emails_enviadosFindFirstArgs>(args?: SelectSubset<T, emails_enviadosFindFirstArgs<ExtArgs>>): Prisma__emails_enviadosClient<$Result.GetResult<Prisma.$emails_enviadosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Emails_enviados that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {emails_enviadosFindFirstOrThrowArgs} args - Arguments to find a Emails_enviados
     * @example
     * // Get one Emails_enviados
     * const emails_enviados = await prisma.emails_enviados.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends emails_enviadosFindFirstOrThrowArgs>(args?: SelectSubset<T, emails_enviadosFindFirstOrThrowArgs<ExtArgs>>): Prisma__emails_enviadosClient<$Result.GetResult<Prisma.$emails_enviadosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Emails_enviados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {emails_enviadosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Emails_enviados
     * const emails_enviados = await prisma.emails_enviados.findMany()
     * 
     * // Get first 10 Emails_enviados
     * const emails_enviados = await prisma.emails_enviados.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emails_enviadosWithIdOnly = await prisma.emails_enviados.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends emails_enviadosFindManyArgs>(args?: SelectSubset<T, emails_enviadosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$emails_enviadosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Emails_enviados.
     * @param {emails_enviadosCreateArgs} args - Arguments to create a Emails_enviados.
     * @example
     * // Create one Emails_enviados
     * const Emails_enviados = await prisma.emails_enviados.create({
     *   data: {
     *     // ... data to create a Emails_enviados
     *   }
     * })
     * 
     */
    create<T extends emails_enviadosCreateArgs>(args: SelectSubset<T, emails_enviadosCreateArgs<ExtArgs>>): Prisma__emails_enviadosClient<$Result.GetResult<Prisma.$emails_enviadosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Emails_enviados.
     * @param {emails_enviadosCreateManyArgs} args - Arguments to create many Emails_enviados.
     * @example
     * // Create many Emails_enviados
     * const emails_enviados = await prisma.emails_enviados.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends emails_enviadosCreateManyArgs>(args?: SelectSubset<T, emails_enviadosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Emails_enviados and returns the data saved in the database.
     * @param {emails_enviadosCreateManyAndReturnArgs} args - Arguments to create many Emails_enviados.
     * @example
     * // Create many Emails_enviados
     * const emails_enviados = await prisma.emails_enviados.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Emails_enviados and only return the `id`
     * const emails_enviadosWithIdOnly = await prisma.emails_enviados.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends emails_enviadosCreateManyAndReturnArgs>(args?: SelectSubset<T, emails_enviadosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$emails_enviadosPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Emails_enviados.
     * @param {emails_enviadosDeleteArgs} args - Arguments to delete one Emails_enviados.
     * @example
     * // Delete one Emails_enviados
     * const Emails_enviados = await prisma.emails_enviados.delete({
     *   where: {
     *     // ... filter to delete one Emails_enviados
     *   }
     * })
     * 
     */
    delete<T extends emails_enviadosDeleteArgs>(args: SelectSubset<T, emails_enviadosDeleteArgs<ExtArgs>>): Prisma__emails_enviadosClient<$Result.GetResult<Prisma.$emails_enviadosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Emails_enviados.
     * @param {emails_enviadosUpdateArgs} args - Arguments to update one Emails_enviados.
     * @example
     * // Update one Emails_enviados
     * const emails_enviados = await prisma.emails_enviados.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends emails_enviadosUpdateArgs>(args: SelectSubset<T, emails_enviadosUpdateArgs<ExtArgs>>): Prisma__emails_enviadosClient<$Result.GetResult<Prisma.$emails_enviadosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Emails_enviados.
     * @param {emails_enviadosDeleteManyArgs} args - Arguments to filter Emails_enviados to delete.
     * @example
     * // Delete a few Emails_enviados
     * const { count } = await prisma.emails_enviados.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends emails_enviadosDeleteManyArgs>(args?: SelectSubset<T, emails_enviadosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Emails_enviados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {emails_enviadosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Emails_enviados
     * const emails_enviados = await prisma.emails_enviados.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends emails_enviadosUpdateManyArgs>(args: SelectSubset<T, emails_enviadosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Emails_enviados and returns the data updated in the database.
     * @param {emails_enviadosUpdateManyAndReturnArgs} args - Arguments to update many Emails_enviados.
     * @example
     * // Update many Emails_enviados
     * const emails_enviados = await prisma.emails_enviados.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Emails_enviados and only return the `id`
     * const emails_enviadosWithIdOnly = await prisma.emails_enviados.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends emails_enviadosUpdateManyAndReturnArgs>(args: SelectSubset<T, emails_enviadosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$emails_enviadosPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Emails_enviados.
     * @param {emails_enviadosUpsertArgs} args - Arguments to update or create a Emails_enviados.
     * @example
     * // Update or create a Emails_enviados
     * const emails_enviados = await prisma.emails_enviados.upsert({
     *   create: {
     *     // ... data to create a Emails_enviados
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Emails_enviados we want to update
     *   }
     * })
     */
    upsert<T extends emails_enviadosUpsertArgs>(args: SelectSubset<T, emails_enviadosUpsertArgs<ExtArgs>>): Prisma__emails_enviadosClient<$Result.GetResult<Prisma.$emails_enviadosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Emails_enviados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {emails_enviadosCountArgs} args - Arguments to filter Emails_enviados to count.
     * @example
     * // Count the number of Emails_enviados
     * const count = await prisma.emails_enviados.count({
     *   where: {
     *     // ... the filter for the Emails_enviados we want to count
     *   }
     * })
    **/
    count<T extends emails_enviadosCountArgs>(
      args?: Subset<T, emails_enviadosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Emails_enviadosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Emails_enviados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Emails_enviadosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Emails_enviadosAggregateArgs>(args: Subset<T, Emails_enviadosAggregateArgs>): Prisma.PrismaPromise<GetEmails_enviadosAggregateType<T>>

    /**
     * Group by Emails_enviados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {emails_enviadosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends emails_enviadosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: emails_enviadosGroupByArgs['orderBy'] }
        : { orderBy?: emails_enviadosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, emails_enviadosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmails_enviadosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the emails_enviados model
   */
  readonly fields: emails_enviadosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for emails_enviados.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__emails_enviadosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the emails_enviados model
   */
  interface emails_enviadosFieldRefs {
    readonly id: FieldRef<"emails_enviados", 'Int'>
    readonly usuario_id: FieldRef<"emails_enviados", 'Int'>
    readonly email: FieldRef<"emails_enviados", 'String'>
    readonly tipo: FieldRef<"emails_enviados", 'enum_emails_enviados_tipo'>
    readonly titulo: FieldRef<"emails_enviados", 'String'>
    readonly conteudo: FieldRef<"emails_enviados", 'String'>
    readonly status_envio: FieldRef<"emails_enviados", 'enum_emails_enviados_status_envio'>
    readonly data_envio: FieldRef<"emails_enviados", 'DateTime'>
    readonly createdAt: FieldRef<"emails_enviados", 'DateTime'>
    readonly updatedAt: FieldRef<"emails_enviados", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * emails_enviados findUnique
   */
  export type emails_enviadosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the emails_enviados
     */
    select?: emails_enviadosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the emails_enviados
     */
    omit?: emails_enviadosOmit<ExtArgs> | null
    /**
     * Filter, which emails_enviados to fetch.
     */
    where: emails_enviadosWhereUniqueInput
  }

  /**
   * emails_enviados findUniqueOrThrow
   */
  export type emails_enviadosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the emails_enviados
     */
    select?: emails_enviadosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the emails_enviados
     */
    omit?: emails_enviadosOmit<ExtArgs> | null
    /**
     * Filter, which emails_enviados to fetch.
     */
    where: emails_enviadosWhereUniqueInput
  }

  /**
   * emails_enviados findFirst
   */
  export type emails_enviadosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the emails_enviados
     */
    select?: emails_enviadosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the emails_enviados
     */
    omit?: emails_enviadosOmit<ExtArgs> | null
    /**
     * Filter, which emails_enviados to fetch.
     */
    where?: emails_enviadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of emails_enviados to fetch.
     */
    orderBy?: emails_enviadosOrderByWithRelationInput | emails_enviadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for emails_enviados.
     */
    cursor?: emails_enviadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` emails_enviados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` emails_enviados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of emails_enviados.
     */
    distinct?: Emails_enviadosScalarFieldEnum | Emails_enviadosScalarFieldEnum[]
  }

  /**
   * emails_enviados findFirstOrThrow
   */
  export type emails_enviadosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the emails_enviados
     */
    select?: emails_enviadosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the emails_enviados
     */
    omit?: emails_enviadosOmit<ExtArgs> | null
    /**
     * Filter, which emails_enviados to fetch.
     */
    where?: emails_enviadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of emails_enviados to fetch.
     */
    orderBy?: emails_enviadosOrderByWithRelationInput | emails_enviadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for emails_enviados.
     */
    cursor?: emails_enviadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` emails_enviados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` emails_enviados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of emails_enviados.
     */
    distinct?: Emails_enviadosScalarFieldEnum | Emails_enviadosScalarFieldEnum[]
  }

  /**
   * emails_enviados findMany
   */
  export type emails_enviadosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the emails_enviados
     */
    select?: emails_enviadosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the emails_enviados
     */
    omit?: emails_enviadosOmit<ExtArgs> | null
    /**
     * Filter, which emails_enviados to fetch.
     */
    where?: emails_enviadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of emails_enviados to fetch.
     */
    orderBy?: emails_enviadosOrderByWithRelationInput | emails_enviadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing emails_enviados.
     */
    cursor?: emails_enviadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` emails_enviados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` emails_enviados.
     */
    skip?: number
    distinct?: Emails_enviadosScalarFieldEnum | Emails_enviadosScalarFieldEnum[]
  }

  /**
   * emails_enviados create
   */
  export type emails_enviadosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the emails_enviados
     */
    select?: emails_enviadosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the emails_enviados
     */
    omit?: emails_enviadosOmit<ExtArgs> | null
    /**
     * The data needed to create a emails_enviados.
     */
    data: XOR<emails_enviadosCreateInput, emails_enviadosUncheckedCreateInput>
  }

  /**
   * emails_enviados createMany
   */
  export type emails_enviadosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many emails_enviados.
     */
    data: emails_enviadosCreateManyInput | emails_enviadosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * emails_enviados createManyAndReturn
   */
  export type emails_enviadosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the emails_enviados
     */
    select?: emails_enviadosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the emails_enviados
     */
    omit?: emails_enviadosOmit<ExtArgs> | null
    /**
     * The data used to create many emails_enviados.
     */
    data: emails_enviadosCreateManyInput | emails_enviadosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * emails_enviados update
   */
  export type emails_enviadosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the emails_enviados
     */
    select?: emails_enviadosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the emails_enviados
     */
    omit?: emails_enviadosOmit<ExtArgs> | null
    /**
     * The data needed to update a emails_enviados.
     */
    data: XOR<emails_enviadosUpdateInput, emails_enviadosUncheckedUpdateInput>
    /**
     * Choose, which emails_enviados to update.
     */
    where: emails_enviadosWhereUniqueInput
  }

  /**
   * emails_enviados updateMany
   */
  export type emails_enviadosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update emails_enviados.
     */
    data: XOR<emails_enviadosUpdateManyMutationInput, emails_enviadosUncheckedUpdateManyInput>
    /**
     * Filter which emails_enviados to update
     */
    where?: emails_enviadosWhereInput
    /**
     * Limit how many emails_enviados to update.
     */
    limit?: number
  }

  /**
   * emails_enviados updateManyAndReturn
   */
  export type emails_enviadosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the emails_enviados
     */
    select?: emails_enviadosSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the emails_enviados
     */
    omit?: emails_enviadosOmit<ExtArgs> | null
    /**
     * The data used to update emails_enviados.
     */
    data: XOR<emails_enviadosUpdateManyMutationInput, emails_enviadosUncheckedUpdateManyInput>
    /**
     * Filter which emails_enviados to update
     */
    where?: emails_enviadosWhereInput
    /**
     * Limit how many emails_enviados to update.
     */
    limit?: number
  }

  /**
   * emails_enviados upsert
   */
  export type emails_enviadosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the emails_enviados
     */
    select?: emails_enviadosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the emails_enviados
     */
    omit?: emails_enviadosOmit<ExtArgs> | null
    /**
     * The filter to search for the emails_enviados to update in case it exists.
     */
    where: emails_enviadosWhereUniqueInput
    /**
     * In case the emails_enviados found by the `where` argument doesn't exist, create a new emails_enviados with this data.
     */
    create: XOR<emails_enviadosCreateInput, emails_enviadosUncheckedCreateInput>
    /**
     * In case the emails_enviados was found with the provided `where` argument, update it with this data.
     */
    update: XOR<emails_enviadosUpdateInput, emails_enviadosUncheckedUpdateInput>
  }

  /**
   * emails_enviados delete
   */
  export type emails_enviadosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the emails_enviados
     */
    select?: emails_enviadosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the emails_enviados
     */
    omit?: emails_enviadosOmit<ExtArgs> | null
    /**
     * Filter which emails_enviados to delete.
     */
    where: emails_enviadosWhereUniqueInput
  }

  /**
   * emails_enviados deleteMany
   */
  export type emails_enviadosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which emails_enviados to delete
     */
    where?: emails_enviadosWhereInput
    /**
     * Limit how many emails_enviados to delete.
     */
    limit?: number
  }

  /**
   * emails_enviados without action
   */
  export type emails_enviadosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the emails_enviados
     */
    select?: emails_enviadosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the emails_enviados
     */
    omit?: emails_enviadosOmit<ExtArgs> | null
  }


  /**
   * Model historico_indicacoes
   */

  export type AggregateHistorico_indicacoes = {
    _count: Historico_indicacoesCountAggregateOutputType | null
    _avg: Historico_indicacoesAvgAggregateOutputType | null
    _sum: Historico_indicacoesSumAggregateOutputType | null
    _min: Historico_indicacoesMinAggregateOutputType | null
    _max: Historico_indicacoesMaxAggregateOutputType | null
  }

  export type Historico_indicacoesAvgAggregateOutputType = {
    id: number | null
    indicador_id: number | null
    indicado_id: number | null
  }

  export type Historico_indicacoesSumAggregateOutputType = {
    id: number | null
    indicador_id: number | null
    indicado_id: number | null
  }

  export type Historico_indicacoesMinAggregateOutputType = {
    id: number | null
    indicador_id: number | null
    indicado_id: number | null
    tipo: $Enums.enum_historico_indicacoes_tipo | null
    data_vinculo: Date | null
    codigo_utilizado: string | null
    ativo: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Historico_indicacoesMaxAggregateOutputType = {
    id: number | null
    indicador_id: number | null
    indicado_id: number | null
    tipo: $Enums.enum_historico_indicacoes_tipo | null
    data_vinculo: Date | null
    codigo_utilizado: string | null
    ativo: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Historico_indicacoesCountAggregateOutputType = {
    id: number
    indicador_id: number
    indicado_id: number
    tipo: number
    data_vinculo: number
    codigo_utilizado: number
    ativo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Historico_indicacoesAvgAggregateInputType = {
    id?: true
    indicador_id?: true
    indicado_id?: true
  }

  export type Historico_indicacoesSumAggregateInputType = {
    id?: true
    indicador_id?: true
    indicado_id?: true
  }

  export type Historico_indicacoesMinAggregateInputType = {
    id?: true
    indicador_id?: true
    indicado_id?: true
    tipo?: true
    data_vinculo?: true
    codigo_utilizado?: true
    ativo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Historico_indicacoesMaxAggregateInputType = {
    id?: true
    indicador_id?: true
    indicado_id?: true
    tipo?: true
    data_vinculo?: true
    codigo_utilizado?: true
    ativo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Historico_indicacoesCountAggregateInputType = {
    id?: true
    indicador_id?: true
    indicado_id?: true
    tipo?: true
    data_vinculo?: true
    codigo_utilizado?: true
    ativo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Historico_indicacoesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which historico_indicacoes to aggregate.
     */
    where?: historico_indicacoesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historico_indicacoes to fetch.
     */
    orderBy?: historico_indicacoesOrderByWithRelationInput | historico_indicacoesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: historico_indicacoesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historico_indicacoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historico_indicacoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned historico_indicacoes
    **/
    _count?: true | Historico_indicacoesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Historico_indicacoesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Historico_indicacoesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Historico_indicacoesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Historico_indicacoesMaxAggregateInputType
  }

  export type GetHistorico_indicacoesAggregateType<T extends Historico_indicacoesAggregateArgs> = {
        [P in keyof T & keyof AggregateHistorico_indicacoes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHistorico_indicacoes[P]>
      : GetScalarType<T[P], AggregateHistorico_indicacoes[P]>
  }




  export type historico_indicacoesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: historico_indicacoesWhereInput
    orderBy?: historico_indicacoesOrderByWithAggregationInput | historico_indicacoesOrderByWithAggregationInput[]
    by: Historico_indicacoesScalarFieldEnum[] | Historico_indicacoesScalarFieldEnum
    having?: historico_indicacoesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Historico_indicacoesCountAggregateInputType | true
    _avg?: Historico_indicacoesAvgAggregateInputType
    _sum?: Historico_indicacoesSumAggregateInputType
    _min?: Historico_indicacoesMinAggregateInputType
    _max?: Historico_indicacoesMaxAggregateInputType
  }

  export type Historico_indicacoesGroupByOutputType = {
    id: number
    indicador_id: number
    indicado_id: number
    tipo: $Enums.enum_historico_indicacoes_tipo
    data_vinculo: Date | null
    codigo_utilizado: string | null
    ativo: boolean | null
    createdAt: Date
    updatedAt: Date
    _count: Historico_indicacoesCountAggregateOutputType | null
    _avg: Historico_indicacoesAvgAggregateOutputType | null
    _sum: Historico_indicacoesSumAggregateOutputType | null
    _min: Historico_indicacoesMinAggregateOutputType | null
    _max: Historico_indicacoesMaxAggregateOutputType | null
  }

  type GetHistorico_indicacoesGroupByPayload<T extends historico_indicacoesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Historico_indicacoesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Historico_indicacoesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Historico_indicacoesGroupByOutputType[P]>
            : GetScalarType<T[P], Historico_indicacoesGroupByOutputType[P]>
        }
      >
    >


  export type historico_indicacoesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    indicador_id?: boolean
    indicado_id?: boolean
    tipo?: boolean
    data_vinculo?: boolean
    codigo_utilizado?: boolean
    ativo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["historico_indicacoes"]>

  export type historico_indicacoesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    indicador_id?: boolean
    indicado_id?: boolean
    tipo?: boolean
    data_vinculo?: boolean
    codigo_utilizado?: boolean
    ativo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["historico_indicacoes"]>

  export type historico_indicacoesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    indicador_id?: boolean
    indicado_id?: boolean
    tipo?: boolean
    data_vinculo?: boolean
    codigo_utilizado?: boolean
    ativo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["historico_indicacoes"]>

  export type historico_indicacoesSelectScalar = {
    id?: boolean
    indicador_id?: boolean
    indicado_id?: boolean
    tipo?: boolean
    data_vinculo?: boolean
    codigo_utilizado?: boolean
    ativo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type historico_indicacoesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "indicador_id" | "indicado_id" | "tipo" | "data_vinculo" | "codigo_utilizado" | "ativo" | "createdAt" | "updatedAt", ExtArgs["result"]["historico_indicacoes"]>

  export type $historico_indicacoesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "historico_indicacoes"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      indicador_id: number
      indicado_id: number
      tipo: $Enums.enum_historico_indicacoes_tipo
      data_vinculo: Date | null
      codigo_utilizado: string | null
      ativo: boolean | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["historico_indicacoes"]>
    composites: {}
  }

  type historico_indicacoesGetPayload<S extends boolean | null | undefined | historico_indicacoesDefaultArgs> = $Result.GetResult<Prisma.$historico_indicacoesPayload, S>

  type historico_indicacoesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<historico_indicacoesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Historico_indicacoesCountAggregateInputType | true
    }

  export interface historico_indicacoesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['historico_indicacoes'], meta: { name: 'historico_indicacoes' } }
    /**
     * Find zero or one Historico_indicacoes that matches the filter.
     * @param {historico_indicacoesFindUniqueArgs} args - Arguments to find a Historico_indicacoes
     * @example
     * // Get one Historico_indicacoes
     * const historico_indicacoes = await prisma.historico_indicacoes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends historico_indicacoesFindUniqueArgs>(args: SelectSubset<T, historico_indicacoesFindUniqueArgs<ExtArgs>>): Prisma__historico_indicacoesClient<$Result.GetResult<Prisma.$historico_indicacoesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Historico_indicacoes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {historico_indicacoesFindUniqueOrThrowArgs} args - Arguments to find a Historico_indicacoes
     * @example
     * // Get one Historico_indicacoes
     * const historico_indicacoes = await prisma.historico_indicacoes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends historico_indicacoesFindUniqueOrThrowArgs>(args: SelectSubset<T, historico_indicacoesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__historico_indicacoesClient<$Result.GetResult<Prisma.$historico_indicacoesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Historico_indicacoes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historico_indicacoesFindFirstArgs} args - Arguments to find a Historico_indicacoes
     * @example
     * // Get one Historico_indicacoes
     * const historico_indicacoes = await prisma.historico_indicacoes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends historico_indicacoesFindFirstArgs>(args?: SelectSubset<T, historico_indicacoesFindFirstArgs<ExtArgs>>): Prisma__historico_indicacoesClient<$Result.GetResult<Prisma.$historico_indicacoesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Historico_indicacoes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historico_indicacoesFindFirstOrThrowArgs} args - Arguments to find a Historico_indicacoes
     * @example
     * // Get one Historico_indicacoes
     * const historico_indicacoes = await prisma.historico_indicacoes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends historico_indicacoesFindFirstOrThrowArgs>(args?: SelectSubset<T, historico_indicacoesFindFirstOrThrowArgs<ExtArgs>>): Prisma__historico_indicacoesClient<$Result.GetResult<Prisma.$historico_indicacoesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Historico_indicacoes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historico_indicacoesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Historico_indicacoes
     * const historico_indicacoes = await prisma.historico_indicacoes.findMany()
     * 
     * // Get first 10 Historico_indicacoes
     * const historico_indicacoes = await prisma.historico_indicacoes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const historico_indicacoesWithIdOnly = await prisma.historico_indicacoes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends historico_indicacoesFindManyArgs>(args?: SelectSubset<T, historico_indicacoesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$historico_indicacoesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Historico_indicacoes.
     * @param {historico_indicacoesCreateArgs} args - Arguments to create a Historico_indicacoes.
     * @example
     * // Create one Historico_indicacoes
     * const Historico_indicacoes = await prisma.historico_indicacoes.create({
     *   data: {
     *     // ... data to create a Historico_indicacoes
     *   }
     * })
     * 
     */
    create<T extends historico_indicacoesCreateArgs>(args: SelectSubset<T, historico_indicacoesCreateArgs<ExtArgs>>): Prisma__historico_indicacoesClient<$Result.GetResult<Prisma.$historico_indicacoesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Historico_indicacoes.
     * @param {historico_indicacoesCreateManyArgs} args - Arguments to create many Historico_indicacoes.
     * @example
     * // Create many Historico_indicacoes
     * const historico_indicacoes = await prisma.historico_indicacoes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends historico_indicacoesCreateManyArgs>(args?: SelectSubset<T, historico_indicacoesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Historico_indicacoes and returns the data saved in the database.
     * @param {historico_indicacoesCreateManyAndReturnArgs} args - Arguments to create many Historico_indicacoes.
     * @example
     * // Create many Historico_indicacoes
     * const historico_indicacoes = await prisma.historico_indicacoes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Historico_indicacoes and only return the `id`
     * const historico_indicacoesWithIdOnly = await prisma.historico_indicacoes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends historico_indicacoesCreateManyAndReturnArgs>(args?: SelectSubset<T, historico_indicacoesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$historico_indicacoesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Historico_indicacoes.
     * @param {historico_indicacoesDeleteArgs} args - Arguments to delete one Historico_indicacoes.
     * @example
     * // Delete one Historico_indicacoes
     * const Historico_indicacoes = await prisma.historico_indicacoes.delete({
     *   where: {
     *     // ... filter to delete one Historico_indicacoes
     *   }
     * })
     * 
     */
    delete<T extends historico_indicacoesDeleteArgs>(args: SelectSubset<T, historico_indicacoesDeleteArgs<ExtArgs>>): Prisma__historico_indicacoesClient<$Result.GetResult<Prisma.$historico_indicacoesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Historico_indicacoes.
     * @param {historico_indicacoesUpdateArgs} args - Arguments to update one Historico_indicacoes.
     * @example
     * // Update one Historico_indicacoes
     * const historico_indicacoes = await prisma.historico_indicacoes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends historico_indicacoesUpdateArgs>(args: SelectSubset<T, historico_indicacoesUpdateArgs<ExtArgs>>): Prisma__historico_indicacoesClient<$Result.GetResult<Prisma.$historico_indicacoesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Historico_indicacoes.
     * @param {historico_indicacoesDeleteManyArgs} args - Arguments to filter Historico_indicacoes to delete.
     * @example
     * // Delete a few Historico_indicacoes
     * const { count } = await prisma.historico_indicacoes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends historico_indicacoesDeleteManyArgs>(args?: SelectSubset<T, historico_indicacoesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Historico_indicacoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historico_indicacoesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Historico_indicacoes
     * const historico_indicacoes = await prisma.historico_indicacoes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends historico_indicacoesUpdateManyArgs>(args: SelectSubset<T, historico_indicacoesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Historico_indicacoes and returns the data updated in the database.
     * @param {historico_indicacoesUpdateManyAndReturnArgs} args - Arguments to update many Historico_indicacoes.
     * @example
     * // Update many Historico_indicacoes
     * const historico_indicacoes = await prisma.historico_indicacoes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Historico_indicacoes and only return the `id`
     * const historico_indicacoesWithIdOnly = await prisma.historico_indicacoes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends historico_indicacoesUpdateManyAndReturnArgs>(args: SelectSubset<T, historico_indicacoesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$historico_indicacoesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Historico_indicacoes.
     * @param {historico_indicacoesUpsertArgs} args - Arguments to update or create a Historico_indicacoes.
     * @example
     * // Update or create a Historico_indicacoes
     * const historico_indicacoes = await prisma.historico_indicacoes.upsert({
     *   create: {
     *     // ... data to create a Historico_indicacoes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Historico_indicacoes we want to update
     *   }
     * })
     */
    upsert<T extends historico_indicacoesUpsertArgs>(args: SelectSubset<T, historico_indicacoesUpsertArgs<ExtArgs>>): Prisma__historico_indicacoesClient<$Result.GetResult<Prisma.$historico_indicacoesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Historico_indicacoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historico_indicacoesCountArgs} args - Arguments to filter Historico_indicacoes to count.
     * @example
     * // Count the number of Historico_indicacoes
     * const count = await prisma.historico_indicacoes.count({
     *   where: {
     *     // ... the filter for the Historico_indicacoes we want to count
     *   }
     * })
    **/
    count<T extends historico_indicacoesCountArgs>(
      args?: Subset<T, historico_indicacoesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Historico_indicacoesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Historico_indicacoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Historico_indicacoesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Historico_indicacoesAggregateArgs>(args: Subset<T, Historico_indicacoesAggregateArgs>): Prisma.PrismaPromise<GetHistorico_indicacoesAggregateType<T>>

    /**
     * Group by Historico_indicacoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historico_indicacoesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends historico_indicacoesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: historico_indicacoesGroupByArgs['orderBy'] }
        : { orderBy?: historico_indicacoesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, historico_indicacoesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHistorico_indicacoesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the historico_indicacoes model
   */
  readonly fields: historico_indicacoesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for historico_indicacoes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__historico_indicacoesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the historico_indicacoes model
   */
  interface historico_indicacoesFieldRefs {
    readonly id: FieldRef<"historico_indicacoes", 'Int'>
    readonly indicador_id: FieldRef<"historico_indicacoes", 'Int'>
    readonly indicado_id: FieldRef<"historico_indicacoes", 'Int'>
    readonly tipo: FieldRef<"historico_indicacoes", 'enum_historico_indicacoes_tipo'>
    readonly data_vinculo: FieldRef<"historico_indicacoes", 'DateTime'>
    readonly codigo_utilizado: FieldRef<"historico_indicacoes", 'String'>
    readonly ativo: FieldRef<"historico_indicacoes", 'Boolean'>
    readonly createdAt: FieldRef<"historico_indicacoes", 'DateTime'>
    readonly updatedAt: FieldRef<"historico_indicacoes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * historico_indicacoes findUnique
   */
  export type historico_indicacoesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historico_indicacoes
     */
    select?: historico_indicacoesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the historico_indicacoes
     */
    omit?: historico_indicacoesOmit<ExtArgs> | null
    /**
     * Filter, which historico_indicacoes to fetch.
     */
    where: historico_indicacoesWhereUniqueInput
  }

  /**
   * historico_indicacoes findUniqueOrThrow
   */
  export type historico_indicacoesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historico_indicacoes
     */
    select?: historico_indicacoesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the historico_indicacoes
     */
    omit?: historico_indicacoesOmit<ExtArgs> | null
    /**
     * Filter, which historico_indicacoes to fetch.
     */
    where: historico_indicacoesWhereUniqueInput
  }

  /**
   * historico_indicacoes findFirst
   */
  export type historico_indicacoesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historico_indicacoes
     */
    select?: historico_indicacoesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the historico_indicacoes
     */
    omit?: historico_indicacoesOmit<ExtArgs> | null
    /**
     * Filter, which historico_indicacoes to fetch.
     */
    where?: historico_indicacoesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historico_indicacoes to fetch.
     */
    orderBy?: historico_indicacoesOrderByWithRelationInput | historico_indicacoesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for historico_indicacoes.
     */
    cursor?: historico_indicacoesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historico_indicacoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historico_indicacoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of historico_indicacoes.
     */
    distinct?: Historico_indicacoesScalarFieldEnum | Historico_indicacoesScalarFieldEnum[]
  }

  /**
   * historico_indicacoes findFirstOrThrow
   */
  export type historico_indicacoesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historico_indicacoes
     */
    select?: historico_indicacoesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the historico_indicacoes
     */
    omit?: historico_indicacoesOmit<ExtArgs> | null
    /**
     * Filter, which historico_indicacoes to fetch.
     */
    where?: historico_indicacoesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historico_indicacoes to fetch.
     */
    orderBy?: historico_indicacoesOrderByWithRelationInput | historico_indicacoesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for historico_indicacoes.
     */
    cursor?: historico_indicacoesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historico_indicacoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historico_indicacoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of historico_indicacoes.
     */
    distinct?: Historico_indicacoesScalarFieldEnum | Historico_indicacoesScalarFieldEnum[]
  }

  /**
   * historico_indicacoes findMany
   */
  export type historico_indicacoesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historico_indicacoes
     */
    select?: historico_indicacoesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the historico_indicacoes
     */
    omit?: historico_indicacoesOmit<ExtArgs> | null
    /**
     * Filter, which historico_indicacoes to fetch.
     */
    where?: historico_indicacoesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historico_indicacoes to fetch.
     */
    orderBy?: historico_indicacoesOrderByWithRelationInput | historico_indicacoesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing historico_indicacoes.
     */
    cursor?: historico_indicacoesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historico_indicacoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historico_indicacoes.
     */
    skip?: number
    distinct?: Historico_indicacoesScalarFieldEnum | Historico_indicacoesScalarFieldEnum[]
  }

  /**
   * historico_indicacoes create
   */
  export type historico_indicacoesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historico_indicacoes
     */
    select?: historico_indicacoesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the historico_indicacoes
     */
    omit?: historico_indicacoesOmit<ExtArgs> | null
    /**
     * The data needed to create a historico_indicacoes.
     */
    data: XOR<historico_indicacoesCreateInput, historico_indicacoesUncheckedCreateInput>
  }

  /**
   * historico_indicacoes createMany
   */
  export type historico_indicacoesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many historico_indicacoes.
     */
    data: historico_indicacoesCreateManyInput | historico_indicacoesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * historico_indicacoes createManyAndReturn
   */
  export type historico_indicacoesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historico_indicacoes
     */
    select?: historico_indicacoesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the historico_indicacoes
     */
    omit?: historico_indicacoesOmit<ExtArgs> | null
    /**
     * The data used to create many historico_indicacoes.
     */
    data: historico_indicacoesCreateManyInput | historico_indicacoesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * historico_indicacoes update
   */
  export type historico_indicacoesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historico_indicacoes
     */
    select?: historico_indicacoesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the historico_indicacoes
     */
    omit?: historico_indicacoesOmit<ExtArgs> | null
    /**
     * The data needed to update a historico_indicacoes.
     */
    data: XOR<historico_indicacoesUpdateInput, historico_indicacoesUncheckedUpdateInput>
    /**
     * Choose, which historico_indicacoes to update.
     */
    where: historico_indicacoesWhereUniqueInput
  }

  /**
   * historico_indicacoes updateMany
   */
  export type historico_indicacoesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update historico_indicacoes.
     */
    data: XOR<historico_indicacoesUpdateManyMutationInput, historico_indicacoesUncheckedUpdateManyInput>
    /**
     * Filter which historico_indicacoes to update
     */
    where?: historico_indicacoesWhereInput
    /**
     * Limit how many historico_indicacoes to update.
     */
    limit?: number
  }

  /**
   * historico_indicacoes updateManyAndReturn
   */
  export type historico_indicacoesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historico_indicacoes
     */
    select?: historico_indicacoesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the historico_indicacoes
     */
    omit?: historico_indicacoesOmit<ExtArgs> | null
    /**
     * The data used to update historico_indicacoes.
     */
    data: XOR<historico_indicacoesUpdateManyMutationInput, historico_indicacoesUncheckedUpdateManyInput>
    /**
     * Filter which historico_indicacoes to update
     */
    where?: historico_indicacoesWhereInput
    /**
     * Limit how many historico_indicacoes to update.
     */
    limit?: number
  }

  /**
   * historico_indicacoes upsert
   */
  export type historico_indicacoesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historico_indicacoes
     */
    select?: historico_indicacoesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the historico_indicacoes
     */
    omit?: historico_indicacoesOmit<ExtArgs> | null
    /**
     * The filter to search for the historico_indicacoes to update in case it exists.
     */
    where: historico_indicacoesWhereUniqueInput
    /**
     * In case the historico_indicacoes found by the `where` argument doesn't exist, create a new historico_indicacoes with this data.
     */
    create: XOR<historico_indicacoesCreateInput, historico_indicacoesUncheckedCreateInput>
    /**
     * In case the historico_indicacoes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<historico_indicacoesUpdateInput, historico_indicacoesUncheckedUpdateInput>
  }

  /**
   * historico_indicacoes delete
   */
  export type historico_indicacoesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historico_indicacoes
     */
    select?: historico_indicacoesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the historico_indicacoes
     */
    omit?: historico_indicacoesOmit<ExtArgs> | null
    /**
     * Filter which historico_indicacoes to delete.
     */
    where: historico_indicacoesWhereUniqueInput
  }

  /**
   * historico_indicacoes deleteMany
   */
  export type historico_indicacoesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which historico_indicacoes to delete
     */
    where?: historico_indicacoesWhereInput
    /**
     * Limit how many historico_indicacoes to delete.
     */
    limit?: number
  }

  /**
   * historico_indicacoes without action
   */
  export type historico_indicacoesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historico_indicacoes
     */
    select?: historico_indicacoesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the historico_indicacoes
     */
    omit?: historico_indicacoesOmit<ExtArgs> | null
  }


  /**
   * Model historico_selfies
   */

  export type AggregateHistorico_selfies = {
    _count: Historico_selfiesCountAggregateOutputType | null
    _avg: Historico_selfiesAvgAggregateOutputType | null
    _sum: Historico_selfiesSumAggregateOutputType | null
    _min: Historico_selfiesMinAggregateOutputType | null
    _max: Historico_selfiesMaxAggregateOutputType | null
  }

  export type Historico_selfiesAvgAggregateOutputType = {
    id: number | null
    usuario_id: number | null
  }

  export type Historico_selfiesSumAggregateOutputType = {
    id: number | null
    usuario_id: number | null
  }

  export type Historico_selfiesMinAggregateOutputType = {
    id: number | null
    usuario_id: number | null
    tipo: $Enums.enum_historico_selfies_tipo | null
    imagem_url: string | null
    resultado: $Enums.enum_historico_selfies_resultado | null
    motivo_falha: string | null
    data_envio: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Historico_selfiesMaxAggregateOutputType = {
    id: number | null
    usuario_id: number | null
    tipo: $Enums.enum_historico_selfies_tipo | null
    imagem_url: string | null
    resultado: $Enums.enum_historico_selfies_resultado | null
    motivo_falha: string | null
    data_envio: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Historico_selfiesCountAggregateOutputType = {
    id: number
    usuario_id: number
    tipo: number
    imagem_url: number
    resultado: number
    motivo_falha: number
    data_envio: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Historico_selfiesAvgAggregateInputType = {
    id?: true
    usuario_id?: true
  }

  export type Historico_selfiesSumAggregateInputType = {
    id?: true
    usuario_id?: true
  }

  export type Historico_selfiesMinAggregateInputType = {
    id?: true
    usuario_id?: true
    tipo?: true
    imagem_url?: true
    resultado?: true
    motivo_falha?: true
    data_envio?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Historico_selfiesMaxAggregateInputType = {
    id?: true
    usuario_id?: true
    tipo?: true
    imagem_url?: true
    resultado?: true
    motivo_falha?: true
    data_envio?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Historico_selfiesCountAggregateInputType = {
    id?: true
    usuario_id?: true
    tipo?: true
    imagem_url?: true
    resultado?: true
    motivo_falha?: true
    data_envio?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Historico_selfiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which historico_selfies to aggregate.
     */
    where?: historico_selfiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historico_selfies to fetch.
     */
    orderBy?: historico_selfiesOrderByWithRelationInput | historico_selfiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: historico_selfiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historico_selfies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historico_selfies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned historico_selfies
    **/
    _count?: true | Historico_selfiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Historico_selfiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Historico_selfiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Historico_selfiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Historico_selfiesMaxAggregateInputType
  }

  export type GetHistorico_selfiesAggregateType<T extends Historico_selfiesAggregateArgs> = {
        [P in keyof T & keyof AggregateHistorico_selfies]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHistorico_selfies[P]>
      : GetScalarType<T[P], AggregateHistorico_selfies[P]>
  }




  export type historico_selfiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: historico_selfiesWhereInput
    orderBy?: historico_selfiesOrderByWithAggregationInput | historico_selfiesOrderByWithAggregationInput[]
    by: Historico_selfiesScalarFieldEnum[] | Historico_selfiesScalarFieldEnum
    having?: historico_selfiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Historico_selfiesCountAggregateInputType | true
    _avg?: Historico_selfiesAvgAggregateInputType
    _sum?: Historico_selfiesSumAggregateInputType
    _min?: Historico_selfiesMinAggregateInputType
    _max?: Historico_selfiesMaxAggregateInputType
  }

  export type Historico_selfiesGroupByOutputType = {
    id: number
    usuario_id: number
    tipo: $Enums.enum_historico_selfies_tipo
    imagem_url: string
    resultado: $Enums.enum_historico_selfies_resultado | null
    motivo_falha: string | null
    data_envio: Date | null
    createdAt: Date
    updatedAt: Date
    _count: Historico_selfiesCountAggregateOutputType | null
    _avg: Historico_selfiesAvgAggregateOutputType | null
    _sum: Historico_selfiesSumAggregateOutputType | null
    _min: Historico_selfiesMinAggregateOutputType | null
    _max: Historico_selfiesMaxAggregateOutputType | null
  }

  type GetHistorico_selfiesGroupByPayload<T extends historico_selfiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Historico_selfiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Historico_selfiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Historico_selfiesGroupByOutputType[P]>
            : GetScalarType<T[P], Historico_selfiesGroupByOutputType[P]>
        }
      >
    >


  export type historico_selfiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    tipo?: boolean
    imagem_url?: boolean
    resultado?: boolean
    motivo_falha?: boolean
    data_envio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["historico_selfies"]>

  export type historico_selfiesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    tipo?: boolean
    imagem_url?: boolean
    resultado?: boolean
    motivo_falha?: boolean
    data_envio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["historico_selfies"]>

  export type historico_selfiesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    tipo?: boolean
    imagem_url?: boolean
    resultado?: boolean
    motivo_falha?: boolean
    data_envio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["historico_selfies"]>

  export type historico_selfiesSelectScalar = {
    id?: boolean
    usuario_id?: boolean
    tipo?: boolean
    imagem_url?: boolean
    resultado?: boolean
    motivo_falha?: boolean
    data_envio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type historico_selfiesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "usuario_id" | "tipo" | "imagem_url" | "resultado" | "motivo_falha" | "data_envio" | "createdAt" | "updatedAt", ExtArgs["result"]["historico_selfies"]>

  export type $historico_selfiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "historico_selfies"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      usuario_id: number
      tipo: $Enums.enum_historico_selfies_tipo
      imagem_url: string
      resultado: $Enums.enum_historico_selfies_resultado | null
      motivo_falha: string | null
      data_envio: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["historico_selfies"]>
    composites: {}
  }

  type historico_selfiesGetPayload<S extends boolean | null | undefined | historico_selfiesDefaultArgs> = $Result.GetResult<Prisma.$historico_selfiesPayload, S>

  type historico_selfiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<historico_selfiesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Historico_selfiesCountAggregateInputType | true
    }

  export interface historico_selfiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['historico_selfies'], meta: { name: 'historico_selfies' } }
    /**
     * Find zero or one Historico_selfies that matches the filter.
     * @param {historico_selfiesFindUniqueArgs} args - Arguments to find a Historico_selfies
     * @example
     * // Get one Historico_selfies
     * const historico_selfies = await prisma.historico_selfies.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends historico_selfiesFindUniqueArgs>(args: SelectSubset<T, historico_selfiesFindUniqueArgs<ExtArgs>>): Prisma__historico_selfiesClient<$Result.GetResult<Prisma.$historico_selfiesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Historico_selfies that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {historico_selfiesFindUniqueOrThrowArgs} args - Arguments to find a Historico_selfies
     * @example
     * // Get one Historico_selfies
     * const historico_selfies = await prisma.historico_selfies.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends historico_selfiesFindUniqueOrThrowArgs>(args: SelectSubset<T, historico_selfiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__historico_selfiesClient<$Result.GetResult<Prisma.$historico_selfiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Historico_selfies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historico_selfiesFindFirstArgs} args - Arguments to find a Historico_selfies
     * @example
     * // Get one Historico_selfies
     * const historico_selfies = await prisma.historico_selfies.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends historico_selfiesFindFirstArgs>(args?: SelectSubset<T, historico_selfiesFindFirstArgs<ExtArgs>>): Prisma__historico_selfiesClient<$Result.GetResult<Prisma.$historico_selfiesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Historico_selfies that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historico_selfiesFindFirstOrThrowArgs} args - Arguments to find a Historico_selfies
     * @example
     * // Get one Historico_selfies
     * const historico_selfies = await prisma.historico_selfies.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends historico_selfiesFindFirstOrThrowArgs>(args?: SelectSubset<T, historico_selfiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__historico_selfiesClient<$Result.GetResult<Prisma.$historico_selfiesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Historico_selfies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historico_selfiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Historico_selfies
     * const historico_selfies = await prisma.historico_selfies.findMany()
     * 
     * // Get first 10 Historico_selfies
     * const historico_selfies = await prisma.historico_selfies.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const historico_selfiesWithIdOnly = await prisma.historico_selfies.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends historico_selfiesFindManyArgs>(args?: SelectSubset<T, historico_selfiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$historico_selfiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Historico_selfies.
     * @param {historico_selfiesCreateArgs} args - Arguments to create a Historico_selfies.
     * @example
     * // Create one Historico_selfies
     * const Historico_selfies = await prisma.historico_selfies.create({
     *   data: {
     *     // ... data to create a Historico_selfies
     *   }
     * })
     * 
     */
    create<T extends historico_selfiesCreateArgs>(args: SelectSubset<T, historico_selfiesCreateArgs<ExtArgs>>): Prisma__historico_selfiesClient<$Result.GetResult<Prisma.$historico_selfiesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Historico_selfies.
     * @param {historico_selfiesCreateManyArgs} args - Arguments to create many Historico_selfies.
     * @example
     * // Create many Historico_selfies
     * const historico_selfies = await prisma.historico_selfies.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends historico_selfiesCreateManyArgs>(args?: SelectSubset<T, historico_selfiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Historico_selfies and returns the data saved in the database.
     * @param {historico_selfiesCreateManyAndReturnArgs} args - Arguments to create many Historico_selfies.
     * @example
     * // Create many Historico_selfies
     * const historico_selfies = await prisma.historico_selfies.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Historico_selfies and only return the `id`
     * const historico_selfiesWithIdOnly = await prisma.historico_selfies.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends historico_selfiesCreateManyAndReturnArgs>(args?: SelectSubset<T, historico_selfiesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$historico_selfiesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Historico_selfies.
     * @param {historico_selfiesDeleteArgs} args - Arguments to delete one Historico_selfies.
     * @example
     * // Delete one Historico_selfies
     * const Historico_selfies = await prisma.historico_selfies.delete({
     *   where: {
     *     // ... filter to delete one Historico_selfies
     *   }
     * })
     * 
     */
    delete<T extends historico_selfiesDeleteArgs>(args: SelectSubset<T, historico_selfiesDeleteArgs<ExtArgs>>): Prisma__historico_selfiesClient<$Result.GetResult<Prisma.$historico_selfiesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Historico_selfies.
     * @param {historico_selfiesUpdateArgs} args - Arguments to update one Historico_selfies.
     * @example
     * // Update one Historico_selfies
     * const historico_selfies = await prisma.historico_selfies.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends historico_selfiesUpdateArgs>(args: SelectSubset<T, historico_selfiesUpdateArgs<ExtArgs>>): Prisma__historico_selfiesClient<$Result.GetResult<Prisma.$historico_selfiesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Historico_selfies.
     * @param {historico_selfiesDeleteManyArgs} args - Arguments to filter Historico_selfies to delete.
     * @example
     * // Delete a few Historico_selfies
     * const { count } = await prisma.historico_selfies.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends historico_selfiesDeleteManyArgs>(args?: SelectSubset<T, historico_selfiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Historico_selfies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historico_selfiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Historico_selfies
     * const historico_selfies = await prisma.historico_selfies.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends historico_selfiesUpdateManyArgs>(args: SelectSubset<T, historico_selfiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Historico_selfies and returns the data updated in the database.
     * @param {historico_selfiesUpdateManyAndReturnArgs} args - Arguments to update many Historico_selfies.
     * @example
     * // Update many Historico_selfies
     * const historico_selfies = await prisma.historico_selfies.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Historico_selfies and only return the `id`
     * const historico_selfiesWithIdOnly = await prisma.historico_selfies.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends historico_selfiesUpdateManyAndReturnArgs>(args: SelectSubset<T, historico_selfiesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$historico_selfiesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Historico_selfies.
     * @param {historico_selfiesUpsertArgs} args - Arguments to update or create a Historico_selfies.
     * @example
     * // Update or create a Historico_selfies
     * const historico_selfies = await prisma.historico_selfies.upsert({
     *   create: {
     *     // ... data to create a Historico_selfies
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Historico_selfies we want to update
     *   }
     * })
     */
    upsert<T extends historico_selfiesUpsertArgs>(args: SelectSubset<T, historico_selfiesUpsertArgs<ExtArgs>>): Prisma__historico_selfiesClient<$Result.GetResult<Prisma.$historico_selfiesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Historico_selfies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historico_selfiesCountArgs} args - Arguments to filter Historico_selfies to count.
     * @example
     * // Count the number of Historico_selfies
     * const count = await prisma.historico_selfies.count({
     *   where: {
     *     // ... the filter for the Historico_selfies we want to count
     *   }
     * })
    **/
    count<T extends historico_selfiesCountArgs>(
      args?: Subset<T, historico_selfiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Historico_selfiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Historico_selfies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Historico_selfiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Historico_selfiesAggregateArgs>(args: Subset<T, Historico_selfiesAggregateArgs>): Prisma.PrismaPromise<GetHistorico_selfiesAggregateType<T>>

    /**
     * Group by Historico_selfies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historico_selfiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends historico_selfiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: historico_selfiesGroupByArgs['orderBy'] }
        : { orderBy?: historico_selfiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, historico_selfiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHistorico_selfiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the historico_selfies model
   */
  readonly fields: historico_selfiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for historico_selfies.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__historico_selfiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the historico_selfies model
   */
  interface historico_selfiesFieldRefs {
    readonly id: FieldRef<"historico_selfies", 'Int'>
    readonly usuario_id: FieldRef<"historico_selfies", 'Int'>
    readonly tipo: FieldRef<"historico_selfies", 'enum_historico_selfies_tipo'>
    readonly imagem_url: FieldRef<"historico_selfies", 'String'>
    readonly resultado: FieldRef<"historico_selfies", 'enum_historico_selfies_resultado'>
    readonly motivo_falha: FieldRef<"historico_selfies", 'String'>
    readonly data_envio: FieldRef<"historico_selfies", 'DateTime'>
    readonly createdAt: FieldRef<"historico_selfies", 'DateTime'>
    readonly updatedAt: FieldRef<"historico_selfies", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * historico_selfies findUnique
   */
  export type historico_selfiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historico_selfies
     */
    select?: historico_selfiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the historico_selfies
     */
    omit?: historico_selfiesOmit<ExtArgs> | null
    /**
     * Filter, which historico_selfies to fetch.
     */
    where: historico_selfiesWhereUniqueInput
  }

  /**
   * historico_selfies findUniqueOrThrow
   */
  export type historico_selfiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historico_selfies
     */
    select?: historico_selfiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the historico_selfies
     */
    omit?: historico_selfiesOmit<ExtArgs> | null
    /**
     * Filter, which historico_selfies to fetch.
     */
    where: historico_selfiesWhereUniqueInput
  }

  /**
   * historico_selfies findFirst
   */
  export type historico_selfiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historico_selfies
     */
    select?: historico_selfiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the historico_selfies
     */
    omit?: historico_selfiesOmit<ExtArgs> | null
    /**
     * Filter, which historico_selfies to fetch.
     */
    where?: historico_selfiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historico_selfies to fetch.
     */
    orderBy?: historico_selfiesOrderByWithRelationInput | historico_selfiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for historico_selfies.
     */
    cursor?: historico_selfiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historico_selfies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historico_selfies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of historico_selfies.
     */
    distinct?: Historico_selfiesScalarFieldEnum | Historico_selfiesScalarFieldEnum[]
  }

  /**
   * historico_selfies findFirstOrThrow
   */
  export type historico_selfiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historico_selfies
     */
    select?: historico_selfiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the historico_selfies
     */
    omit?: historico_selfiesOmit<ExtArgs> | null
    /**
     * Filter, which historico_selfies to fetch.
     */
    where?: historico_selfiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historico_selfies to fetch.
     */
    orderBy?: historico_selfiesOrderByWithRelationInput | historico_selfiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for historico_selfies.
     */
    cursor?: historico_selfiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historico_selfies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historico_selfies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of historico_selfies.
     */
    distinct?: Historico_selfiesScalarFieldEnum | Historico_selfiesScalarFieldEnum[]
  }

  /**
   * historico_selfies findMany
   */
  export type historico_selfiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historico_selfies
     */
    select?: historico_selfiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the historico_selfies
     */
    omit?: historico_selfiesOmit<ExtArgs> | null
    /**
     * Filter, which historico_selfies to fetch.
     */
    where?: historico_selfiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historico_selfies to fetch.
     */
    orderBy?: historico_selfiesOrderByWithRelationInput | historico_selfiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing historico_selfies.
     */
    cursor?: historico_selfiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historico_selfies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historico_selfies.
     */
    skip?: number
    distinct?: Historico_selfiesScalarFieldEnum | Historico_selfiesScalarFieldEnum[]
  }

  /**
   * historico_selfies create
   */
  export type historico_selfiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historico_selfies
     */
    select?: historico_selfiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the historico_selfies
     */
    omit?: historico_selfiesOmit<ExtArgs> | null
    /**
     * The data needed to create a historico_selfies.
     */
    data: XOR<historico_selfiesCreateInput, historico_selfiesUncheckedCreateInput>
  }

  /**
   * historico_selfies createMany
   */
  export type historico_selfiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many historico_selfies.
     */
    data: historico_selfiesCreateManyInput | historico_selfiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * historico_selfies createManyAndReturn
   */
  export type historico_selfiesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historico_selfies
     */
    select?: historico_selfiesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the historico_selfies
     */
    omit?: historico_selfiesOmit<ExtArgs> | null
    /**
     * The data used to create many historico_selfies.
     */
    data: historico_selfiesCreateManyInput | historico_selfiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * historico_selfies update
   */
  export type historico_selfiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historico_selfies
     */
    select?: historico_selfiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the historico_selfies
     */
    omit?: historico_selfiesOmit<ExtArgs> | null
    /**
     * The data needed to update a historico_selfies.
     */
    data: XOR<historico_selfiesUpdateInput, historico_selfiesUncheckedUpdateInput>
    /**
     * Choose, which historico_selfies to update.
     */
    where: historico_selfiesWhereUniqueInput
  }

  /**
   * historico_selfies updateMany
   */
  export type historico_selfiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update historico_selfies.
     */
    data: XOR<historico_selfiesUpdateManyMutationInput, historico_selfiesUncheckedUpdateManyInput>
    /**
     * Filter which historico_selfies to update
     */
    where?: historico_selfiesWhereInput
    /**
     * Limit how many historico_selfies to update.
     */
    limit?: number
  }

  /**
   * historico_selfies updateManyAndReturn
   */
  export type historico_selfiesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historico_selfies
     */
    select?: historico_selfiesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the historico_selfies
     */
    omit?: historico_selfiesOmit<ExtArgs> | null
    /**
     * The data used to update historico_selfies.
     */
    data: XOR<historico_selfiesUpdateManyMutationInput, historico_selfiesUncheckedUpdateManyInput>
    /**
     * Filter which historico_selfies to update
     */
    where?: historico_selfiesWhereInput
    /**
     * Limit how many historico_selfies to update.
     */
    limit?: number
  }

  /**
   * historico_selfies upsert
   */
  export type historico_selfiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historico_selfies
     */
    select?: historico_selfiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the historico_selfies
     */
    omit?: historico_selfiesOmit<ExtArgs> | null
    /**
     * The filter to search for the historico_selfies to update in case it exists.
     */
    where: historico_selfiesWhereUniqueInput
    /**
     * In case the historico_selfies found by the `where` argument doesn't exist, create a new historico_selfies with this data.
     */
    create: XOR<historico_selfiesCreateInput, historico_selfiesUncheckedCreateInput>
    /**
     * In case the historico_selfies was found with the provided `where` argument, update it with this data.
     */
    update: XOR<historico_selfiesUpdateInput, historico_selfiesUncheckedUpdateInput>
  }

  /**
   * historico_selfies delete
   */
  export type historico_selfiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historico_selfies
     */
    select?: historico_selfiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the historico_selfies
     */
    omit?: historico_selfiesOmit<ExtArgs> | null
    /**
     * Filter which historico_selfies to delete.
     */
    where: historico_selfiesWhereUniqueInput
  }

  /**
   * historico_selfies deleteMany
   */
  export type historico_selfiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which historico_selfies to delete
     */
    where?: historico_selfiesWhereInput
    /**
     * Limit how many historico_selfies to delete.
     */
    limit?: number
  }

  /**
   * historico_selfies without action
   */
  export type historico_selfiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historico_selfies
     */
    select?: historico_selfiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the historico_selfies
     */
    omit?: historico_selfiesOmit<ExtArgs> | null
  }


  /**
   * Model logs_acesso
   */

  export type AggregateLogs_acesso = {
    _count: Logs_acessoCountAggregateOutputType | null
    _avg: Logs_acessoAvgAggregateOutputType | null
    _sum: Logs_acessoSumAggregateOutputType | null
    _min: Logs_acessoMinAggregateOutputType | null
    _max: Logs_acessoMaxAggregateOutputType | null
  }

  export type Logs_acessoAvgAggregateOutputType = {
    id: number | null
    usuario_id: number | null
  }

  export type Logs_acessoSumAggregateOutputType = {
    id: number | null
    usuario_id: number | null
  }

  export type Logs_acessoMinAggregateOutputType = {
    id: number | null
    usuario_id: number | null
    tipo_usuario: $Enums.enum_logs_acesso_tipo_usuario | null
    acao: string | null
    descricao: string | null
    ip: string | null
    dispositivo: string | null
    data: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Logs_acessoMaxAggregateOutputType = {
    id: number | null
    usuario_id: number | null
    tipo_usuario: $Enums.enum_logs_acesso_tipo_usuario | null
    acao: string | null
    descricao: string | null
    ip: string | null
    dispositivo: string | null
    data: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Logs_acessoCountAggregateOutputType = {
    id: number
    usuario_id: number
    tipo_usuario: number
    acao: number
    descricao: number
    ip: number
    dispositivo: number
    data: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Logs_acessoAvgAggregateInputType = {
    id?: true
    usuario_id?: true
  }

  export type Logs_acessoSumAggregateInputType = {
    id?: true
    usuario_id?: true
  }

  export type Logs_acessoMinAggregateInputType = {
    id?: true
    usuario_id?: true
    tipo_usuario?: true
    acao?: true
    descricao?: true
    ip?: true
    dispositivo?: true
    data?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Logs_acessoMaxAggregateInputType = {
    id?: true
    usuario_id?: true
    tipo_usuario?: true
    acao?: true
    descricao?: true
    ip?: true
    dispositivo?: true
    data?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Logs_acessoCountAggregateInputType = {
    id?: true
    usuario_id?: true
    tipo_usuario?: true
    acao?: true
    descricao?: true
    ip?: true
    dispositivo?: true
    data?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Logs_acessoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which logs_acesso to aggregate.
     */
    where?: logs_acessoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logs_acessos to fetch.
     */
    orderBy?: logs_acessoOrderByWithRelationInput | logs_acessoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: logs_acessoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logs_acessos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logs_acessos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned logs_acessos
    **/
    _count?: true | Logs_acessoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Logs_acessoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Logs_acessoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Logs_acessoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Logs_acessoMaxAggregateInputType
  }

  export type GetLogs_acessoAggregateType<T extends Logs_acessoAggregateArgs> = {
        [P in keyof T & keyof AggregateLogs_acesso]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogs_acesso[P]>
      : GetScalarType<T[P], AggregateLogs_acesso[P]>
  }




  export type logs_acessoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: logs_acessoWhereInput
    orderBy?: logs_acessoOrderByWithAggregationInput | logs_acessoOrderByWithAggregationInput[]
    by: Logs_acessoScalarFieldEnum[] | Logs_acessoScalarFieldEnum
    having?: logs_acessoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Logs_acessoCountAggregateInputType | true
    _avg?: Logs_acessoAvgAggregateInputType
    _sum?: Logs_acessoSumAggregateInputType
    _min?: Logs_acessoMinAggregateInputType
    _max?: Logs_acessoMaxAggregateInputType
  }

  export type Logs_acessoGroupByOutputType = {
    id: number
    usuario_id: number
    tipo_usuario: $Enums.enum_logs_acesso_tipo_usuario
    acao: string
    descricao: string | null
    ip: string | null
    dispositivo: string | null
    data: Date | null
    createdAt: Date
    updatedAt: Date
    _count: Logs_acessoCountAggregateOutputType | null
    _avg: Logs_acessoAvgAggregateOutputType | null
    _sum: Logs_acessoSumAggregateOutputType | null
    _min: Logs_acessoMinAggregateOutputType | null
    _max: Logs_acessoMaxAggregateOutputType | null
  }

  type GetLogs_acessoGroupByPayload<T extends logs_acessoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Logs_acessoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Logs_acessoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Logs_acessoGroupByOutputType[P]>
            : GetScalarType<T[P], Logs_acessoGroupByOutputType[P]>
        }
      >
    >


  export type logs_acessoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    tipo_usuario?: boolean
    acao?: boolean
    descricao?: boolean
    ip?: boolean
    dispositivo?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["logs_acesso"]>

  export type logs_acessoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    tipo_usuario?: boolean
    acao?: boolean
    descricao?: boolean
    ip?: boolean
    dispositivo?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["logs_acesso"]>

  export type logs_acessoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    tipo_usuario?: boolean
    acao?: boolean
    descricao?: boolean
    ip?: boolean
    dispositivo?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["logs_acesso"]>

  export type logs_acessoSelectScalar = {
    id?: boolean
    usuario_id?: boolean
    tipo_usuario?: boolean
    acao?: boolean
    descricao?: boolean
    ip?: boolean
    dispositivo?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type logs_acessoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "usuario_id" | "tipo_usuario" | "acao" | "descricao" | "ip" | "dispositivo" | "data" | "createdAt" | "updatedAt", ExtArgs["result"]["logs_acesso"]>

  export type $logs_acessoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "logs_acesso"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      usuario_id: number
      tipo_usuario: $Enums.enum_logs_acesso_tipo_usuario
      acao: string
      descricao: string | null
      ip: string | null
      dispositivo: string | null
      data: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["logs_acesso"]>
    composites: {}
  }

  type logs_acessoGetPayload<S extends boolean | null | undefined | logs_acessoDefaultArgs> = $Result.GetResult<Prisma.$logs_acessoPayload, S>

  type logs_acessoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<logs_acessoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Logs_acessoCountAggregateInputType | true
    }

  export interface logs_acessoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['logs_acesso'], meta: { name: 'logs_acesso' } }
    /**
     * Find zero or one Logs_acesso that matches the filter.
     * @param {logs_acessoFindUniqueArgs} args - Arguments to find a Logs_acesso
     * @example
     * // Get one Logs_acesso
     * const logs_acesso = await prisma.logs_acesso.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends logs_acessoFindUniqueArgs>(args: SelectSubset<T, logs_acessoFindUniqueArgs<ExtArgs>>): Prisma__logs_acessoClient<$Result.GetResult<Prisma.$logs_acessoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Logs_acesso that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {logs_acessoFindUniqueOrThrowArgs} args - Arguments to find a Logs_acesso
     * @example
     * // Get one Logs_acesso
     * const logs_acesso = await prisma.logs_acesso.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends logs_acessoFindUniqueOrThrowArgs>(args: SelectSubset<T, logs_acessoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__logs_acessoClient<$Result.GetResult<Prisma.$logs_acessoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Logs_acesso that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logs_acessoFindFirstArgs} args - Arguments to find a Logs_acesso
     * @example
     * // Get one Logs_acesso
     * const logs_acesso = await prisma.logs_acesso.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends logs_acessoFindFirstArgs>(args?: SelectSubset<T, logs_acessoFindFirstArgs<ExtArgs>>): Prisma__logs_acessoClient<$Result.GetResult<Prisma.$logs_acessoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Logs_acesso that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logs_acessoFindFirstOrThrowArgs} args - Arguments to find a Logs_acesso
     * @example
     * // Get one Logs_acesso
     * const logs_acesso = await prisma.logs_acesso.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends logs_acessoFindFirstOrThrowArgs>(args?: SelectSubset<T, logs_acessoFindFirstOrThrowArgs<ExtArgs>>): Prisma__logs_acessoClient<$Result.GetResult<Prisma.$logs_acessoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Logs_acessos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logs_acessoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Logs_acessos
     * const logs_acessos = await prisma.logs_acesso.findMany()
     * 
     * // Get first 10 Logs_acessos
     * const logs_acessos = await prisma.logs_acesso.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logs_acessoWithIdOnly = await prisma.logs_acesso.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends logs_acessoFindManyArgs>(args?: SelectSubset<T, logs_acessoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$logs_acessoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Logs_acesso.
     * @param {logs_acessoCreateArgs} args - Arguments to create a Logs_acesso.
     * @example
     * // Create one Logs_acesso
     * const Logs_acesso = await prisma.logs_acesso.create({
     *   data: {
     *     // ... data to create a Logs_acesso
     *   }
     * })
     * 
     */
    create<T extends logs_acessoCreateArgs>(args: SelectSubset<T, logs_acessoCreateArgs<ExtArgs>>): Prisma__logs_acessoClient<$Result.GetResult<Prisma.$logs_acessoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Logs_acessos.
     * @param {logs_acessoCreateManyArgs} args - Arguments to create many Logs_acessos.
     * @example
     * // Create many Logs_acessos
     * const logs_acesso = await prisma.logs_acesso.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends logs_acessoCreateManyArgs>(args?: SelectSubset<T, logs_acessoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Logs_acessos and returns the data saved in the database.
     * @param {logs_acessoCreateManyAndReturnArgs} args - Arguments to create many Logs_acessos.
     * @example
     * // Create many Logs_acessos
     * const logs_acesso = await prisma.logs_acesso.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Logs_acessos and only return the `id`
     * const logs_acessoWithIdOnly = await prisma.logs_acesso.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends logs_acessoCreateManyAndReturnArgs>(args?: SelectSubset<T, logs_acessoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$logs_acessoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Logs_acesso.
     * @param {logs_acessoDeleteArgs} args - Arguments to delete one Logs_acesso.
     * @example
     * // Delete one Logs_acesso
     * const Logs_acesso = await prisma.logs_acesso.delete({
     *   where: {
     *     // ... filter to delete one Logs_acesso
     *   }
     * })
     * 
     */
    delete<T extends logs_acessoDeleteArgs>(args: SelectSubset<T, logs_acessoDeleteArgs<ExtArgs>>): Prisma__logs_acessoClient<$Result.GetResult<Prisma.$logs_acessoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Logs_acesso.
     * @param {logs_acessoUpdateArgs} args - Arguments to update one Logs_acesso.
     * @example
     * // Update one Logs_acesso
     * const logs_acesso = await prisma.logs_acesso.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends logs_acessoUpdateArgs>(args: SelectSubset<T, logs_acessoUpdateArgs<ExtArgs>>): Prisma__logs_acessoClient<$Result.GetResult<Prisma.$logs_acessoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Logs_acessos.
     * @param {logs_acessoDeleteManyArgs} args - Arguments to filter Logs_acessos to delete.
     * @example
     * // Delete a few Logs_acessos
     * const { count } = await prisma.logs_acesso.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends logs_acessoDeleteManyArgs>(args?: SelectSubset<T, logs_acessoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logs_acessos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logs_acessoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Logs_acessos
     * const logs_acesso = await prisma.logs_acesso.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends logs_acessoUpdateManyArgs>(args: SelectSubset<T, logs_acessoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logs_acessos and returns the data updated in the database.
     * @param {logs_acessoUpdateManyAndReturnArgs} args - Arguments to update many Logs_acessos.
     * @example
     * // Update many Logs_acessos
     * const logs_acesso = await prisma.logs_acesso.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Logs_acessos and only return the `id`
     * const logs_acessoWithIdOnly = await prisma.logs_acesso.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends logs_acessoUpdateManyAndReturnArgs>(args: SelectSubset<T, logs_acessoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$logs_acessoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Logs_acesso.
     * @param {logs_acessoUpsertArgs} args - Arguments to update or create a Logs_acesso.
     * @example
     * // Update or create a Logs_acesso
     * const logs_acesso = await prisma.logs_acesso.upsert({
     *   create: {
     *     // ... data to create a Logs_acesso
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Logs_acesso we want to update
     *   }
     * })
     */
    upsert<T extends logs_acessoUpsertArgs>(args: SelectSubset<T, logs_acessoUpsertArgs<ExtArgs>>): Prisma__logs_acessoClient<$Result.GetResult<Prisma.$logs_acessoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Logs_acessos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logs_acessoCountArgs} args - Arguments to filter Logs_acessos to count.
     * @example
     * // Count the number of Logs_acessos
     * const count = await prisma.logs_acesso.count({
     *   where: {
     *     // ... the filter for the Logs_acessos we want to count
     *   }
     * })
    **/
    count<T extends logs_acessoCountArgs>(
      args?: Subset<T, logs_acessoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Logs_acessoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Logs_acesso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Logs_acessoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Logs_acessoAggregateArgs>(args: Subset<T, Logs_acessoAggregateArgs>): Prisma.PrismaPromise<GetLogs_acessoAggregateType<T>>

    /**
     * Group by Logs_acesso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logs_acessoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends logs_acessoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: logs_acessoGroupByArgs['orderBy'] }
        : { orderBy?: logs_acessoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, logs_acessoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogs_acessoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the logs_acesso model
   */
  readonly fields: logs_acessoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for logs_acesso.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__logs_acessoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the logs_acesso model
   */
  interface logs_acessoFieldRefs {
    readonly id: FieldRef<"logs_acesso", 'Int'>
    readonly usuario_id: FieldRef<"logs_acesso", 'Int'>
    readonly tipo_usuario: FieldRef<"logs_acesso", 'enum_logs_acesso_tipo_usuario'>
    readonly acao: FieldRef<"logs_acesso", 'String'>
    readonly descricao: FieldRef<"logs_acesso", 'String'>
    readonly ip: FieldRef<"logs_acesso", 'String'>
    readonly dispositivo: FieldRef<"logs_acesso", 'String'>
    readonly data: FieldRef<"logs_acesso", 'DateTime'>
    readonly createdAt: FieldRef<"logs_acesso", 'DateTime'>
    readonly updatedAt: FieldRef<"logs_acesso", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * logs_acesso findUnique
   */
  export type logs_acessoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs_acesso
     */
    select?: logs_acessoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logs_acesso
     */
    omit?: logs_acessoOmit<ExtArgs> | null
    /**
     * Filter, which logs_acesso to fetch.
     */
    where: logs_acessoWhereUniqueInput
  }

  /**
   * logs_acesso findUniqueOrThrow
   */
  export type logs_acessoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs_acesso
     */
    select?: logs_acessoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logs_acesso
     */
    omit?: logs_acessoOmit<ExtArgs> | null
    /**
     * Filter, which logs_acesso to fetch.
     */
    where: logs_acessoWhereUniqueInput
  }

  /**
   * logs_acesso findFirst
   */
  export type logs_acessoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs_acesso
     */
    select?: logs_acessoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logs_acesso
     */
    omit?: logs_acessoOmit<ExtArgs> | null
    /**
     * Filter, which logs_acesso to fetch.
     */
    where?: logs_acessoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logs_acessos to fetch.
     */
    orderBy?: logs_acessoOrderByWithRelationInput | logs_acessoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for logs_acessos.
     */
    cursor?: logs_acessoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logs_acessos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logs_acessos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of logs_acessos.
     */
    distinct?: Logs_acessoScalarFieldEnum | Logs_acessoScalarFieldEnum[]
  }

  /**
   * logs_acesso findFirstOrThrow
   */
  export type logs_acessoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs_acesso
     */
    select?: logs_acessoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logs_acesso
     */
    omit?: logs_acessoOmit<ExtArgs> | null
    /**
     * Filter, which logs_acesso to fetch.
     */
    where?: logs_acessoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logs_acessos to fetch.
     */
    orderBy?: logs_acessoOrderByWithRelationInput | logs_acessoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for logs_acessos.
     */
    cursor?: logs_acessoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logs_acessos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logs_acessos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of logs_acessos.
     */
    distinct?: Logs_acessoScalarFieldEnum | Logs_acessoScalarFieldEnum[]
  }

  /**
   * logs_acesso findMany
   */
  export type logs_acessoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs_acesso
     */
    select?: logs_acessoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logs_acesso
     */
    omit?: logs_acessoOmit<ExtArgs> | null
    /**
     * Filter, which logs_acessos to fetch.
     */
    where?: logs_acessoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logs_acessos to fetch.
     */
    orderBy?: logs_acessoOrderByWithRelationInput | logs_acessoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing logs_acessos.
     */
    cursor?: logs_acessoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logs_acessos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logs_acessos.
     */
    skip?: number
    distinct?: Logs_acessoScalarFieldEnum | Logs_acessoScalarFieldEnum[]
  }

  /**
   * logs_acesso create
   */
  export type logs_acessoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs_acesso
     */
    select?: logs_acessoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logs_acesso
     */
    omit?: logs_acessoOmit<ExtArgs> | null
    /**
     * The data needed to create a logs_acesso.
     */
    data: XOR<logs_acessoCreateInput, logs_acessoUncheckedCreateInput>
  }

  /**
   * logs_acesso createMany
   */
  export type logs_acessoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many logs_acessos.
     */
    data: logs_acessoCreateManyInput | logs_acessoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * logs_acesso createManyAndReturn
   */
  export type logs_acessoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs_acesso
     */
    select?: logs_acessoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the logs_acesso
     */
    omit?: logs_acessoOmit<ExtArgs> | null
    /**
     * The data used to create many logs_acessos.
     */
    data: logs_acessoCreateManyInput | logs_acessoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * logs_acesso update
   */
  export type logs_acessoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs_acesso
     */
    select?: logs_acessoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logs_acesso
     */
    omit?: logs_acessoOmit<ExtArgs> | null
    /**
     * The data needed to update a logs_acesso.
     */
    data: XOR<logs_acessoUpdateInput, logs_acessoUncheckedUpdateInput>
    /**
     * Choose, which logs_acesso to update.
     */
    where: logs_acessoWhereUniqueInput
  }

  /**
   * logs_acesso updateMany
   */
  export type logs_acessoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update logs_acessos.
     */
    data: XOR<logs_acessoUpdateManyMutationInput, logs_acessoUncheckedUpdateManyInput>
    /**
     * Filter which logs_acessos to update
     */
    where?: logs_acessoWhereInput
    /**
     * Limit how many logs_acessos to update.
     */
    limit?: number
  }

  /**
   * logs_acesso updateManyAndReturn
   */
  export type logs_acessoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs_acesso
     */
    select?: logs_acessoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the logs_acesso
     */
    omit?: logs_acessoOmit<ExtArgs> | null
    /**
     * The data used to update logs_acessos.
     */
    data: XOR<logs_acessoUpdateManyMutationInput, logs_acessoUncheckedUpdateManyInput>
    /**
     * Filter which logs_acessos to update
     */
    where?: logs_acessoWhereInput
    /**
     * Limit how many logs_acessos to update.
     */
    limit?: number
  }

  /**
   * logs_acesso upsert
   */
  export type logs_acessoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs_acesso
     */
    select?: logs_acessoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logs_acesso
     */
    omit?: logs_acessoOmit<ExtArgs> | null
    /**
     * The filter to search for the logs_acesso to update in case it exists.
     */
    where: logs_acessoWhereUniqueInput
    /**
     * In case the logs_acesso found by the `where` argument doesn't exist, create a new logs_acesso with this data.
     */
    create: XOR<logs_acessoCreateInput, logs_acessoUncheckedCreateInput>
    /**
     * In case the logs_acesso was found with the provided `where` argument, update it with this data.
     */
    update: XOR<logs_acessoUpdateInput, logs_acessoUncheckedUpdateInput>
  }

  /**
   * logs_acesso delete
   */
  export type logs_acessoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs_acesso
     */
    select?: logs_acessoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logs_acesso
     */
    omit?: logs_acessoOmit<ExtArgs> | null
    /**
     * Filter which logs_acesso to delete.
     */
    where: logs_acessoWhereUniqueInput
  }

  /**
   * logs_acesso deleteMany
   */
  export type logs_acessoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which logs_acessos to delete
     */
    where?: logs_acessoWhereInput
    /**
     * Limit how many logs_acessos to delete.
     */
    limit?: number
  }

  /**
   * logs_acesso without action
   */
  export type logs_acessoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs_acesso
     */
    select?: logs_acessoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logs_acesso
     */
    omit?: logs_acessoOmit<ExtArgs> | null
  }


  /**
   * Model mensagens_suporte
   */

  export type AggregateMensagens_suporte = {
    _count: Mensagens_suporteCountAggregateOutputType | null
    _avg: Mensagens_suporteAvgAggregateOutputType | null
    _sum: Mensagens_suporteSumAggregateOutputType | null
    _min: Mensagens_suporteMinAggregateOutputType | null
    _max: Mensagens_suporteMaxAggregateOutputType | null
  }

  export type Mensagens_suporteAvgAggregateOutputType = {
    id: number | null
    usuario_id: number | null
  }

  export type Mensagens_suporteSumAggregateOutputType = {
    id: number | null
    usuario_id: number | null
  }

  export type Mensagens_suporteMinAggregateOutputType = {
    id: number | null
    usuario_id: number | null
    tipo_usuario: $Enums.enum_mensagens_suporte_tipo_usuario | null
    mensagem: string | null
    resposta_sistema: boolean | null
    status: $Enums.enum_mensagens_suporte_status | null
    data_envio: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Mensagens_suporteMaxAggregateOutputType = {
    id: number | null
    usuario_id: number | null
    tipo_usuario: $Enums.enum_mensagens_suporte_tipo_usuario | null
    mensagem: string | null
    resposta_sistema: boolean | null
    status: $Enums.enum_mensagens_suporte_status | null
    data_envio: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Mensagens_suporteCountAggregateOutputType = {
    id: number
    usuario_id: number
    tipo_usuario: number
    mensagem: number
    resposta_sistema: number
    status: number
    data_envio: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Mensagens_suporteAvgAggregateInputType = {
    id?: true
    usuario_id?: true
  }

  export type Mensagens_suporteSumAggregateInputType = {
    id?: true
    usuario_id?: true
  }

  export type Mensagens_suporteMinAggregateInputType = {
    id?: true
    usuario_id?: true
    tipo_usuario?: true
    mensagem?: true
    resposta_sistema?: true
    status?: true
    data_envio?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Mensagens_suporteMaxAggregateInputType = {
    id?: true
    usuario_id?: true
    tipo_usuario?: true
    mensagem?: true
    resposta_sistema?: true
    status?: true
    data_envio?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Mensagens_suporteCountAggregateInputType = {
    id?: true
    usuario_id?: true
    tipo_usuario?: true
    mensagem?: true
    resposta_sistema?: true
    status?: true
    data_envio?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Mensagens_suporteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which mensagens_suporte to aggregate.
     */
    where?: mensagens_suporteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mensagens_suportes to fetch.
     */
    orderBy?: mensagens_suporteOrderByWithRelationInput | mensagens_suporteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: mensagens_suporteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mensagens_suportes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mensagens_suportes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mensagens_suportes
    **/
    _count?: true | Mensagens_suporteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Mensagens_suporteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Mensagens_suporteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Mensagens_suporteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Mensagens_suporteMaxAggregateInputType
  }

  export type GetMensagens_suporteAggregateType<T extends Mensagens_suporteAggregateArgs> = {
        [P in keyof T & keyof AggregateMensagens_suporte]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMensagens_suporte[P]>
      : GetScalarType<T[P], AggregateMensagens_suporte[P]>
  }




  export type mensagens_suporteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: mensagens_suporteWhereInput
    orderBy?: mensagens_suporteOrderByWithAggregationInput | mensagens_suporteOrderByWithAggregationInput[]
    by: Mensagens_suporteScalarFieldEnum[] | Mensagens_suporteScalarFieldEnum
    having?: mensagens_suporteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Mensagens_suporteCountAggregateInputType | true
    _avg?: Mensagens_suporteAvgAggregateInputType
    _sum?: Mensagens_suporteSumAggregateInputType
    _min?: Mensagens_suporteMinAggregateInputType
    _max?: Mensagens_suporteMaxAggregateInputType
  }

  export type Mensagens_suporteGroupByOutputType = {
    id: number
    usuario_id: number
    tipo_usuario: $Enums.enum_mensagens_suporte_tipo_usuario
    mensagem: string
    resposta_sistema: boolean | null
    status: $Enums.enum_mensagens_suporte_status | null
    data_envio: Date | null
    createdAt: Date
    updatedAt: Date
    _count: Mensagens_suporteCountAggregateOutputType | null
    _avg: Mensagens_suporteAvgAggregateOutputType | null
    _sum: Mensagens_suporteSumAggregateOutputType | null
    _min: Mensagens_suporteMinAggregateOutputType | null
    _max: Mensagens_suporteMaxAggregateOutputType | null
  }

  type GetMensagens_suporteGroupByPayload<T extends mensagens_suporteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Mensagens_suporteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Mensagens_suporteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Mensagens_suporteGroupByOutputType[P]>
            : GetScalarType<T[P], Mensagens_suporteGroupByOutputType[P]>
        }
      >
    >


  export type mensagens_suporteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    tipo_usuario?: boolean
    mensagem?: boolean
    resposta_sistema?: boolean
    status?: boolean
    data_envio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["mensagens_suporte"]>

  export type mensagens_suporteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    tipo_usuario?: boolean
    mensagem?: boolean
    resposta_sistema?: boolean
    status?: boolean
    data_envio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["mensagens_suporte"]>

  export type mensagens_suporteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    tipo_usuario?: boolean
    mensagem?: boolean
    resposta_sistema?: boolean
    status?: boolean
    data_envio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["mensagens_suporte"]>

  export type mensagens_suporteSelectScalar = {
    id?: boolean
    usuario_id?: boolean
    tipo_usuario?: boolean
    mensagem?: boolean
    resposta_sistema?: boolean
    status?: boolean
    data_envio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type mensagens_suporteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "usuario_id" | "tipo_usuario" | "mensagem" | "resposta_sistema" | "status" | "data_envio" | "createdAt" | "updatedAt", ExtArgs["result"]["mensagens_suporte"]>

  export type $mensagens_suportePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "mensagens_suporte"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      usuario_id: number
      tipo_usuario: $Enums.enum_mensagens_suporte_tipo_usuario
      mensagem: string
      resposta_sistema: boolean | null
      status: $Enums.enum_mensagens_suporte_status | null
      data_envio: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["mensagens_suporte"]>
    composites: {}
  }

  type mensagens_suporteGetPayload<S extends boolean | null | undefined | mensagens_suporteDefaultArgs> = $Result.GetResult<Prisma.$mensagens_suportePayload, S>

  type mensagens_suporteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<mensagens_suporteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Mensagens_suporteCountAggregateInputType | true
    }

  export interface mensagens_suporteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['mensagens_suporte'], meta: { name: 'mensagens_suporte' } }
    /**
     * Find zero or one Mensagens_suporte that matches the filter.
     * @param {mensagens_suporteFindUniqueArgs} args - Arguments to find a Mensagens_suporte
     * @example
     * // Get one Mensagens_suporte
     * const mensagens_suporte = await prisma.mensagens_suporte.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends mensagens_suporteFindUniqueArgs>(args: SelectSubset<T, mensagens_suporteFindUniqueArgs<ExtArgs>>): Prisma__mensagens_suporteClient<$Result.GetResult<Prisma.$mensagens_suportePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Mensagens_suporte that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {mensagens_suporteFindUniqueOrThrowArgs} args - Arguments to find a Mensagens_suporte
     * @example
     * // Get one Mensagens_suporte
     * const mensagens_suporte = await prisma.mensagens_suporte.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends mensagens_suporteFindUniqueOrThrowArgs>(args: SelectSubset<T, mensagens_suporteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__mensagens_suporteClient<$Result.GetResult<Prisma.$mensagens_suportePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mensagens_suporte that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mensagens_suporteFindFirstArgs} args - Arguments to find a Mensagens_suporte
     * @example
     * // Get one Mensagens_suporte
     * const mensagens_suporte = await prisma.mensagens_suporte.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends mensagens_suporteFindFirstArgs>(args?: SelectSubset<T, mensagens_suporteFindFirstArgs<ExtArgs>>): Prisma__mensagens_suporteClient<$Result.GetResult<Prisma.$mensagens_suportePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mensagens_suporte that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mensagens_suporteFindFirstOrThrowArgs} args - Arguments to find a Mensagens_suporte
     * @example
     * // Get one Mensagens_suporte
     * const mensagens_suporte = await prisma.mensagens_suporte.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends mensagens_suporteFindFirstOrThrowArgs>(args?: SelectSubset<T, mensagens_suporteFindFirstOrThrowArgs<ExtArgs>>): Prisma__mensagens_suporteClient<$Result.GetResult<Prisma.$mensagens_suportePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Mensagens_suportes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mensagens_suporteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mensagens_suportes
     * const mensagens_suportes = await prisma.mensagens_suporte.findMany()
     * 
     * // Get first 10 Mensagens_suportes
     * const mensagens_suportes = await prisma.mensagens_suporte.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mensagens_suporteWithIdOnly = await prisma.mensagens_suporte.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends mensagens_suporteFindManyArgs>(args?: SelectSubset<T, mensagens_suporteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mensagens_suportePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Mensagens_suporte.
     * @param {mensagens_suporteCreateArgs} args - Arguments to create a Mensagens_suporte.
     * @example
     * // Create one Mensagens_suporte
     * const Mensagens_suporte = await prisma.mensagens_suporte.create({
     *   data: {
     *     // ... data to create a Mensagens_suporte
     *   }
     * })
     * 
     */
    create<T extends mensagens_suporteCreateArgs>(args: SelectSubset<T, mensagens_suporteCreateArgs<ExtArgs>>): Prisma__mensagens_suporteClient<$Result.GetResult<Prisma.$mensagens_suportePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Mensagens_suportes.
     * @param {mensagens_suporteCreateManyArgs} args - Arguments to create many Mensagens_suportes.
     * @example
     * // Create many Mensagens_suportes
     * const mensagens_suporte = await prisma.mensagens_suporte.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends mensagens_suporteCreateManyArgs>(args?: SelectSubset<T, mensagens_suporteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Mensagens_suportes and returns the data saved in the database.
     * @param {mensagens_suporteCreateManyAndReturnArgs} args - Arguments to create many Mensagens_suportes.
     * @example
     * // Create many Mensagens_suportes
     * const mensagens_suporte = await prisma.mensagens_suporte.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Mensagens_suportes and only return the `id`
     * const mensagens_suporteWithIdOnly = await prisma.mensagens_suporte.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends mensagens_suporteCreateManyAndReturnArgs>(args?: SelectSubset<T, mensagens_suporteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mensagens_suportePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Mensagens_suporte.
     * @param {mensagens_suporteDeleteArgs} args - Arguments to delete one Mensagens_suporte.
     * @example
     * // Delete one Mensagens_suporte
     * const Mensagens_suporte = await prisma.mensagens_suporte.delete({
     *   where: {
     *     // ... filter to delete one Mensagens_suporte
     *   }
     * })
     * 
     */
    delete<T extends mensagens_suporteDeleteArgs>(args: SelectSubset<T, mensagens_suporteDeleteArgs<ExtArgs>>): Prisma__mensagens_suporteClient<$Result.GetResult<Prisma.$mensagens_suportePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Mensagens_suporte.
     * @param {mensagens_suporteUpdateArgs} args - Arguments to update one Mensagens_suporte.
     * @example
     * // Update one Mensagens_suporte
     * const mensagens_suporte = await prisma.mensagens_suporte.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends mensagens_suporteUpdateArgs>(args: SelectSubset<T, mensagens_suporteUpdateArgs<ExtArgs>>): Prisma__mensagens_suporteClient<$Result.GetResult<Prisma.$mensagens_suportePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Mensagens_suportes.
     * @param {mensagens_suporteDeleteManyArgs} args - Arguments to filter Mensagens_suportes to delete.
     * @example
     * // Delete a few Mensagens_suportes
     * const { count } = await prisma.mensagens_suporte.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends mensagens_suporteDeleteManyArgs>(args?: SelectSubset<T, mensagens_suporteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mensagens_suportes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mensagens_suporteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mensagens_suportes
     * const mensagens_suporte = await prisma.mensagens_suporte.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends mensagens_suporteUpdateManyArgs>(args: SelectSubset<T, mensagens_suporteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mensagens_suportes and returns the data updated in the database.
     * @param {mensagens_suporteUpdateManyAndReturnArgs} args - Arguments to update many Mensagens_suportes.
     * @example
     * // Update many Mensagens_suportes
     * const mensagens_suporte = await prisma.mensagens_suporte.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Mensagens_suportes and only return the `id`
     * const mensagens_suporteWithIdOnly = await prisma.mensagens_suporte.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends mensagens_suporteUpdateManyAndReturnArgs>(args: SelectSubset<T, mensagens_suporteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mensagens_suportePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Mensagens_suporte.
     * @param {mensagens_suporteUpsertArgs} args - Arguments to update or create a Mensagens_suporte.
     * @example
     * // Update or create a Mensagens_suporte
     * const mensagens_suporte = await prisma.mensagens_suporte.upsert({
     *   create: {
     *     // ... data to create a Mensagens_suporte
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mensagens_suporte we want to update
     *   }
     * })
     */
    upsert<T extends mensagens_suporteUpsertArgs>(args: SelectSubset<T, mensagens_suporteUpsertArgs<ExtArgs>>): Prisma__mensagens_suporteClient<$Result.GetResult<Prisma.$mensagens_suportePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Mensagens_suportes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mensagens_suporteCountArgs} args - Arguments to filter Mensagens_suportes to count.
     * @example
     * // Count the number of Mensagens_suportes
     * const count = await prisma.mensagens_suporte.count({
     *   where: {
     *     // ... the filter for the Mensagens_suportes we want to count
     *   }
     * })
    **/
    count<T extends mensagens_suporteCountArgs>(
      args?: Subset<T, mensagens_suporteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Mensagens_suporteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mensagens_suporte.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Mensagens_suporteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Mensagens_suporteAggregateArgs>(args: Subset<T, Mensagens_suporteAggregateArgs>): Prisma.PrismaPromise<GetMensagens_suporteAggregateType<T>>

    /**
     * Group by Mensagens_suporte.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mensagens_suporteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends mensagens_suporteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: mensagens_suporteGroupByArgs['orderBy'] }
        : { orderBy?: mensagens_suporteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, mensagens_suporteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMensagens_suporteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the mensagens_suporte model
   */
  readonly fields: mensagens_suporteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for mensagens_suporte.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__mensagens_suporteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the mensagens_suporte model
   */
  interface mensagens_suporteFieldRefs {
    readonly id: FieldRef<"mensagens_suporte", 'Int'>
    readonly usuario_id: FieldRef<"mensagens_suporte", 'Int'>
    readonly tipo_usuario: FieldRef<"mensagens_suporte", 'enum_mensagens_suporte_tipo_usuario'>
    readonly mensagem: FieldRef<"mensagens_suporte", 'String'>
    readonly resposta_sistema: FieldRef<"mensagens_suporte", 'Boolean'>
    readonly status: FieldRef<"mensagens_suporte", 'enum_mensagens_suporte_status'>
    readonly data_envio: FieldRef<"mensagens_suporte", 'DateTime'>
    readonly createdAt: FieldRef<"mensagens_suporte", 'DateTime'>
    readonly updatedAt: FieldRef<"mensagens_suporte", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * mensagens_suporte findUnique
   */
  export type mensagens_suporteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mensagens_suporte
     */
    select?: mensagens_suporteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mensagens_suporte
     */
    omit?: mensagens_suporteOmit<ExtArgs> | null
    /**
     * Filter, which mensagens_suporte to fetch.
     */
    where: mensagens_suporteWhereUniqueInput
  }

  /**
   * mensagens_suporte findUniqueOrThrow
   */
  export type mensagens_suporteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mensagens_suporte
     */
    select?: mensagens_suporteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mensagens_suporte
     */
    omit?: mensagens_suporteOmit<ExtArgs> | null
    /**
     * Filter, which mensagens_suporte to fetch.
     */
    where: mensagens_suporteWhereUniqueInput
  }

  /**
   * mensagens_suporte findFirst
   */
  export type mensagens_suporteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mensagens_suporte
     */
    select?: mensagens_suporteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mensagens_suporte
     */
    omit?: mensagens_suporteOmit<ExtArgs> | null
    /**
     * Filter, which mensagens_suporte to fetch.
     */
    where?: mensagens_suporteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mensagens_suportes to fetch.
     */
    orderBy?: mensagens_suporteOrderByWithRelationInput | mensagens_suporteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mensagens_suportes.
     */
    cursor?: mensagens_suporteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mensagens_suportes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mensagens_suportes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mensagens_suportes.
     */
    distinct?: Mensagens_suporteScalarFieldEnum | Mensagens_suporteScalarFieldEnum[]
  }

  /**
   * mensagens_suporte findFirstOrThrow
   */
  export type mensagens_suporteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mensagens_suporte
     */
    select?: mensagens_suporteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mensagens_suporte
     */
    omit?: mensagens_suporteOmit<ExtArgs> | null
    /**
     * Filter, which mensagens_suporte to fetch.
     */
    where?: mensagens_suporteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mensagens_suportes to fetch.
     */
    orderBy?: mensagens_suporteOrderByWithRelationInput | mensagens_suporteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mensagens_suportes.
     */
    cursor?: mensagens_suporteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mensagens_suportes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mensagens_suportes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mensagens_suportes.
     */
    distinct?: Mensagens_suporteScalarFieldEnum | Mensagens_suporteScalarFieldEnum[]
  }

  /**
   * mensagens_suporte findMany
   */
  export type mensagens_suporteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mensagens_suporte
     */
    select?: mensagens_suporteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mensagens_suporte
     */
    omit?: mensagens_suporteOmit<ExtArgs> | null
    /**
     * Filter, which mensagens_suportes to fetch.
     */
    where?: mensagens_suporteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mensagens_suportes to fetch.
     */
    orderBy?: mensagens_suporteOrderByWithRelationInput | mensagens_suporteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mensagens_suportes.
     */
    cursor?: mensagens_suporteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mensagens_suportes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mensagens_suportes.
     */
    skip?: number
    distinct?: Mensagens_suporteScalarFieldEnum | Mensagens_suporteScalarFieldEnum[]
  }

  /**
   * mensagens_suporte create
   */
  export type mensagens_suporteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mensagens_suporte
     */
    select?: mensagens_suporteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mensagens_suporte
     */
    omit?: mensagens_suporteOmit<ExtArgs> | null
    /**
     * The data needed to create a mensagens_suporte.
     */
    data: XOR<mensagens_suporteCreateInput, mensagens_suporteUncheckedCreateInput>
  }

  /**
   * mensagens_suporte createMany
   */
  export type mensagens_suporteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many mensagens_suportes.
     */
    data: mensagens_suporteCreateManyInput | mensagens_suporteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * mensagens_suporte createManyAndReturn
   */
  export type mensagens_suporteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mensagens_suporte
     */
    select?: mensagens_suporteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the mensagens_suporte
     */
    omit?: mensagens_suporteOmit<ExtArgs> | null
    /**
     * The data used to create many mensagens_suportes.
     */
    data: mensagens_suporteCreateManyInput | mensagens_suporteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * mensagens_suporte update
   */
  export type mensagens_suporteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mensagens_suporte
     */
    select?: mensagens_suporteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mensagens_suporte
     */
    omit?: mensagens_suporteOmit<ExtArgs> | null
    /**
     * The data needed to update a mensagens_suporte.
     */
    data: XOR<mensagens_suporteUpdateInput, mensagens_suporteUncheckedUpdateInput>
    /**
     * Choose, which mensagens_suporte to update.
     */
    where: mensagens_suporteWhereUniqueInput
  }

  /**
   * mensagens_suporte updateMany
   */
  export type mensagens_suporteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update mensagens_suportes.
     */
    data: XOR<mensagens_suporteUpdateManyMutationInput, mensagens_suporteUncheckedUpdateManyInput>
    /**
     * Filter which mensagens_suportes to update
     */
    where?: mensagens_suporteWhereInput
    /**
     * Limit how many mensagens_suportes to update.
     */
    limit?: number
  }

  /**
   * mensagens_suporte updateManyAndReturn
   */
  export type mensagens_suporteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mensagens_suporte
     */
    select?: mensagens_suporteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the mensagens_suporte
     */
    omit?: mensagens_suporteOmit<ExtArgs> | null
    /**
     * The data used to update mensagens_suportes.
     */
    data: XOR<mensagens_suporteUpdateManyMutationInput, mensagens_suporteUncheckedUpdateManyInput>
    /**
     * Filter which mensagens_suportes to update
     */
    where?: mensagens_suporteWhereInput
    /**
     * Limit how many mensagens_suportes to update.
     */
    limit?: number
  }

  /**
   * mensagens_suporte upsert
   */
  export type mensagens_suporteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mensagens_suporte
     */
    select?: mensagens_suporteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mensagens_suporte
     */
    omit?: mensagens_suporteOmit<ExtArgs> | null
    /**
     * The filter to search for the mensagens_suporte to update in case it exists.
     */
    where: mensagens_suporteWhereUniqueInput
    /**
     * In case the mensagens_suporte found by the `where` argument doesn't exist, create a new mensagens_suporte with this data.
     */
    create: XOR<mensagens_suporteCreateInput, mensagens_suporteUncheckedCreateInput>
    /**
     * In case the mensagens_suporte was found with the provided `where` argument, update it with this data.
     */
    update: XOR<mensagens_suporteUpdateInput, mensagens_suporteUncheckedUpdateInput>
  }

  /**
   * mensagens_suporte delete
   */
  export type mensagens_suporteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mensagens_suporte
     */
    select?: mensagens_suporteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mensagens_suporte
     */
    omit?: mensagens_suporteOmit<ExtArgs> | null
    /**
     * Filter which mensagens_suporte to delete.
     */
    where: mensagens_suporteWhereUniqueInput
  }

  /**
   * mensagens_suporte deleteMany
   */
  export type mensagens_suporteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which mensagens_suportes to delete
     */
    where?: mensagens_suporteWhereInput
    /**
     * Limit how many mensagens_suportes to delete.
     */
    limit?: number
  }

  /**
   * mensagens_suporte without action
   */
  export type mensagens_suporteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mensagens_suporte
     */
    select?: mensagens_suporteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mensagens_suporte
     */
    omit?: mensagens_suporteOmit<ExtArgs> | null
  }


  /**
   * Model pagamentos_pessoais
   */

  export type AggregatePagamentos_pessoais = {
    _count: Pagamentos_pessoaisCountAggregateOutputType | null
    _avg: Pagamentos_pessoaisAvgAggregateOutputType | null
    _sum: Pagamentos_pessoaisSumAggregateOutputType | null
    _min: Pagamentos_pessoaisMinAggregateOutputType | null
    _max: Pagamentos_pessoaisMaxAggregateOutputType | null
  }

  export type Pagamentos_pessoaisAvgAggregateOutputType = {
    id: number | null
    motorista_id: number | null
    passageiro_id: number | null
    valor: number | null
    valor_maximo: number | null
  }

  export type Pagamentos_pessoaisSumAggregateOutputType = {
    id: number | null
    motorista_id: number | null
    passageiro_id: number | null
    valor: number | null
    valor_maximo: number | null
  }

  export type Pagamentos_pessoaisMinAggregateOutputType = {
    id: number | null
    motorista_id: number | null
    passageiro_id: number | null
    valor: number | null
    valor_maximo: number | null
    aceito_pelo_app: boolean | null
    data_corrida: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Pagamentos_pessoaisMaxAggregateOutputType = {
    id: number | null
    motorista_id: number | null
    passageiro_id: number | null
    valor: number | null
    valor_maximo: number | null
    aceito_pelo_app: boolean | null
    data_corrida: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Pagamentos_pessoaisCountAggregateOutputType = {
    id: number
    motorista_id: number
    passageiro_id: number
    valor: number
    valor_maximo: number
    aceito_pelo_app: number
    data_corrida: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Pagamentos_pessoaisAvgAggregateInputType = {
    id?: true
    motorista_id?: true
    passageiro_id?: true
    valor?: true
    valor_maximo?: true
  }

  export type Pagamentos_pessoaisSumAggregateInputType = {
    id?: true
    motorista_id?: true
    passageiro_id?: true
    valor?: true
    valor_maximo?: true
  }

  export type Pagamentos_pessoaisMinAggregateInputType = {
    id?: true
    motorista_id?: true
    passageiro_id?: true
    valor?: true
    valor_maximo?: true
    aceito_pelo_app?: true
    data_corrida?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Pagamentos_pessoaisMaxAggregateInputType = {
    id?: true
    motorista_id?: true
    passageiro_id?: true
    valor?: true
    valor_maximo?: true
    aceito_pelo_app?: true
    data_corrida?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Pagamentos_pessoaisCountAggregateInputType = {
    id?: true
    motorista_id?: true
    passageiro_id?: true
    valor?: true
    valor_maximo?: true
    aceito_pelo_app?: true
    data_corrida?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Pagamentos_pessoaisAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pagamentos_pessoais to aggregate.
     */
    where?: pagamentos_pessoaisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pagamentos_pessoais to fetch.
     */
    orderBy?: pagamentos_pessoaisOrderByWithRelationInput | pagamentos_pessoaisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pagamentos_pessoaisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pagamentos_pessoais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pagamentos_pessoais.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pagamentos_pessoais
    **/
    _count?: true | Pagamentos_pessoaisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Pagamentos_pessoaisAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Pagamentos_pessoaisSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Pagamentos_pessoaisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Pagamentos_pessoaisMaxAggregateInputType
  }

  export type GetPagamentos_pessoaisAggregateType<T extends Pagamentos_pessoaisAggregateArgs> = {
        [P in keyof T & keyof AggregatePagamentos_pessoais]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePagamentos_pessoais[P]>
      : GetScalarType<T[P], AggregatePagamentos_pessoais[P]>
  }




  export type pagamentos_pessoaisGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pagamentos_pessoaisWhereInput
    orderBy?: pagamentos_pessoaisOrderByWithAggregationInput | pagamentos_pessoaisOrderByWithAggregationInput[]
    by: Pagamentos_pessoaisScalarFieldEnum[] | Pagamentos_pessoaisScalarFieldEnum
    having?: pagamentos_pessoaisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Pagamentos_pessoaisCountAggregateInputType | true
    _avg?: Pagamentos_pessoaisAvgAggregateInputType
    _sum?: Pagamentos_pessoaisSumAggregateInputType
    _min?: Pagamentos_pessoaisMinAggregateInputType
    _max?: Pagamentos_pessoaisMaxAggregateInputType
  }

  export type Pagamentos_pessoaisGroupByOutputType = {
    id: number
    motorista_id: number
    passageiro_id: number
    valor: number
    valor_maximo: number
    aceito_pelo_app: boolean | null
    data_corrida: Date | null
    createdAt: Date
    updatedAt: Date
    _count: Pagamentos_pessoaisCountAggregateOutputType | null
    _avg: Pagamentos_pessoaisAvgAggregateOutputType | null
    _sum: Pagamentos_pessoaisSumAggregateOutputType | null
    _min: Pagamentos_pessoaisMinAggregateOutputType | null
    _max: Pagamentos_pessoaisMaxAggregateOutputType | null
  }

  type GetPagamentos_pessoaisGroupByPayload<T extends pagamentos_pessoaisGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Pagamentos_pessoaisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Pagamentos_pessoaisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Pagamentos_pessoaisGroupByOutputType[P]>
            : GetScalarType<T[P], Pagamentos_pessoaisGroupByOutputType[P]>
        }
      >
    >


  export type pagamentos_pessoaisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    motorista_id?: boolean
    passageiro_id?: boolean
    valor?: boolean
    valor_maximo?: boolean
    aceito_pelo_app?: boolean
    data_corrida?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["pagamentos_pessoais"]>

  export type pagamentos_pessoaisSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    motorista_id?: boolean
    passageiro_id?: boolean
    valor?: boolean
    valor_maximo?: boolean
    aceito_pelo_app?: boolean
    data_corrida?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["pagamentos_pessoais"]>

  export type pagamentos_pessoaisSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    motorista_id?: boolean
    passageiro_id?: boolean
    valor?: boolean
    valor_maximo?: boolean
    aceito_pelo_app?: boolean
    data_corrida?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["pagamentos_pessoais"]>

  export type pagamentos_pessoaisSelectScalar = {
    id?: boolean
    motorista_id?: boolean
    passageiro_id?: boolean
    valor?: boolean
    valor_maximo?: boolean
    aceito_pelo_app?: boolean
    data_corrida?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type pagamentos_pessoaisOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "motorista_id" | "passageiro_id" | "valor" | "valor_maximo" | "aceito_pelo_app" | "data_corrida" | "createdAt" | "updatedAt", ExtArgs["result"]["pagamentos_pessoais"]>

  export type $pagamentos_pessoaisPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pagamentos_pessoais"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      motorista_id: number
      passageiro_id: number
      valor: number
      valor_maximo: number
      aceito_pelo_app: boolean | null
      data_corrida: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pagamentos_pessoais"]>
    composites: {}
  }

  type pagamentos_pessoaisGetPayload<S extends boolean | null | undefined | pagamentos_pessoaisDefaultArgs> = $Result.GetResult<Prisma.$pagamentos_pessoaisPayload, S>

  type pagamentos_pessoaisCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<pagamentos_pessoaisFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Pagamentos_pessoaisCountAggregateInputType | true
    }

  export interface pagamentos_pessoaisDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pagamentos_pessoais'], meta: { name: 'pagamentos_pessoais' } }
    /**
     * Find zero or one Pagamentos_pessoais that matches the filter.
     * @param {pagamentos_pessoaisFindUniqueArgs} args - Arguments to find a Pagamentos_pessoais
     * @example
     * // Get one Pagamentos_pessoais
     * const pagamentos_pessoais = await prisma.pagamentos_pessoais.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pagamentos_pessoaisFindUniqueArgs>(args: SelectSubset<T, pagamentos_pessoaisFindUniqueArgs<ExtArgs>>): Prisma__pagamentos_pessoaisClient<$Result.GetResult<Prisma.$pagamentos_pessoaisPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pagamentos_pessoais that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {pagamentos_pessoaisFindUniqueOrThrowArgs} args - Arguments to find a Pagamentos_pessoais
     * @example
     * // Get one Pagamentos_pessoais
     * const pagamentos_pessoais = await prisma.pagamentos_pessoais.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pagamentos_pessoaisFindUniqueOrThrowArgs>(args: SelectSubset<T, pagamentos_pessoaisFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pagamentos_pessoaisClient<$Result.GetResult<Prisma.$pagamentos_pessoaisPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pagamentos_pessoais that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pagamentos_pessoaisFindFirstArgs} args - Arguments to find a Pagamentos_pessoais
     * @example
     * // Get one Pagamentos_pessoais
     * const pagamentos_pessoais = await prisma.pagamentos_pessoais.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pagamentos_pessoaisFindFirstArgs>(args?: SelectSubset<T, pagamentos_pessoaisFindFirstArgs<ExtArgs>>): Prisma__pagamentos_pessoaisClient<$Result.GetResult<Prisma.$pagamentos_pessoaisPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pagamentos_pessoais that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pagamentos_pessoaisFindFirstOrThrowArgs} args - Arguments to find a Pagamentos_pessoais
     * @example
     * // Get one Pagamentos_pessoais
     * const pagamentos_pessoais = await prisma.pagamentos_pessoais.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pagamentos_pessoaisFindFirstOrThrowArgs>(args?: SelectSubset<T, pagamentos_pessoaisFindFirstOrThrowArgs<ExtArgs>>): Prisma__pagamentos_pessoaisClient<$Result.GetResult<Prisma.$pagamentos_pessoaisPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pagamentos_pessoais that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pagamentos_pessoaisFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pagamentos_pessoais
     * const pagamentos_pessoais = await prisma.pagamentos_pessoais.findMany()
     * 
     * // Get first 10 Pagamentos_pessoais
     * const pagamentos_pessoais = await prisma.pagamentos_pessoais.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pagamentos_pessoaisWithIdOnly = await prisma.pagamentos_pessoais.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends pagamentos_pessoaisFindManyArgs>(args?: SelectSubset<T, pagamentos_pessoaisFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pagamentos_pessoaisPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pagamentos_pessoais.
     * @param {pagamentos_pessoaisCreateArgs} args - Arguments to create a Pagamentos_pessoais.
     * @example
     * // Create one Pagamentos_pessoais
     * const Pagamentos_pessoais = await prisma.pagamentos_pessoais.create({
     *   data: {
     *     // ... data to create a Pagamentos_pessoais
     *   }
     * })
     * 
     */
    create<T extends pagamentos_pessoaisCreateArgs>(args: SelectSubset<T, pagamentos_pessoaisCreateArgs<ExtArgs>>): Prisma__pagamentos_pessoaisClient<$Result.GetResult<Prisma.$pagamentos_pessoaisPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pagamentos_pessoais.
     * @param {pagamentos_pessoaisCreateManyArgs} args - Arguments to create many Pagamentos_pessoais.
     * @example
     * // Create many Pagamentos_pessoais
     * const pagamentos_pessoais = await prisma.pagamentos_pessoais.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pagamentos_pessoaisCreateManyArgs>(args?: SelectSubset<T, pagamentos_pessoaisCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pagamentos_pessoais and returns the data saved in the database.
     * @param {pagamentos_pessoaisCreateManyAndReturnArgs} args - Arguments to create many Pagamentos_pessoais.
     * @example
     * // Create many Pagamentos_pessoais
     * const pagamentos_pessoais = await prisma.pagamentos_pessoais.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pagamentos_pessoais and only return the `id`
     * const pagamentos_pessoaisWithIdOnly = await prisma.pagamentos_pessoais.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends pagamentos_pessoaisCreateManyAndReturnArgs>(args?: SelectSubset<T, pagamentos_pessoaisCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pagamentos_pessoaisPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Pagamentos_pessoais.
     * @param {pagamentos_pessoaisDeleteArgs} args - Arguments to delete one Pagamentos_pessoais.
     * @example
     * // Delete one Pagamentos_pessoais
     * const Pagamentos_pessoais = await prisma.pagamentos_pessoais.delete({
     *   where: {
     *     // ... filter to delete one Pagamentos_pessoais
     *   }
     * })
     * 
     */
    delete<T extends pagamentos_pessoaisDeleteArgs>(args: SelectSubset<T, pagamentos_pessoaisDeleteArgs<ExtArgs>>): Prisma__pagamentos_pessoaisClient<$Result.GetResult<Prisma.$pagamentos_pessoaisPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pagamentos_pessoais.
     * @param {pagamentos_pessoaisUpdateArgs} args - Arguments to update one Pagamentos_pessoais.
     * @example
     * // Update one Pagamentos_pessoais
     * const pagamentos_pessoais = await prisma.pagamentos_pessoais.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pagamentos_pessoaisUpdateArgs>(args: SelectSubset<T, pagamentos_pessoaisUpdateArgs<ExtArgs>>): Prisma__pagamentos_pessoaisClient<$Result.GetResult<Prisma.$pagamentos_pessoaisPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pagamentos_pessoais.
     * @param {pagamentos_pessoaisDeleteManyArgs} args - Arguments to filter Pagamentos_pessoais to delete.
     * @example
     * // Delete a few Pagamentos_pessoais
     * const { count } = await prisma.pagamentos_pessoais.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pagamentos_pessoaisDeleteManyArgs>(args?: SelectSubset<T, pagamentos_pessoaisDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pagamentos_pessoais.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pagamentos_pessoaisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pagamentos_pessoais
     * const pagamentos_pessoais = await prisma.pagamentos_pessoais.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pagamentos_pessoaisUpdateManyArgs>(args: SelectSubset<T, pagamentos_pessoaisUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pagamentos_pessoais and returns the data updated in the database.
     * @param {pagamentos_pessoaisUpdateManyAndReturnArgs} args - Arguments to update many Pagamentos_pessoais.
     * @example
     * // Update many Pagamentos_pessoais
     * const pagamentos_pessoais = await prisma.pagamentos_pessoais.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pagamentos_pessoais and only return the `id`
     * const pagamentos_pessoaisWithIdOnly = await prisma.pagamentos_pessoais.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends pagamentos_pessoaisUpdateManyAndReturnArgs>(args: SelectSubset<T, pagamentos_pessoaisUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pagamentos_pessoaisPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Pagamentos_pessoais.
     * @param {pagamentos_pessoaisUpsertArgs} args - Arguments to update or create a Pagamentos_pessoais.
     * @example
     * // Update or create a Pagamentos_pessoais
     * const pagamentos_pessoais = await prisma.pagamentos_pessoais.upsert({
     *   create: {
     *     // ... data to create a Pagamentos_pessoais
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pagamentos_pessoais we want to update
     *   }
     * })
     */
    upsert<T extends pagamentos_pessoaisUpsertArgs>(args: SelectSubset<T, pagamentos_pessoaisUpsertArgs<ExtArgs>>): Prisma__pagamentos_pessoaisClient<$Result.GetResult<Prisma.$pagamentos_pessoaisPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pagamentos_pessoais.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pagamentos_pessoaisCountArgs} args - Arguments to filter Pagamentos_pessoais to count.
     * @example
     * // Count the number of Pagamentos_pessoais
     * const count = await prisma.pagamentos_pessoais.count({
     *   where: {
     *     // ... the filter for the Pagamentos_pessoais we want to count
     *   }
     * })
    **/
    count<T extends pagamentos_pessoaisCountArgs>(
      args?: Subset<T, pagamentos_pessoaisCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Pagamentos_pessoaisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pagamentos_pessoais.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pagamentos_pessoaisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Pagamentos_pessoaisAggregateArgs>(args: Subset<T, Pagamentos_pessoaisAggregateArgs>): Prisma.PrismaPromise<GetPagamentos_pessoaisAggregateType<T>>

    /**
     * Group by Pagamentos_pessoais.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pagamentos_pessoaisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pagamentos_pessoaisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pagamentos_pessoaisGroupByArgs['orderBy'] }
        : { orderBy?: pagamentos_pessoaisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pagamentos_pessoaisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPagamentos_pessoaisGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pagamentos_pessoais model
   */
  readonly fields: pagamentos_pessoaisFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pagamentos_pessoais.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pagamentos_pessoaisClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pagamentos_pessoais model
   */
  interface pagamentos_pessoaisFieldRefs {
    readonly id: FieldRef<"pagamentos_pessoais", 'Int'>
    readonly motorista_id: FieldRef<"pagamentos_pessoais", 'Int'>
    readonly passageiro_id: FieldRef<"pagamentos_pessoais", 'Int'>
    readonly valor: FieldRef<"pagamentos_pessoais", 'Float'>
    readonly valor_maximo: FieldRef<"pagamentos_pessoais", 'Float'>
    readonly aceito_pelo_app: FieldRef<"pagamentos_pessoais", 'Boolean'>
    readonly data_corrida: FieldRef<"pagamentos_pessoais", 'DateTime'>
    readonly createdAt: FieldRef<"pagamentos_pessoais", 'DateTime'>
    readonly updatedAt: FieldRef<"pagamentos_pessoais", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * pagamentos_pessoais findUnique
   */
  export type pagamentos_pessoaisFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pagamentos_pessoais
     */
    select?: pagamentos_pessoaisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pagamentos_pessoais
     */
    omit?: pagamentos_pessoaisOmit<ExtArgs> | null
    /**
     * Filter, which pagamentos_pessoais to fetch.
     */
    where: pagamentos_pessoaisWhereUniqueInput
  }

  /**
   * pagamentos_pessoais findUniqueOrThrow
   */
  export type pagamentos_pessoaisFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pagamentos_pessoais
     */
    select?: pagamentos_pessoaisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pagamentos_pessoais
     */
    omit?: pagamentos_pessoaisOmit<ExtArgs> | null
    /**
     * Filter, which pagamentos_pessoais to fetch.
     */
    where: pagamentos_pessoaisWhereUniqueInput
  }

  /**
   * pagamentos_pessoais findFirst
   */
  export type pagamentos_pessoaisFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pagamentos_pessoais
     */
    select?: pagamentos_pessoaisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pagamentos_pessoais
     */
    omit?: pagamentos_pessoaisOmit<ExtArgs> | null
    /**
     * Filter, which pagamentos_pessoais to fetch.
     */
    where?: pagamentos_pessoaisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pagamentos_pessoais to fetch.
     */
    orderBy?: pagamentos_pessoaisOrderByWithRelationInput | pagamentos_pessoaisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pagamentos_pessoais.
     */
    cursor?: pagamentos_pessoaisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pagamentos_pessoais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pagamentos_pessoais.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pagamentos_pessoais.
     */
    distinct?: Pagamentos_pessoaisScalarFieldEnum | Pagamentos_pessoaisScalarFieldEnum[]
  }

  /**
   * pagamentos_pessoais findFirstOrThrow
   */
  export type pagamentos_pessoaisFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pagamentos_pessoais
     */
    select?: pagamentos_pessoaisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pagamentos_pessoais
     */
    omit?: pagamentos_pessoaisOmit<ExtArgs> | null
    /**
     * Filter, which pagamentos_pessoais to fetch.
     */
    where?: pagamentos_pessoaisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pagamentos_pessoais to fetch.
     */
    orderBy?: pagamentos_pessoaisOrderByWithRelationInput | pagamentos_pessoaisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pagamentos_pessoais.
     */
    cursor?: pagamentos_pessoaisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pagamentos_pessoais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pagamentos_pessoais.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pagamentos_pessoais.
     */
    distinct?: Pagamentos_pessoaisScalarFieldEnum | Pagamentos_pessoaisScalarFieldEnum[]
  }

  /**
   * pagamentos_pessoais findMany
   */
  export type pagamentos_pessoaisFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pagamentos_pessoais
     */
    select?: pagamentos_pessoaisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pagamentos_pessoais
     */
    omit?: pagamentos_pessoaisOmit<ExtArgs> | null
    /**
     * Filter, which pagamentos_pessoais to fetch.
     */
    where?: pagamentos_pessoaisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pagamentos_pessoais to fetch.
     */
    orderBy?: pagamentos_pessoaisOrderByWithRelationInput | pagamentos_pessoaisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pagamentos_pessoais.
     */
    cursor?: pagamentos_pessoaisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pagamentos_pessoais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pagamentos_pessoais.
     */
    skip?: number
    distinct?: Pagamentos_pessoaisScalarFieldEnum | Pagamentos_pessoaisScalarFieldEnum[]
  }

  /**
   * pagamentos_pessoais create
   */
  export type pagamentos_pessoaisCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pagamentos_pessoais
     */
    select?: pagamentos_pessoaisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pagamentos_pessoais
     */
    omit?: pagamentos_pessoaisOmit<ExtArgs> | null
    /**
     * The data needed to create a pagamentos_pessoais.
     */
    data: XOR<pagamentos_pessoaisCreateInput, pagamentos_pessoaisUncheckedCreateInput>
  }

  /**
   * pagamentos_pessoais createMany
   */
  export type pagamentos_pessoaisCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pagamentos_pessoais.
     */
    data: pagamentos_pessoaisCreateManyInput | pagamentos_pessoaisCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pagamentos_pessoais createManyAndReturn
   */
  export type pagamentos_pessoaisCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pagamentos_pessoais
     */
    select?: pagamentos_pessoaisSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the pagamentos_pessoais
     */
    omit?: pagamentos_pessoaisOmit<ExtArgs> | null
    /**
     * The data used to create many pagamentos_pessoais.
     */
    data: pagamentos_pessoaisCreateManyInput | pagamentos_pessoaisCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pagamentos_pessoais update
   */
  export type pagamentos_pessoaisUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pagamentos_pessoais
     */
    select?: pagamentos_pessoaisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pagamentos_pessoais
     */
    omit?: pagamentos_pessoaisOmit<ExtArgs> | null
    /**
     * The data needed to update a pagamentos_pessoais.
     */
    data: XOR<pagamentos_pessoaisUpdateInput, pagamentos_pessoaisUncheckedUpdateInput>
    /**
     * Choose, which pagamentos_pessoais to update.
     */
    where: pagamentos_pessoaisWhereUniqueInput
  }

  /**
   * pagamentos_pessoais updateMany
   */
  export type pagamentos_pessoaisUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pagamentos_pessoais.
     */
    data: XOR<pagamentos_pessoaisUpdateManyMutationInput, pagamentos_pessoaisUncheckedUpdateManyInput>
    /**
     * Filter which pagamentos_pessoais to update
     */
    where?: pagamentos_pessoaisWhereInput
    /**
     * Limit how many pagamentos_pessoais to update.
     */
    limit?: number
  }

  /**
   * pagamentos_pessoais updateManyAndReturn
   */
  export type pagamentos_pessoaisUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pagamentos_pessoais
     */
    select?: pagamentos_pessoaisSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the pagamentos_pessoais
     */
    omit?: pagamentos_pessoaisOmit<ExtArgs> | null
    /**
     * The data used to update pagamentos_pessoais.
     */
    data: XOR<pagamentos_pessoaisUpdateManyMutationInput, pagamentos_pessoaisUncheckedUpdateManyInput>
    /**
     * Filter which pagamentos_pessoais to update
     */
    where?: pagamentos_pessoaisWhereInput
    /**
     * Limit how many pagamentos_pessoais to update.
     */
    limit?: number
  }

  /**
   * pagamentos_pessoais upsert
   */
  export type pagamentos_pessoaisUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pagamentos_pessoais
     */
    select?: pagamentos_pessoaisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pagamentos_pessoais
     */
    omit?: pagamentos_pessoaisOmit<ExtArgs> | null
    /**
     * The filter to search for the pagamentos_pessoais to update in case it exists.
     */
    where: pagamentos_pessoaisWhereUniqueInput
    /**
     * In case the pagamentos_pessoais found by the `where` argument doesn't exist, create a new pagamentos_pessoais with this data.
     */
    create: XOR<pagamentos_pessoaisCreateInput, pagamentos_pessoaisUncheckedCreateInput>
    /**
     * In case the pagamentos_pessoais was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pagamentos_pessoaisUpdateInput, pagamentos_pessoaisUncheckedUpdateInput>
  }

  /**
   * pagamentos_pessoais delete
   */
  export type pagamentos_pessoaisDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pagamentos_pessoais
     */
    select?: pagamentos_pessoaisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pagamentos_pessoais
     */
    omit?: pagamentos_pessoaisOmit<ExtArgs> | null
    /**
     * Filter which pagamentos_pessoais to delete.
     */
    where: pagamentos_pessoaisWhereUniqueInput
  }

  /**
   * pagamentos_pessoais deleteMany
   */
  export type pagamentos_pessoaisDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pagamentos_pessoais to delete
     */
    where?: pagamentos_pessoaisWhereInput
    /**
     * Limit how many pagamentos_pessoais to delete.
     */
    limit?: number
  }

  /**
   * pagamentos_pessoais without action
   */
  export type pagamentos_pessoaisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pagamentos_pessoais
     */
    select?: pagamentos_pessoaisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pagamentos_pessoais
     */
    omit?: pagamentos_pessoaisOmit<ExtArgs> | null
  }


  /**
   * Model paradas
   */

  export type AggregateParadas = {
    _count: ParadasCountAggregateOutputType | null
    _avg: ParadasAvgAggregateOutputType | null
    _sum: ParadasSumAggregateOutputType | null
    _min: ParadasMinAggregateOutputType | null
    _max: ParadasMaxAggregateOutputType | null
  }

  export type ParadasAvgAggregateOutputType = {
    id: number | null
    corrida_id: number | null
    ordem: number | null
    latitude: number | null
    longitude: number | null
    tempo_espera: number | null
  }

  export type ParadasSumAggregateOutputType = {
    id: number | null
    corrida_id: number | null
    ordem: number | null
    latitude: number | null
    longitude: number | null
    tempo_espera: number | null
  }

  export type ParadasMinAggregateOutputType = {
    id: number | null
    corrida_id: number | null
    ordem: number | null
    endereco: string | null
    latitude: number | null
    longitude: number | null
    tempo_espera: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ParadasMaxAggregateOutputType = {
    id: number | null
    corrida_id: number | null
    ordem: number | null
    endereco: string | null
    latitude: number | null
    longitude: number | null
    tempo_espera: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ParadasCountAggregateOutputType = {
    id: number
    corrida_id: number
    ordem: number
    endereco: number
    latitude: number
    longitude: number
    tempo_espera: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ParadasAvgAggregateInputType = {
    id?: true
    corrida_id?: true
    ordem?: true
    latitude?: true
    longitude?: true
    tempo_espera?: true
  }

  export type ParadasSumAggregateInputType = {
    id?: true
    corrida_id?: true
    ordem?: true
    latitude?: true
    longitude?: true
    tempo_espera?: true
  }

  export type ParadasMinAggregateInputType = {
    id?: true
    corrida_id?: true
    ordem?: true
    endereco?: true
    latitude?: true
    longitude?: true
    tempo_espera?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ParadasMaxAggregateInputType = {
    id?: true
    corrida_id?: true
    ordem?: true
    endereco?: true
    latitude?: true
    longitude?: true
    tempo_espera?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ParadasCountAggregateInputType = {
    id?: true
    corrida_id?: true
    ordem?: true
    endereco?: true
    latitude?: true
    longitude?: true
    tempo_espera?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ParadasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which paradas to aggregate.
     */
    where?: paradasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of paradas to fetch.
     */
    orderBy?: paradasOrderByWithRelationInput | paradasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: paradasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` paradas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` paradas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned paradas
    **/
    _count?: true | ParadasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParadasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParadasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParadasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParadasMaxAggregateInputType
  }

  export type GetParadasAggregateType<T extends ParadasAggregateArgs> = {
        [P in keyof T & keyof AggregateParadas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParadas[P]>
      : GetScalarType<T[P], AggregateParadas[P]>
  }




  export type paradasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paradasWhereInput
    orderBy?: paradasOrderByWithAggregationInput | paradasOrderByWithAggregationInput[]
    by: ParadasScalarFieldEnum[] | ParadasScalarFieldEnum
    having?: paradasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParadasCountAggregateInputType | true
    _avg?: ParadasAvgAggregateInputType
    _sum?: ParadasSumAggregateInputType
    _min?: ParadasMinAggregateInputType
    _max?: ParadasMaxAggregateInputType
  }

  export type ParadasGroupByOutputType = {
    id: number
    corrida_id: number
    ordem: number
    endereco: string
    latitude: number | null
    longitude: number | null
    tempo_espera: number | null
    createdAt: Date
    updatedAt: Date
    _count: ParadasCountAggregateOutputType | null
    _avg: ParadasAvgAggregateOutputType | null
    _sum: ParadasSumAggregateOutputType | null
    _min: ParadasMinAggregateOutputType | null
    _max: ParadasMaxAggregateOutputType | null
  }

  type GetParadasGroupByPayload<T extends paradasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParadasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParadasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParadasGroupByOutputType[P]>
            : GetScalarType<T[P], ParadasGroupByOutputType[P]>
        }
      >
    >


  export type paradasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    corrida_id?: boolean
    ordem?: boolean
    endereco?: boolean
    latitude?: boolean
    longitude?: boolean
    tempo_espera?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["paradas"]>

  export type paradasSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    corrida_id?: boolean
    ordem?: boolean
    endereco?: boolean
    latitude?: boolean
    longitude?: boolean
    tempo_espera?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["paradas"]>

  export type paradasSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    corrida_id?: boolean
    ordem?: boolean
    endereco?: boolean
    latitude?: boolean
    longitude?: boolean
    tempo_espera?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["paradas"]>

  export type paradasSelectScalar = {
    id?: boolean
    corrida_id?: boolean
    ordem?: boolean
    endereco?: boolean
    latitude?: boolean
    longitude?: boolean
    tempo_espera?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type paradasOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "corrida_id" | "ordem" | "endereco" | "latitude" | "longitude" | "tempo_espera" | "createdAt" | "updatedAt", ExtArgs["result"]["paradas"]>

  export type $paradasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "paradas"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      corrida_id: number
      ordem: number
      endereco: string
      latitude: number | null
      longitude: number | null
      tempo_espera: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["paradas"]>
    composites: {}
  }

  type paradasGetPayload<S extends boolean | null | undefined | paradasDefaultArgs> = $Result.GetResult<Prisma.$paradasPayload, S>

  type paradasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<paradasFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ParadasCountAggregateInputType | true
    }

  export interface paradasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['paradas'], meta: { name: 'paradas' } }
    /**
     * Find zero or one Paradas that matches the filter.
     * @param {paradasFindUniqueArgs} args - Arguments to find a Paradas
     * @example
     * // Get one Paradas
     * const paradas = await prisma.paradas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends paradasFindUniqueArgs>(args: SelectSubset<T, paradasFindUniqueArgs<ExtArgs>>): Prisma__paradasClient<$Result.GetResult<Prisma.$paradasPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Paradas that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {paradasFindUniqueOrThrowArgs} args - Arguments to find a Paradas
     * @example
     * // Get one Paradas
     * const paradas = await prisma.paradas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends paradasFindUniqueOrThrowArgs>(args: SelectSubset<T, paradasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__paradasClient<$Result.GetResult<Prisma.$paradasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Paradas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paradasFindFirstArgs} args - Arguments to find a Paradas
     * @example
     * // Get one Paradas
     * const paradas = await prisma.paradas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends paradasFindFirstArgs>(args?: SelectSubset<T, paradasFindFirstArgs<ExtArgs>>): Prisma__paradasClient<$Result.GetResult<Prisma.$paradasPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Paradas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paradasFindFirstOrThrowArgs} args - Arguments to find a Paradas
     * @example
     * // Get one Paradas
     * const paradas = await prisma.paradas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends paradasFindFirstOrThrowArgs>(args?: SelectSubset<T, paradasFindFirstOrThrowArgs<ExtArgs>>): Prisma__paradasClient<$Result.GetResult<Prisma.$paradasPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Paradas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paradasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Paradas
     * const paradas = await prisma.paradas.findMany()
     * 
     * // Get first 10 Paradas
     * const paradas = await prisma.paradas.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paradasWithIdOnly = await prisma.paradas.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends paradasFindManyArgs>(args?: SelectSubset<T, paradasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paradasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Paradas.
     * @param {paradasCreateArgs} args - Arguments to create a Paradas.
     * @example
     * // Create one Paradas
     * const Paradas = await prisma.paradas.create({
     *   data: {
     *     // ... data to create a Paradas
     *   }
     * })
     * 
     */
    create<T extends paradasCreateArgs>(args: SelectSubset<T, paradasCreateArgs<ExtArgs>>): Prisma__paradasClient<$Result.GetResult<Prisma.$paradasPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Paradas.
     * @param {paradasCreateManyArgs} args - Arguments to create many Paradas.
     * @example
     * // Create many Paradas
     * const paradas = await prisma.paradas.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends paradasCreateManyArgs>(args?: SelectSubset<T, paradasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Paradas and returns the data saved in the database.
     * @param {paradasCreateManyAndReturnArgs} args - Arguments to create many Paradas.
     * @example
     * // Create many Paradas
     * const paradas = await prisma.paradas.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Paradas and only return the `id`
     * const paradasWithIdOnly = await prisma.paradas.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends paradasCreateManyAndReturnArgs>(args?: SelectSubset<T, paradasCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paradasPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Paradas.
     * @param {paradasDeleteArgs} args - Arguments to delete one Paradas.
     * @example
     * // Delete one Paradas
     * const Paradas = await prisma.paradas.delete({
     *   where: {
     *     // ... filter to delete one Paradas
     *   }
     * })
     * 
     */
    delete<T extends paradasDeleteArgs>(args: SelectSubset<T, paradasDeleteArgs<ExtArgs>>): Prisma__paradasClient<$Result.GetResult<Prisma.$paradasPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Paradas.
     * @param {paradasUpdateArgs} args - Arguments to update one Paradas.
     * @example
     * // Update one Paradas
     * const paradas = await prisma.paradas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends paradasUpdateArgs>(args: SelectSubset<T, paradasUpdateArgs<ExtArgs>>): Prisma__paradasClient<$Result.GetResult<Prisma.$paradasPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Paradas.
     * @param {paradasDeleteManyArgs} args - Arguments to filter Paradas to delete.
     * @example
     * // Delete a few Paradas
     * const { count } = await prisma.paradas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends paradasDeleteManyArgs>(args?: SelectSubset<T, paradasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Paradas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paradasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Paradas
     * const paradas = await prisma.paradas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends paradasUpdateManyArgs>(args: SelectSubset<T, paradasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Paradas and returns the data updated in the database.
     * @param {paradasUpdateManyAndReturnArgs} args - Arguments to update many Paradas.
     * @example
     * // Update many Paradas
     * const paradas = await prisma.paradas.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Paradas and only return the `id`
     * const paradasWithIdOnly = await prisma.paradas.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends paradasUpdateManyAndReturnArgs>(args: SelectSubset<T, paradasUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paradasPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Paradas.
     * @param {paradasUpsertArgs} args - Arguments to update or create a Paradas.
     * @example
     * // Update or create a Paradas
     * const paradas = await prisma.paradas.upsert({
     *   create: {
     *     // ... data to create a Paradas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Paradas we want to update
     *   }
     * })
     */
    upsert<T extends paradasUpsertArgs>(args: SelectSubset<T, paradasUpsertArgs<ExtArgs>>): Prisma__paradasClient<$Result.GetResult<Prisma.$paradasPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Paradas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paradasCountArgs} args - Arguments to filter Paradas to count.
     * @example
     * // Count the number of Paradas
     * const count = await prisma.paradas.count({
     *   where: {
     *     // ... the filter for the Paradas we want to count
     *   }
     * })
    **/
    count<T extends paradasCountArgs>(
      args?: Subset<T, paradasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParadasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Paradas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParadasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParadasAggregateArgs>(args: Subset<T, ParadasAggregateArgs>): Prisma.PrismaPromise<GetParadasAggregateType<T>>

    /**
     * Group by Paradas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paradasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends paradasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: paradasGroupByArgs['orderBy'] }
        : { orderBy?: paradasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, paradasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParadasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the paradas model
   */
  readonly fields: paradasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for paradas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__paradasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the paradas model
   */
  interface paradasFieldRefs {
    readonly id: FieldRef<"paradas", 'Int'>
    readonly corrida_id: FieldRef<"paradas", 'Int'>
    readonly ordem: FieldRef<"paradas", 'Int'>
    readonly endereco: FieldRef<"paradas", 'String'>
    readonly latitude: FieldRef<"paradas", 'Float'>
    readonly longitude: FieldRef<"paradas", 'Float'>
    readonly tempo_espera: FieldRef<"paradas", 'Int'>
    readonly createdAt: FieldRef<"paradas", 'DateTime'>
    readonly updatedAt: FieldRef<"paradas", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * paradas findUnique
   */
  export type paradasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paradas
     */
    select?: paradasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paradas
     */
    omit?: paradasOmit<ExtArgs> | null
    /**
     * Filter, which paradas to fetch.
     */
    where: paradasWhereUniqueInput
  }

  /**
   * paradas findUniqueOrThrow
   */
  export type paradasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paradas
     */
    select?: paradasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paradas
     */
    omit?: paradasOmit<ExtArgs> | null
    /**
     * Filter, which paradas to fetch.
     */
    where: paradasWhereUniqueInput
  }

  /**
   * paradas findFirst
   */
  export type paradasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paradas
     */
    select?: paradasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paradas
     */
    omit?: paradasOmit<ExtArgs> | null
    /**
     * Filter, which paradas to fetch.
     */
    where?: paradasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of paradas to fetch.
     */
    orderBy?: paradasOrderByWithRelationInput | paradasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for paradas.
     */
    cursor?: paradasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` paradas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` paradas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of paradas.
     */
    distinct?: ParadasScalarFieldEnum | ParadasScalarFieldEnum[]
  }

  /**
   * paradas findFirstOrThrow
   */
  export type paradasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paradas
     */
    select?: paradasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paradas
     */
    omit?: paradasOmit<ExtArgs> | null
    /**
     * Filter, which paradas to fetch.
     */
    where?: paradasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of paradas to fetch.
     */
    orderBy?: paradasOrderByWithRelationInput | paradasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for paradas.
     */
    cursor?: paradasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` paradas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` paradas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of paradas.
     */
    distinct?: ParadasScalarFieldEnum | ParadasScalarFieldEnum[]
  }

  /**
   * paradas findMany
   */
  export type paradasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paradas
     */
    select?: paradasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paradas
     */
    omit?: paradasOmit<ExtArgs> | null
    /**
     * Filter, which paradas to fetch.
     */
    where?: paradasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of paradas to fetch.
     */
    orderBy?: paradasOrderByWithRelationInput | paradasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing paradas.
     */
    cursor?: paradasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` paradas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` paradas.
     */
    skip?: number
    distinct?: ParadasScalarFieldEnum | ParadasScalarFieldEnum[]
  }

  /**
   * paradas create
   */
  export type paradasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paradas
     */
    select?: paradasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paradas
     */
    omit?: paradasOmit<ExtArgs> | null
    /**
     * The data needed to create a paradas.
     */
    data: XOR<paradasCreateInput, paradasUncheckedCreateInput>
  }

  /**
   * paradas createMany
   */
  export type paradasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many paradas.
     */
    data: paradasCreateManyInput | paradasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * paradas createManyAndReturn
   */
  export type paradasCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paradas
     */
    select?: paradasSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the paradas
     */
    omit?: paradasOmit<ExtArgs> | null
    /**
     * The data used to create many paradas.
     */
    data: paradasCreateManyInput | paradasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * paradas update
   */
  export type paradasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paradas
     */
    select?: paradasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paradas
     */
    omit?: paradasOmit<ExtArgs> | null
    /**
     * The data needed to update a paradas.
     */
    data: XOR<paradasUpdateInput, paradasUncheckedUpdateInput>
    /**
     * Choose, which paradas to update.
     */
    where: paradasWhereUniqueInput
  }

  /**
   * paradas updateMany
   */
  export type paradasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update paradas.
     */
    data: XOR<paradasUpdateManyMutationInput, paradasUncheckedUpdateManyInput>
    /**
     * Filter which paradas to update
     */
    where?: paradasWhereInput
    /**
     * Limit how many paradas to update.
     */
    limit?: number
  }

  /**
   * paradas updateManyAndReturn
   */
  export type paradasUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paradas
     */
    select?: paradasSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the paradas
     */
    omit?: paradasOmit<ExtArgs> | null
    /**
     * The data used to update paradas.
     */
    data: XOR<paradasUpdateManyMutationInput, paradasUncheckedUpdateManyInput>
    /**
     * Filter which paradas to update
     */
    where?: paradasWhereInput
    /**
     * Limit how many paradas to update.
     */
    limit?: number
  }

  /**
   * paradas upsert
   */
  export type paradasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paradas
     */
    select?: paradasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paradas
     */
    omit?: paradasOmit<ExtArgs> | null
    /**
     * The filter to search for the paradas to update in case it exists.
     */
    where: paradasWhereUniqueInput
    /**
     * In case the paradas found by the `where` argument doesn't exist, create a new paradas with this data.
     */
    create: XOR<paradasCreateInput, paradasUncheckedCreateInput>
    /**
     * In case the paradas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<paradasUpdateInput, paradasUncheckedUpdateInput>
  }

  /**
   * paradas delete
   */
  export type paradasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paradas
     */
    select?: paradasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paradas
     */
    omit?: paradasOmit<ExtArgs> | null
    /**
     * Filter which paradas to delete.
     */
    where: paradasWhereUniqueInput
  }

  /**
   * paradas deleteMany
   */
  export type paradasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which paradas to delete
     */
    where?: paradasWhereInput
    /**
     * Limit how many paradas to delete.
     */
    limit?: number
  }

  /**
   * paradas without action
   */
  export type paradasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paradas
     */
    select?: paradasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paradas
     */
    omit?: paradasOmit<ExtArgs> | null
  }


  /**
   * Model recompensas
   */

  export type AggregateRecompensas = {
    _count: RecompensasCountAggregateOutputType | null
    _avg: RecompensasAvgAggregateOutputType | null
    _sum: RecompensasSumAggregateOutputType | null
    _min: RecompensasMinAggregateOutputType | null
    _max: RecompensasMaxAggregateOutputType | null
  }

  export type RecompensasAvgAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    valor: number | null
  }

  export type RecompensasSumAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    valor: number | null
  }

  export type RecompensasMinAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    descricao: string | null
    valor: number | null
    status: $Enums.enum_Recompensas_status | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecompensasMaxAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    descricao: string | null
    valor: number | null
    status: $Enums.enum_Recompensas_status | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecompensasCountAggregateOutputType = {
    id: number
    usuarioId: number
    descricao: number
    valor: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RecompensasAvgAggregateInputType = {
    id?: true
    usuarioId?: true
    valor?: true
  }

  export type RecompensasSumAggregateInputType = {
    id?: true
    usuarioId?: true
    valor?: true
  }

  export type RecompensasMinAggregateInputType = {
    id?: true
    usuarioId?: true
    descricao?: true
    valor?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecompensasMaxAggregateInputType = {
    id?: true
    usuarioId?: true
    descricao?: true
    valor?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecompensasCountAggregateInputType = {
    id?: true
    usuarioId?: true
    descricao?: true
    valor?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RecompensasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which recompensas to aggregate.
     */
    where?: recompensasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recompensas to fetch.
     */
    orderBy?: recompensasOrderByWithRelationInput | recompensasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: recompensasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recompensas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recompensas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned recompensas
    **/
    _count?: true | RecompensasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecompensasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecompensasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecompensasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecompensasMaxAggregateInputType
  }

  export type GetRecompensasAggregateType<T extends RecompensasAggregateArgs> = {
        [P in keyof T & keyof AggregateRecompensas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecompensas[P]>
      : GetScalarType<T[P], AggregateRecompensas[P]>
  }




  export type recompensasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: recompensasWhereInput
    orderBy?: recompensasOrderByWithAggregationInput | recompensasOrderByWithAggregationInput[]
    by: RecompensasScalarFieldEnum[] | RecompensasScalarFieldEnum
    having?: recompensasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecompensasCountAggregateInputType | true
    _avg?: RecompensasAvgAggregateInputType
    _sum?: RecompensasSumAggregateInputType
    _min?: RecompensasMinAggregateInputType
    _max?: RecompensasMaxAggregateInputType
  }

  export type RecompensasGroupByOutputType = {
    id: number
    usuarioId: number
    descricao: string
    valor: number
    status: $Enums.enum_Recompensas_status | null
    createdAt: Date
    updatedAt: Date
    _count: RecompensasCountAggregateOutputType | null
    _avg: RecompensasAvgAggregateOutputType | null
    _sum: RecompensasSumAggregateOutputType | null
    _min: RecompensasMinAggregateOutputType | null
    _max: RecompensasMaxAggregateOutputType | null
  }

  type GetRecompensasGroupByPayload<T extends recompensasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecompensasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecompensasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecompensasGroupByOutputType[P]>
            : GetScalarType<T[P], RecompensasGroupByOutputType[P]>
        }
      >
    >


  export type recompensasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    indicador_id?: boolean
    indicado_id?: boolean
    tipo?: boolean
    valor?: boolean
    status?: boolean
    data_gerada?: boolean
    referencia_corrida?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["recompensas"]>

  export type recompensasSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    indicador_id?: boolean
    indicado_id?: boolean
    tipo?: boolean
    valor?: boolean
    status?: boolean
    data_gerada?: boolean
    referencia_corrida?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["recompensas"]>

  export type recompensasSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    indicador_id?: boolean
    indicado_id?: boolean
    tipo?: boolean
    valor?: boolean
    status?: boolean
    data_gerada?: boolean
    referencia_corrida?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["recompensas"]>

  export type recompensasSelectScalar = {
    id?: boolean
    indicador_id?: boolean
    indicado_id?: boolean
    tipo?: boolean
    valor?: boolean
    status?: boolean
    data_gerada?: boolean
    referencia_corrida?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type recompensasOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "indicador_id" | "indicado_id" | "tipo" | "valor" | "status" | "data_gerada" | "referencia_corrida" | "createdAt" | "updatedAt", ExtArgs["result"]["recompensas"]>

  export type $recompensasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "recompensas"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      indicador_id: number
      indicado_id: number
      tipo: $Enums.enum_recompensas_tipo
      valor: number
      status: $Enums.enum_recompensas_status | null
      data_gerada: Date | null
      referencia_corrida: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["recompensas"]>
    composites: {}
  }

  type recompensasGetPayload<S extends boolean | null | undefined | recompensasDefaultArgs> = $Result.GetResult<Prisma.$recompensasPayload, S>

  type recompensasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<recompensasFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RecompensasCountAggregateInputType | true
    }

  export interface recompensasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['recompensas'], meta: { name: 'recompensas' } }
    /**
     * Find zero or one Recompensas that matches the filter.
     * @param {recompensasFindUniqueArgs} args - Arguments to find a Recompensas
     * @example
     * // Get one Recompensas
     * const recompensas = await prisma.recompensas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends recompensasFindUniqueArgs>(args: SelectSubset<T, recompensasFindUniqueArgs<ExtArgs>>): Prisma__recompensasClient<$Result.GetResult<Prisma.$recompensasPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Recompensas that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {recompensasFindUniqueOrThrowArgs} args - Arguments to find a Recompensas
     * @example
     * // Get one Recompensas
     * const recompensas = await prisma.recompensas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends recompensasFindUniqueOrThrowArgs>(args: SelectSubset<T, recompensasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__recompensasClient<$Result.GetResult<Prisma.$recompensasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Recompensas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recompensasFindFirstArgs} args - Arguments to find a Recompensas
     * @example
     * // Get one Recompensas
     * const recompensas = await prisma.recompensas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends recompensasFindFirstArgs>(args?: SelectSubset<T, recompensasFindFirstArgs<ExtArgs>>): Prisma__recompensasClient<$Result.GetResult<Prisma.$recompensasPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Recompensas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recompensasFindFirstOrThrowArgs} args - Arguments to find a Recompensas
     * @example
     * // Get one Recompensas
     * const recompensas = await prisma.recompensas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends recompensasFindFirstOrThrowArgs>(args?: SelectSubset<T, recompensasFindFirstOrThrowArgs<ExtArgs>>): Prisma__recompensasClient<$Result.GetResult<Prisma.$recompensasPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Recompensas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recompensasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Recompensas
     * const recompensas = await prisma.recompensas.findMany()
     * 
     * // Get first 10 Recompensas
     * const recompensas = await prisma.recompensas.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recompensasWithIdOnly = await prisma.recompensas.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends recompensasFindManyArgs>(args?: SelectSubset<T, recompensasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$recompensasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Recompensas.
     * @param {recompensasCreateArgs} args - Arguments to create a Recompensas.
     * @example
     * // Create one Recompensas
     * const Recompensas = await prisma.recompensas.create({
     *   data: {
     *     // ... data to create a Recompensas
     *   }
     * })
     * 
     */
    create<T extends recompensasCreateArgs>(args: SelectSubset<T, recompensasCreateArgs<ExtArgs>>): Prisma__recompensasClient<$Result.GetResult<Prisma.$recompensasPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Recompensas.
     * @param {recompensasCreateManyArgs} args - Arguments to create many Recompensas.
     * @example
     * // Create many Recompensas
     * const recompensas = await prisma.recompensas.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends recompensasCreateManyArgs>(args?: SelectSubset<T, recompensasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Recompensas and returns the data saved in the database.
     * @param {recompensasCreateManyAndReturnArgs} args - Arguments to create many Recompensas.
     * @example
     * // Create many Recompensas
     * const recompensas = await prisma.recompensas.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Recompensas and only return the `id`
     * const recompensasWithIdOnly = await prisma.recompensas.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends recompensasCreateManyAndReturnArgs>(args?: SelectSubset<T, recompensasCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$recompensasPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Recompensas.
     * @param {recompensasDeleteArgs} args - Arguments to delete one Recompensas.
     * @example
     * // Delete one Recompensas
     * const Recompensas = await prisma.recompensas.delete({
     *   where: {
     *     // ... filter to delete one Recompensas
     *   }
     * })
     * 
     */
    delete<T extends recompensasDeleteArgs>(args: SelectSubset<T, recompensasDeleteArgs<ExtArgs>>): Prisma__recompensasClient<$Result.GetResult<Prisma.$recompensasPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Recompensas.
     * @param {recompensasUpdateArgs} args - Arguments to update one Recompensas.
     * @example
     * // Update one Recompensas
     * const recompensas = await prisma.recompensas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends recompensasUpdateArgs>(args: SelectSubset<T, recompensasUpdateArgs<ExtArgs>>): Prisma__recompensasClient<$Result.GetResult<Prisma.$recompensasPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Recompensas.
     * @param {recompensasDeleteManyArgs} args - Arguments to filter Recompensas to delete.
     * @example
     * // Delete a few Recompensas
     * const { count } = await prisma.recompensas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends recompensasDeleteManyArgs>(args?: SelectSubset<T, recompensasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recompensas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recompensasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Recompensas
     * const recompensas = await prisma.recompensas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends recompensasUpdateManyArgs>(args: SelectSubset<T, recompensasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recompensas and returns the data updated in the database.
     * @param {recompensasUpdateManyAndReturnArgs} args - Arguments to update many Recompensas.
     * @example
     * // Update many Recompensas
     * const recompensas = await prisma.recompensas.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Recompensas and only return the `id`
     * const recompensasWithIdOnly = await prisma.recompensas.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends recompensasUpdateManyAndReturnArgs>(args: SelectSubset<T, recompensasUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$recompensasPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Recompensas.
     * @param {recompensasUpsertArgs} args - Arguments to update or create a Recompensas.
     * @example
     * // Update or create a Recompensas
     * const recompensas = await prisma.recompensas.upsert({
     *   create: {
     *     // ... data to create a Recompensas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Recompensas we want to update
     *   }
     * })
     */
    upsert<T extends recompensasUpsertArgs>(args: SelectSubset<T, recompensasUpsertArgs<ExtArgs>>): Prisma__recompensasClient<$Result.GetResult<Prisma.$recompensasPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Recompensas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recompensasCountArgs} args - Arguments to filter Recompensas to count.
     * @example
     * // Count the number of Recompensas
     * const count = await prisma.recompensas.count({
     *   where: {
     *     // ... the filter for the Recompensas we want to count
     *   }
     * })
    **/
    count<T extends recompensasCountArgs>(
      args?: Subset<T, recompensasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecompensasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Recompensas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecompensasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecompensasAggregateArgs>(args: Subset<T, RecompensasAggregateArgs>): Prisma.PrismaPromise<GetRecompensasAggregateType<T>>

    /**
     * Group by Recompensas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recompensasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends recompensasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: recompensasGroupByArgs['orderBy'] }
        : { orderBy?: recompensasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, recompensasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecompensasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the recompensas model
   */
  readonly fields: recompensasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for recompensas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__recompensasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the recompensas model
   */
  interface recompensasFieldRefs {
    readonly id: FieldRef<"recompensas", 'Int'>
    readonly indicador_id: FieldRef<"recompensas", 'Int'>
    readonly indicado_id: FieldRef<"recompensas", 'Int'>
    readonly tipo: FieldRef<"recompensas", 'enum_recompensas_tipo'>
    readonly valor: FieldRef<"recompensas", 'Float'>
    readonly status: FieldRef<"recompensas", 'enum_recompensas_status'>
    readonly data_gerada: FieldRef<"recompensas", 'DateTime'>
    readonly referencia_corrida: FieldRef<"recompensas", 'Int'>
    readonly createdAt: FieldRef<"recompensas", 'DateTime'>
    readonly updatedAt: FieldRef<"recompensas", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * recompensas findUnique
   */
  export type recompensasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recompensas
     */
    select?: recompensasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recompensas
     */
    omit?: recompensasOmit<ExtArgs> | null
    /**
     * Filter, which recompensas to fetch.
     */
    where: recompensasWhereUniqueInput
  }

  /**
   * recompensas findUniqueOrThrow
   */
  export type recompensasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recompensas
     */
    select?: recompensasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recompensas
     */
    omit?: recompensasOmit<ExtArgs> | null
    /**
     * Filter, which recompensas to fetch.
     */
    where: recompensasWhereUniqueInput
  }

  /**
   * recompensas findFirst
   */
  export type recompensasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recompensas
     */
    select?: recompensasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recompensas
     */
    omit?: recompensasOmit<ExtArgs> | null
    /**
     * Filter, which recompensas to fetch.
     */
    where?: recompensasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recompensas to fetch.
     */
    orderBy?: recompensasOrderByWithRelationInput | recompensasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for recompensas.
     */
    cursor?: recompensasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recompensas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recompensas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of recompensas.
     */
    distinct?: RecompensasScalarFieldEnum | RecompensasScalarFieldEnum[]
  }

  /**
   * recompensas findFirstOrThrow
   */
  export type recompensasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recompensas
     */
    select?: recompensasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recompensas
     */
    omit?: recompensasOmit<ExtArgs> | null
    /**
     * Filter, which recompensas to fetch.
     */
    where?: recompensasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recompensas to fetch.
     */
    orderBy?: recompensasOrderByWithRelationInput | recompensasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for recompensas.
     */
    cursor?: recompensasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recompensas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recompensas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of recompensas.
     */
    distinct?: RecompensasScalarFieldEnum | RecompensasScalarFieldEnum[]
  }

  /**
   * recompensas findMany
   */
  export type recompensasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recompensas
     */
    select?: recompensasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recompensas
     */
    omit?: recompensasOmit<ExtArgs> | null
    /**
     * Filter, which recompensas to fetch.
     */
    where?: recompensasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recompensas to fetch.
     */
    orderBy?: recompensasOrderByWithRelationInput | recompensasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing recompensas.
     */
    cursor?: recompensasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recompensas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recompensas.
     */
    skip?: number
    distinct?: RecompensasScalarFieldEnum | RecompensasScalarFieldEnum[]
  }

  /**
   * recompensas create
   */
  export type recompensasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recompensas
     */
    select?: recompensasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recompensas
     */
    omit?: recompensasOmit<ExtArgs> | null
    /**
     * The data needed to create a recompensas.
     */
    data: XOR<recompensasCreateInput, recompensasUncheckedCreateInput>
  }

  /**
   * recompensas createMany
   */
  export type recompensasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many recompensas.
     */
    data: recompensasCreateManyInput | recompensasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * recompensas createManyAndReturn
   */
  export type recompensasCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recompensas
     */
    select?: recompensasSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the recompensas
     */
    omit?: recompensasOmit<ExtArgs> | null
    /**
     * The data used to create many recompensas.
     */
    data: recompensasCreateManyInput | recompensasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * recompensas update
   */
  export type recompensasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recompensas
     */
    select?: recompensasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recompensas
     */
    omit?: recompensasOmit<ExtArgs> | null
    /**
     * The data needed to update a recompensas.
     */
    data: XOR<recompensasUpdateInput, recompensasUncheckedUpdateInput>
    /**
     * Choose, which recompensas to update.
     */
    where: recompensasWhereUniqueInput
  }

  /**
   * recompensas updateMany
   */
  export type recompensasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update recompensas.
     */
    data: XOR<recompensasUpdateManyMutationInput, recompensasUncheckedUpdateManyInput>
    /**
     * Filter which recompensas to update
     */
    where?: recompensasWhereInput
    /**
     * Limit how many recompensas to update.
     */
    limit?: number
  }

  /**
   * recompensas updateManyAndReturn
   */
  export type recompensasUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recompensas
     */
    select?: recompensasSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the recompensas
     */
    omit?: recompensasOmit<ExtArgs> | null
    /**
     * The data used to update recompensas.
     */
    data: XOR<recompensasUpdateManyMutationInput, recompensasUncheckedUpdateManyInput>
    /**
     * Filter which recompensas to update
     */
    where?: recompensasWhereInput
    /**
     * Limit how many recompensas to update.
     */
    limit?: number
  }

  /**
   * recompensas upsert
   */
  export type recompensasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recompensas
     */
    select?: recompensasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recompensas
     */
    omit?: recompensasOmit<ExtArgs> | null
    /**
     * The filter to search for the recompensas to update in case it exists.
     */
    where: recompensasWhereUniqueInput
    /**
     * In case the recompensas found by the `where` argument doesn't exist, create a new recompensas with this data.
     */
    create: XOR<recompensasCreateInput, recompensasUncheckedCreateInput>
    /**
     * In case the recompensas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<recompensasUpdateInput, recompensasUncheckedUpdateInput>
  }

  /**
   * recompensas delete
   */
  export type recompensasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recompensas
     */
    select?: recompensasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recompensas
     */
    omit?: recompensasOmit<ExtArgs> | null
    /**
     * Filter which recompensas to delete.
     */
    where: recompensasWhereUniqueInput
  }

  /**
   * recompensas deleteMany
   */
  export type recompensasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which recompensas to delete
     */
    where?: recompensasWhereInput
    /**
     * Limit how many recompensas to delete.
     */
    limit?: number
  }

  /**
   * recompensas without action
   */
  export type recompensasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recompensas
     */
    select?: recompensasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recompensas
     */
    omit?: recompensasOmit<ExtArgs> | null
  }


  /**
   * Model saques
   */

  export type AggregateSaques = {
    _count: SaquesCountAggregateOutputType | null
    _avg: SaquesAvgAggregateOutputType | null
    _sum: SaquesSumAggregateOutputType | null
    _min: SaquesMinAggregateOutputType | null
    _max: SaquesMaxAggregateOutputType | null
  }

  export type SaquesAvgAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    valor: Decimal | null
  }

  export type SaquesSumAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    valor: Decimal | null
  }

  export type SaquesMinAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    valor: Decimal | null
    status: $Enums.enum_Saques_status | null
    tipo: $Enums.enum_Saques_tipo | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SaquesMaxAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    valor: Decimal | null
    status: $Enums.enum_Saques_status | null
    tipo: $Enums.enum_Saques_tipo | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SaquesCountAggregateOutputType = {
    id: number
    usuarioId: number
    valor: number
    status: number
    tipo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SaquesAvgAggregateInputType = {
    id?: true
    usuarioId?: true
    valor?: true
  }

  export type SaquesSumAggregateInputType = {
    id?: true
    usuarioId?: true
    valor?: true
  }

  export type SaquesMinAggregateInputType = {
    id?: true
    usuarioId?: true
    valor?: true
    status?: true
    tipo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SaquesMaxAggregateInputType = {
    id?: true
    usuarioId?: true
    valor?: true
    status?: true
    tipo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SaquesCountAggregateInputType = {
    id?: true
    usuarioId?: true
    valor?: true
    status?: true
    tipo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SaquesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which saques to aggregate.
     */
    where?: saquesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of saques to fetch.
     */
    orderBy?: saquesOrderByWithRelationInput | saquesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: saquesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` saques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` saques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned saques
    **/
    _count?: true | SaquesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SaquesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SaquesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SaquesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SaquesMaxAggregateInputType
  }

  export type GetSaquesAggregateType<T extends SaquesAggregateArgs> = {
        [P in keyof T & keyof AggregateSaques]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSaques[P]>
      : GetScalarType<T[P], AggregateSaques[P]>
  }




  export type saquesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: saquesWhereInput
    orderBy?: saquesOrderByWithAggregationInput | saquesOrderByWithAggregationInput[]
    by: SaquesScalarFieldEnum[] | SaquesScalarFieldEnum
    having?: saquesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SaquesCountAggregateInputType | true
    _avg?: SaquesAvgAggregateInputType
    _sum?: SaquesSumAggregateInputType
    _min?: SaquesMinAggregateInputType
    _max?: SaquesMaxAggregateInputType
  }

  export type SaquesGroupByOutputType = {
    id: number
    usuarioId: number
    valor: Decimal
    status: $Enums.enum_Saques_status | null
    tipo: $Enums.enum_Saques_tipo
    createdAt: Date
    updatedAt: Date
    _count: SaquesCountAggregateOutputType | null
    _avg: SaquesAvgAggregateOutputType | null
    _sum: SaquesSumAggregateOutputType | null
    _min: SaquesMinAggregateOutputType | null
    _max: SaquesMaxAggregateOutputType | null
  }

  type GetSaquesGroupByPayload<T extends saquesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SaquesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SaquesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SaquesGroupByOutputType[P]>
            : GetScalarType<T[P], SaquesGroupByOutputType[P]>
        }
      >
    >


  export type saquesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    valor?: boolean
    status?: boolean
    tipo?: boolean
    pix?: boolean
    data_pedido?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["saques"]>

  export type saquesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    valor?: boolean
    status?: boolean
    tipo?: boolean
    pix?: boolean
    data_pedido?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["saques"]>

  export type saquesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    valor?: boolean
    status?: boolean
    tipo?: boolean
    pix?: boolean
    data_pedido?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["saques"]>

  export type saquesSelectScalar = {
    id?: boolean
    usuario_id?: boolean
    valor?: boolean
    status?: boolean
    tipo?: boolean
    pix?: boolean
    data_pedido?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type saquesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "usuario_id" | "valor" | "status" | "tipo" | "pix" | "data_pedido" | "createdAt" | "updatedAt", ExtArgs["result"]["saques"]>

  export type $saquesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "saques"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      usuario_id: number
      valor: number
      status: $Enums.enum_saques_status | null
      tipo: $Enums.enum_saques_tipo
      pix: string
      data_pedido: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["saques"]>
    composites: {}
  }

  type saquesGetPayload<S extends boolean | null | undefined | saquesDefaultArgs> = $Result.GetResult<Prisma.$saquesPayload, S>

  type saquesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<saquesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SaquesCountAggregateInputType | true
    }

  export interface saquesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['saques'], meta: { name: 'saques' } }
    /**
     * Find zero or one Saques that matches the filter.
     * @param {saquesFindUniqueArgs} args - Arguments to find a Saques
     * @example
     * // Get one Saques
     * const saques = await prisma.saques.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends saquesFindUniqueArgs>(args: SelectSubset<T, saquesFindUniqueArgs<ExtArgs>>): Prisma__saquesClient<$Result.GetResult<Prisma.$saquesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Saques that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {saquesFindUniqueOrThrowArgs} args - Arguments to find a Saques
     * @example
     * // Get one Saques
     * const saques = await prisma.saques.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends saquesFindUniqueOrThrowArgs>(args: SelectSubset<T, saquesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__saquesClient<$Result.GetResult<Prisma.$saquesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Saques that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saquesFindFirstArgs} args - Arguments to find a Saques
     * @example
     * // Get one Saques
     * const saques = await prisma.saques.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends saquesFindFirstArgs>(args?: SelectSubset<T, saquesFindFirstArgs<ExtArgs>>): Prisma__saquesClient<$Result.GetResult<Prisma.$saquesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Saques that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saquesFindFirstOrThrowArgs} args - Arguments to find a Saques
     * @example
     * // Get one Saques
     * const saques = await prisma.saques.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends saquesFindFirstOrThrowArgs>(args?: SelectSubset<T, saquesFindFirstOrThrowArgs<ExtArgs>>): Prisma__saquesClient<$Result.GetResult<Prisma.$saquesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Saques that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saquesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Saques
     * const saques = await prisma.saques.findMany()
     * 
     * // Get first 10 Saques
     * const saques = await prisma.saques.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const saquesWithIdOnly = await prisma.saques.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends saquesFindManyArgs>(args?: SelectSubset<T, saquesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$saquesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Saques.
     * @param {saquesCreateArgs} args - Arguments to create a Saques.
     * @example
     * // Create one Saques
     * const Saques = await prisma.saques.create({
     *   data: {
     *     // ... data to create a Saques
     *   }
     * })
     * 
     */
    create<T extends saquesCreateArgs>(args: SelectSubset<T, saquesCreateArgs<ExtArgs>>): Prisma__saquesClient<$Result.GetResult<Prisma.$saquesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Saques.
     * @param {saquesCreateManyArgs} args - Arguments to create many Saques.
     * @example
     * // Create many Saques
     * const saques = await prisma.saques.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends saquesCreateManyArgs>(args?: SelectSubset<T, saquesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Saques and returns the data saved in the database.
     * @param {saquesCreateManyAndReturnArgs} args - Arguments to create many Saques.
     * @example
     * // Create many Saques
     * const saques = await prisma.saques.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Saques and only return the `id`
     * const saquesWithIdOnly = await prisma.saques.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends saquesCreateManyAndReturnArgs>(args?: SelectSubset<T, saquesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$saquesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Saques.
     * @param {saquesDeleteArgs} args - Arguments to delete one Saques.
     * @example
     * // Delete one Saques
     * const Saques = await prisma.saques.delete({
     *   where: {
     *     // ... filter to delete one Saques
     *   }
     * })
     * 
     */
    delete<T extends saquesDeleteArgs>(args: SelectSubset<T, saquesDeleteArgs<ExtArgs>>): Prisma__saquesClient<$Result.GetResult<Prisma.$saquesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Saques.
     * @param {saquesUpdateArgs} args - Arguments to update one Saques.
     * @example
     * // Update one Saques
     * const saques = await prisma.saques.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends saquesUpdateArgs>(args: SelectSubset<T, saquesUpdateArgs<ExtArgs>>): Prisma__saquesClient<$Result.GetResult<Prisma.$saquesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Saques.
     * @param {saquesDeleteManyArgs} args - Arguments to filter Saques to delete.
     * @example
     * // Delete a few Saques
     * const { count } = await prisma.saques.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends saquesDeleteManyArgs>(args?: SelectSubset<T, saquesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Saques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saquesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Saques
     * const saques = await prisma.saques.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends saquesUpdateManyArgs>(args: SelectSubset<T, saquesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Saques and returns the data updated in the database.
     * @param {saquesUpdateManyAndReturnArgs} args - Arguments to update many Saques.
     * @example
     * // Update many Saques
     * const saques = await prisma.saques.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Saques and only return the `id`
     * const saquesWithIdOnly = await prisma.saques.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends saquesUpdateManyAndReturnArgs>(args: SelectSubset<T, saquesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$saquesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Saques.
     * @param {saquesUpsertArgs} args - Arguments to update or create a Saques.
     * @example
     * // Update or create a Saques
     * const saques = await prisma.saques.upsert({
     *   create: {
     *     // ... data to create a Saques
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Saques we want to update
     *   }
     * })
     */
    upsert<T extends saquesUpsertArgs>(args: SelectSubset<T, saquesUpsertArgs<ExtArgs>>): Prisma__saquesClient<$Result.GetResult<Prisma.$saquesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Saques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saquesCountArgs} args - Arguments to filter Saques to count.
     * @example
     * // Count the number of Saques
     * const count = await prisma.saques.count({
     *   where: {
     *     // ... the filter for the Saques we want to count
     *   }
     * })
    **/
    count<T extends saquesCountArgs>(
      args?: Subset<T, saquesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SaquesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Saques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaquesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SaquesAggregateArgs>(args: Subset<T, SaquesAggregateArgs>): Prisma.PrismaPromise<GetSaquesAggregateType<T>>

    /**
     * Group by Saques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saquesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends saquesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: saquesGroupByArgs['orderBy'] }
        : { orderBy?: saquesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, saquesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaquesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the saques model
   */
  readonly fields: saquesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for saques.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__saquesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the saques model
   */
  interface saquesFieldRefs {
    readonly id: FieldRef<"saques", 'Int'>
    readonly usuario_id: FieldRef<"saques", 'Int'>
    readonly valor: FieldRef<"saques", 'Float'>
    readonly status: FieldRef<"saques", 'enum_saques_status'>
    readonly tipo: FieldRef<"saques", 'enum_saques_tipo'>
    readonly pix: FieldRef<"saques", 'String'>
    readonly data_pedido: FieldRef<"saques", 'DateTime'>
    readonly createdAt: FieldRef<"saques", 'DateTime'>
    readonly updatedAt: FieldRef<"saques", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * saques findUnique
   */
  export type saquesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saques
     */
    select?: saquesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saques
     */
    omit?: saquesOmit<ExtArgs> | null
    /**
     * Filter, which saques to fetch.
     */
    where: saquesWhereUniqueInput
  }

  /**
   * saques findUniqueOrThrow
   */
  export type saquesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saques
     */
    select?: saquesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saques
     */
    omit?: saquesOmit<ExtArgs> | null
    /**
     * Filter, which saques to fetch.
     */
    where: saquesWhereUniqueInput
  }

  /**
   * saques findFirst
   */
  export type saquesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saques
     */
    select?: saquesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saques
     */
    omit?: saquesOmit<ExtArgs> | null
    /**
     * Filter, which saques to fetch.
     */
    where?: saquesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of saques to fetch.
     */
    orderBy?: saquesOrderByWithRelationInput | saquesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for saques.
     */
    cursor?: saquesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` saques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` saques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of saques.
     */
    distinct?: SaquesScalarFieldEnum | SaquesScalarFieldEnum[]
  }

  /**
   * saques findFirstOrThrow
   */
  export type saquesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saques
     */
    select?: saquesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saques
     */
    omit?: saquesOmit<ExtArgs> | null
    /**
     * Filter, which saques to fetch.
     */
    where?: saquesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of saques to fetch.
     */
    orderBy?: saquesOrderByWithRelationInput | saquesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for saques.
     */
    cursor?: saquesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` saques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` saques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of saques.
     */
    distinct?: SaquesScalarFieldEnum | SaquesScalarFieldEnum[]
  }

  /**
   * saques findMany
   */
  export type saquesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saques
     */
    select?: saquesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saques
     */
    omit?: saquesOmit<ExtArgs> | null
    /**
     * Filter, which saques to fetch.
     */
    where?: saquesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of saques to fetch.
     */
    orderBy?: saquesOrderByWithRelationInput | saquesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing saques.
     */
    cursor?: saquesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` saques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` saques.
     */
    skip?: number
    distinct?: SaquesScalarFieldEnum | SaquesScalarFieldEnum[]
  }

  /**
   * saques create
   */
  export type saquesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saques
     */
    select?: saquesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saques
     */
    omit?: saquesOmit<ExtArgs> | null
    /**
     * The data needed to create a saques.
     */
    data: XOR<saquesCreateInput, saquesUncheckedCreateInput>
  }

  /**
   * saques createMany
   */
  export type saquesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many saques.
     */
    data: saquesCreateManyInput | saquesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * saques createManyAndReturn
   */
  export type saquesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saques
     */
    select?: saquesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the saques
     */
    omit?: saquesOmit<ExtArgs> | null
    /**
     * The data used to create many saques.
     */
    data: saquesCreateManyInput | saquesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * saques update
   */
  export type saquesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saques
     */
    select?: saquesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saques
     */
    omit?: saquesOmit<ExtArgs> | null
    /**
     * The data needed to update a saques.
     */
    data: XOR<saquesUpdateInput, saquesUncheckedUpdateInput>
    /**
     * Choose, which saques to update.
     */
    where: saquesWhereUniqueInput
  }

  /**
   * saques updateMany
   */
  export type saquesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update saques.
     */
    data: XOR<saquesUpdateManyMutationInput, saquesUncheckedUpdateManyInput>
    /**
     * Filter which saques to update
     */
    where?: saquesWhereInput
    /**
     * Limit how many saques to update.
     */
    limit?: number
  }

  /**
   * saques updateManyAndReturn
   */
  export type saquesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saques
     */
    select?: saquesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the saques
     */
    omit?: saquesOmit<ExtArgs> | null
    /**
     * The data used to update saques.
     */
    data: XOR<saquesUpdateManyMutationInput, saquesUncheckedUpdateManyInput>
    /**
     * Filter which saques to update
     */
    where?: saquesWhereInput
    /**
     * Limit how many saques to update.
     */
    limit?: number
  }

  /**
   * saques upsert
   */
  export type saquesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saques
     */
    select?: saquesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saques
     */
    omit?: saquesOmit<ExtArgs> | null
    /**
     * The filter to search for the saques to update in case it exists.
     */
    where: saquesWhereUniqueInput
    /**
     * In case the saques found by the `where` argument doesn't exist, create a new saques with this data.
     */
    create: XOR<saquesCreateInput, saquesUncheckedCreateInput>
    /**
     * In case the saques was found with the provided `where` argument, update it with this data.
     */
    update: XOR<saquesUpdateInput, saquesUncheckedUpdateInput>
  }

  /**
   * saques delete
   */
  export type saquesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saques
     */
    select?: saquesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saques
     */
    omit?: saquesOmit<ExtArgs> | null
    /**
     * Filter which saques to delete.
     */
    where: saquesWhereUniqueInput
  }

  /**
   * saques deleteMany
   */
  export type saquesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which saques to delete
     */
    where?: saquesWhereInput
    /**
     * Limit how many saques to delete.
     */
    limit?: number
  }

  /**
   * saques without action
   */
  export type saquesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saques
     */
    select?: saquesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saques
     */
    omit?: saquesOmit<ExtArgs> | null
  }


  /**
   * Model transacoes
   */

  export type AggregateTransacoes = {
    _count: TransacoesCountAggregateOutputType | null
    _avg: TransacoesAvgAggregateOutputType | null
    _sum: TransacoesSumAggregateOutputType | null
    _min: TransacoesMinAggregateOutputType | null
    _max: TransacoesMaxAggregateOutputType | null
  }

  export type TransacoesAvgAggregateOutputType = {
    id: number | null
    usuario_id: number | null
    valor: number | null
  }

  export type TransacoesSumAggregateOutputType = {
    id: number | null
    usuario_id: number | null
    valor: number | null
  }

  export type TransacoesMinAggregateOutputType = {
    id: number | null
    usuario_id: number | null
    tipo: $Enums.enum_transacoes_tipo | null
    origem: $Enums.enum_transacoes_origem | null
    descricao: string | null
    valor: number | null
    data_transacao: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransacoesMaxAggregateOutputType = {
    id: number | null
    usuario_id: number | null
    tipo: $Enums.enum_transacoes_tipo | null
    origem: $Enums.enum_transacoes_origem | null
    descricao: string | null
    valor: number | null
    data_transacao: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransacoesCountAggregateOutputType = {
    id: number
    usuario_id: number
    tipo: number
    origem: number
    descricao: number
    valor: number
    data_transacao: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransacoesAvgAggregateInputType = {
    id?: true
    usuario_id?: true
    valor?: true
  }

  export type TransacoesSumAggregateInputType = {
    id?: true
    usuario_id?: true
    valor?: true
  }

  export type TransacoesMinAggregateInputType = {
    id?: true
    usuario_id?: true
    tipo?: true
    origem?: true
    descricao?: true
    valor?: true
    data_transacao?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransacoesMaxAggregateInputType = {
    id?: true
    usuario_id?: true
    tipo?: true
    origem?: true
    descricao?: true
    valor?: true
    data_transacao?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransacoesCountAggregateInputType = {
    id?: true
    usuario_id?: true
    tipo?: true
    origem?: true
    descricao?: true
    valor?: true
    data_transacao?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransacoesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transacoes to aggregate.
     */
    where?: transacoesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transacoes to fetch.
     */
    orderBy?: transacoesOrderByWithRelationInput | transacoesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: transacoesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transacoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transacoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned transacoes
    **/
    _count?: true | TransacoesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransacoesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransacoesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransacoesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransacoesMaxAggregateInputType
  }

  export type GetTransacoesAggregateType<T extends TransacoesAggregateArgs> = {
        [P in keyof T & keyof AggregateTransacoes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransacoes[P]>
      : GetScalarType<T[P], AggregateTransacoes[P]>
  }




  export type transacoesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transacoesWhereInput
    orderBy?: transacoesOrderByWithAggregationInput | transacoesOrderByWithAggregationInput[]
    by: TransacoesScalarFieldEnum[] | TransacoesScalarFieldEnum
    having?: transacoesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransacoesCountAggregateInputType | true
    _avg?: TransacoesAvgAggregateInputType
    _sum?: TransacoesSumAggregateInputType
    _min?: TransacoesMinAggregateInputType
    _max?: TransacoesMaxAggregateInputType
  }

  export type TransacoesGroupByOutputType = {
    id: number
    usuario_id: number
    tipo: $Enums.enum_transacoes_tipo
    origem: $Enums.enum_transacoes_origem
    descricao: string | null
    valor: number
    data_transacao: Date | null
    createdAt: Date
    updatedAt: Date
    _count: TransacoesCountAggregateOutputType | null
    _avg: TransacoesAvgAggregateOutputType | null
    _sum: TransacoesSumAggregateOutputType | null
    _min: TransacoesMinAggregateOutputType | null
    _max: TransacoesMaxAggregateOutputType | null
  }

  type GetTransacoesGroupByPayload<T extends transacoesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransacoesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransacoesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransacoesGroupByOutputType[P]>
            : GetScalarType<T[P], TransacoesGroupByOutputType[P]>
        }
      >
    >


  export type transacoesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    tipo?: boolean
    origem?: boolean
    descricao?: boolean
    valor?: boolean
    data_transacao?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["transacoes"]>

  export type transacoesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    tipo?: boolean
    origem?: boolean
    descricao?: boolean
    valor?: boolean
    data_transacao?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["transacoes"]>

  export type transacoesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    tipo?: boolean
    origem?: boolean
    descricao?: boolean
    valor?: boolean
    data_transacao?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["transacoes"]>

  export type transacoesSelectScalar = {
    id?: boolean
    usuario_id?: boolean
    tipo?: boolean
    origem?: boolean
    descricao?: boolean
    valor?: boolean
    data_transacao?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type transacoesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "usuario_id" | "tipo" | "origem" | "descricao" | "valor" | "data_transacao" | "createdAt" | "updatedAt", ExtArgs["result"]["transacoes"]>

  export type $transacoesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "transacoes"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      usuario_id: number
      tipo: $Enums.enum_transacoes_tipo
      origem: $Enums.enum_transacoes_origem
      descricao: string | null
      valor: number
      data_transacao: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transacoes"]>
    composites: {}
  }

  type transacoesGetPayload<S extends boolean | null | undefined | transacoesDefaultArgs> = $Result.GetResult<Prisma.$transacoesPayload, S>

  type transacoesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<transacoesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransacoesCountAggregateInputType | true
    }

  export interface transacoesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['transacoes'], meta: { name: 'transacoes' } }
    /**
     * Find zero or one Transacoes that matches the filter.
     * @param {transacoesFindUniqueArgs} args - Arguments to find a Transacoes
     * @example
     * // Get one Transacoes
     * const transacoes = await prisma.transacoes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends transacoesFindUniqueArgs>(args: SelectSubset<T, transacoesFindUniqueArgs<ExtArgs>>): Prisma__transacoesClient<$Result.GetResult<Prisma.$transacoesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transacoes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {transacoesFindUniqueOrThrowArgs} args - Arguments to find a Transacoes
     * @example
     * // Get one Transacoes
     * const transacoes = await prisma.transacoes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends transacoesFindUniqueOrThrowArgs>(args: SelectSubset<T, transacoesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__transacoesClient<$Result.GetResult<Prisma.$transacoesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transacoes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transacoesFindFirstArgs} args - Arguments to find a Transacoes
     * @example
     * // Get one Transacoes
     * const transacoes = await prisma.transacoes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends transacoesFindFirstArgs>(args?: SelectSubset<T, transacoesFindFirstArgs<ExtArgs>>): Prisma__transacoesClient<$Result.GetResult<Prisma.$transacoesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transacoes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transacoesFindFirstOrThrowArgs} args - Arguments to find a Transacoes
     * @example
     * // Get one Transacoes
     * const transacoes = await prisma.transacoes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends transacoesFindFirstOrThrowArgs>(args?: SelectSubset<T, transacoesFindFirstOrThrowArgs<ExtArgs>>): Prisma__transacoesClient<$Result.GetResult<Prisma.$transacoesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transacoes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transacoesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transacoes
     * const transacoes = await prisma.transacoes.findMany()
     * 
     * // Get first 10 Transacoes
     * const transacoes = await prisma.transacoes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transacoesWithIdOnly = await prisma.transacoes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends transacoesFindManyArgs>(args?: SelectSubset<T, transacoesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transacoesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transacoes.
     * @param {transacoesCreateArgs} args - Arguments to create a Transacoes.
     * @example
     * // Create one Transacoes
     * const Transacoes = await prisma.transacoes.create({
     *   data: {
     *     // ... data to create a Transacoes
     *   }
     * })
     * 
     */
    create<T extends transacoesCreateArgs>(args: SelectSubset<T, transacoesCreateArgs<ExtArgs>>): Prisma__transacoesClient<$Result.GetResult<Prisma.$transacoesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transacoes.
     * @param {transacoesCreateManyArgs} args - Arguments to create many Transacoes.
     * @example
     * // Create many Transacoes
     * const transacoes = await prisma.transacoes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends transacoesCreateManyArgs>(args?: SelectSubset<T, transacoesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transacoes and returns the data saved in the database.
     * @param {transacoesCreateManyAndReturnArgs} args - Arguments to create many Transacoes.
     * @example
     * // Create many Transacoes
     * const transacoes = await prisma.transacoes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transacoes and only return the `id`
     * const transacoesWithIdOnly = await prisma.transacoes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends transacoesCreateManyAndReturnArgs>(args?: SelectSubset<T, transacoesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transacoesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transacoes.
     * @param {transacoesDeleteArgs} args - Arguments to delete one Transacoes.
     * @example
     * // Delete one Transacoes
     * const Transacoes = await prisma.transacoes.delete({
     *   where: {
     *     // ... filter to delete one Transacoes
     *   }
     * })
     * 
     */
    delete<T extends transacoesDeleteArgs>(args: SelectSubset<T, transacoesDeleteArgs<ExtArgs>>): Prisma__transacoesClient<$Result.GetResult<Prisma.$transacoesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transacoes.
     * @param {transacoesUpdateArgs} args - Arguments to update one Transacoes.
     * @example
     * // Update one Transacoes
     * const transacoes = await prisma.transacoes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends transacoesUpdateArgs>(args: SelectSubset<T, transacoesUpdateArgs<ExtArgs>>): Prisma__transacoesClient<$Result.GetResult<Prisma.$transacoesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transacoes.
     * @param {transacoesDeleteManyArgs} args - Arguments to filter Transacoes to delete.
     * @example
     * // Delete a few Transacoes
     * const { count } = await prisma.transacoes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends transacoesDeleteManyArgs>(args?: SelectSubset<T, transacoesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transacoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transacoesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transacoes
     * const transacoes = await prisma.transacoes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends transacoesUpdateManyArgs>(args: SelectSubset<T, transacoesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transacoes and returns the data updated in the database.
     * @param {transacoesUpdateManyAndReturnArgs} args - Arguments to update many Transacoes.
     * @example
     * // Update many Transacoes
     * const transacoes = await prisma.transacoes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transacoes and only return the `id`
     * const transacoesWithIdOnly = await prisma.transacoes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends transacoesUpdateManyAndReturnArgs>(args: SelectSubset<T, transacoesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transacoesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transacoes.
     * @param {transacoesUpsertArgs} args - Arguments to update or create a Transacoes.
     * @example
     * // Update or create a Transacoes
     * const transacoes = await prisma.transacoes.upsert({
     *   create: {
     *     // ... data to create a Transacoes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transacoes we want to update
     *   }
     * })
     */
    upsert<T extends transacoesUpsertArgs>(args: SelectSubset<T, transacoesUpsertArgs<ExtArgs>>): Prisma__transacoesClient<$Result.GetResult<Prisma.$transacoesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transacoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transacoesCountArgs} args - Arguments to filter Transacoes to count.
     * @example
     * // Count the number of Transacoes
     * const count = await prisma.transacoes.count({
     *   where: {
     *     // ... the filter for the Transacoes we want to count
     *   }
     * })
    **/
    count<T extends transacoesCountArgs>(
      args?: Subset<T, transacoesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransacoesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transacoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransacoesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransacoesAggregateArgs>(args: Subset<T, TransacoesAggregateArgs>): Prisma.PrismaPromise<GetTransacoesAggregateType<T>>

    /**
     * Group by Transacoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transacoesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends transacoesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: transacoesGroupByArgs['orderBy'] }
        : { orderBy?: transacoesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, transacoesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransacoesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the transacoes model
   */
  readonly fields: transacoesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for transacoes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__transacoesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the transacoes model
   */
  interface transacoesFieldRefs {
    readonly id: FieldRef<"transacoes", 'Int'>
    readonly usuario_id: FieldRef<"transacoes", 'Int'>
    readonly tipo: FieldRef<"transacoes", 'enum_transacoes_tipo'>
    readonly origem: FieldRef<"transacoes", 'enum_transacoes_origem'>
    readonly descricao: FieldRef<"transacoes", 'String'>
    readonly valor: FieldRef<"transacoes", 'Float'>
    readonly data_transacao: FieldRef<"transacoes", 'DateTime'>
    readonly createdAt: FieldRef<"transacoes", 'DateTime'>
    readonly updatedAt: FieldRef<"transacoes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * transacoes findUnique
   */
  export type transacoesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transacoes
     */
    select?: transacoesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transacoes
     */
    omit?: transacoesOmit<ExtArgs> | null
    /**
     * Filter, which transacoes to fetch.
     */
    where: transacoesWhereUniqueInput
  }

  /**
   * transacoes findUniqueOrThrow
   */
  export type transacoesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transacoes
     */
    select?: transacoesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transacoes
     */
    omit?: transacoesOmit<ExtArgs> | null
    /**
     * Filter, which transacoes to fetch.
     */
    where: transacoesWhereUniqueInput
  }

  /**
   * transacoes findFirst
   */
  export type transacoesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transacoes
     */
    select?: transacoesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transacoes
     */
    omit?: transacoesOmit<ExtArgs> | null
    /**
     * Filter, which transacoes to fetch.
     */
    where?: transacoesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transacoes to fetch.
     */
    orderBy?: transacoesOrderByWithRelationInput | transacoesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transacoes.
     */
    cursor?: transacoesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transacoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transacoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transacoes.
     */
    distinct?: TransacoesScalarFieldEnum | TransacoesScalarFieldEnum[]
  }

  /**
   * transacoes findFirstOrThrow
   */
  export type transacoesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transacoes
     */
    select?: transacoesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transacoes
     */
    omit?: transacoesOmit<ExtArgs> | null
    /**
     * Filter, which transacoes to fetch.
     */
    where?: transacoesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transacoes to fetch.
     */
    orderBy?: transacoesOrderByWithRelationInput | transacoesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transacoes.
     */
    cursor?: transacoesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transacoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transacoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transacoes.
     */
    distinct?: TransacoesScalarFieldEnum | TransacoesScalarFieldEnum[]
  }

  /**
   * transacoes findMany
   */
  export type transacoesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transacoes
     */
    select?: transacoesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transacoes
     */
    omit?: transacoesOmit<ExtArgs> | null
    /**
     * Filter, which transacoes to fetch.
     */
    where?: transacoesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transacoes to fetch.
     */
    orderBy?: transacoesOrderByWithRelationInput | transacoesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing transacoes.
     */
    cursor?: transacoesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transacoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transacoes.
     */
    skip?: number
    distinct?: TransacoesScalarFieldEnum | TransacoesScalarFieldEnum[]
  }

  /**
   * transacoes create
   */
  export type transacoesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transacoes
     */
    select?: transacoesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transacoes
     */
    omit?: transacoesOmit<ExtArgs> | null
    /**
     * The data needed to create a transacoes.
     */
    data: XOR<transacoesCreateInput, transacoesUncheckedCreateInput>
  }

  /**
   * transacoes createMany
   */
  export type transacoesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many transacoes.
     */
    data: transacoesCreateManyInput | transacoesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * transacoes createManyAndReturn
   */
  export type transacoesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transacoes
     */
    select?: transacoesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the transacoes
     */
    omit?: transacoesOmit<ExtArgs> | null
    /**
     * The data used to create many transacoes.
     */
    data: transacoesCreateManyInput | transacoesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * transacoes update
   */
  export type transacoesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transacoes
     */
    select?: transacoesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transacoes
     */
    omit?: transacoesOmit<ExtArgs> | null
    /**
     * The data needed to update a transacoes.
     */
    data: XOR<transacoesUpdateInput, transacoesUncheckedUpdateInput>
    /**
     * Choose, which transacoes to update.
     */
    where: transacoesWhereUniqueInput
  }

  /**
   * transacoes updateMany
   */
  export type transacoesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update transacoes.
     */
    data: XOR<transacoesUpdateManyMutationInput, transacoesUncheckedUpdateManyInput>
    /**
     * Filter which transacoes to update
     */
    where?: transacoesWhereInput
    /**
     * Limit how many transacoes to update.
     */
    limit?: number
  }

  /**
   * transacoes updateManyAndReturn
   */
  export type transacoesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transacoes
     */
    select?: transacoesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the transacoes
     */
    omit?: transacoesOmit<ExtArgs> | null
    /**
     * The data used to update transacoes.
     */
    data: XOR<transacoesUpdateManyMutationInput, transacoesUncheckedUpdateManyInput>
    /**
     * Filter which transacoes to update
     */
    where?: transacoesWhereInput
    /**
     * Limit how many transacoes to update.
     */
    limit?: number
  }

  /**
   * transacoes upsert
   */
  export type transacoesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transacoes
     */
    select?: transacoesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transacoes
     */
    omit?: transacoesOmit<ExtArgs> | null
    /**
     * The filter to search for the transacoes to update in case it exists.
     */
    where: transacoesWhereUniqueInput
    /**
     * In case the transacoes found by the `where` argument doesn't exist, create a new transacoes with this data.
     */
    create: XOR<transacoesCreateInput, transacoesUncheckedCreateInput>
    /**
     * In case the transacoes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<transacoesUpdateInput, transacoesUncheckedUpdateInput>
  }

  /**
   * transacoes delete
   */
  export type transacoesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transacoes
     */
    select?: transacoesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transacoes
     */
    omit?: transacoesOmit<ExtArgs> | null
    /**
     * Filter which transacoes to delete.
     */
    where: transacoesWhereUniqueInput
  }

  /**
   * transacoes deleteMany
   */
  export type transacoesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transacoes to delete
     */
    where?: transacoesWhereInput
    /**
     * Limit how many transacoes to delete.
     */
    limit?: number
  }

  /**
   * transacoes without action
   */
  export type transacoesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transacoes
     */
    select?: transacoesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transacoes
     */
    omit?: transacoesOmit<ExtArgs> | null
  }


  /**
   * Model usuarios
   */

  export type AggregateUsuarios = {
    _count: UsuariosCountAggregateOutputType | null
    _avg: UsuariosAvgAggregateOutputType | null
    _sum: UsuariosSumAggregateOutputType | null
    _min: UsuariosMinAggregateOutputType | null
    _max: UsuariosMaxAggregateOutputType | null
  }

  export type UsuariosAvgAggregateOutputType = {
    id: number | null
  }

  export type UsuariosSumAggregateOutputType = {
    id: number | null
  }

  export type UsuariosMinAggregateOutputType = {
    id: number | null
    nome: string | null
    email: string | null
    cpf: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsuariosMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    email: string | null
    cpf: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsuariosCountAggregateOutputType = {
    id: number
    nome: number
    email: number
    cpf: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UsuariosAvgAggregateInputType = {
    id?: true
  }

  export type UsuariosSumAggregateInputType = {
    id?: true
  }

  export type UsuariosMinAggregateInputType = {
    id?: true
    nome?: true
    email?: true
    cpf?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsuariosMaxAggregateInputType = {
    id?: true
    nome?: true
    email?: true
    cpf?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsuariosCountAggregateInputType = {
    id?: true
    nome?: true
    email?: true
    cpf?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UsuariosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usuarios to aggregate.
     */
    where?: usuariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: usuariosOrderByWithRelationInput | usuariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usuariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned usuarios
    **/
    _count?: true | UsuariosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuariosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuariosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuariosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuariosMaxAggregateInputType
  }

  export type GetUsuariosAggregateType<T extends UsuariosAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuarios]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuarios[P]>
      : GetScalarType<T[P], AggregateUsuarios[P]>
  }




  export type usuariosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usuariosWhereInput
    orderBy?: usuariosOrderByWithAggregationInput | usuariosOrderByWithAggregationInput[]
    by: UsuariosScalarFieldEnum[] | UsuariosScalarFieldEnum
    having?: usuariosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuariosCountAggregateInputType | true
    _avg?: UsuariosAvgAggregateInputType
    _sum?: UsuariosSumAggregateInputType
    _min?: UsuariosMinAggregateInputType
    _max?: UsuariosMaxAggregateInputType
  }

  export type UsuariosGroupByOutputType = {
    id: number
    nome: string
    email: string
    cpf: string | null
    createdAt: Date
    updatedAt: Date
    _count: UsuariosCountAggregateOutputType | null
    _avg: UsuariosAvgAggregateOutputType | null
    _sum: UsuariosSumAggregateOutputType | null
    _min: UsuariosMinAggregateOutputType | null
    _max: UsuariosMaxAggregateOutputType | null
  }

  type GetUsuariosGroupByPayload<T extends usuariosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuariosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuariosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuariosGroupByOutputType[P]>
            : GetScalarType<T[P], UsuariosGroupByOutputType[P]>
        }
      >
    >


  export type usuariosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    tipo?: boolean
    email?: boolean
    senha?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["usuarios"]>

  export type usuariosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    tipo?: boolean
    email?: boolean
    senha?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["usuarios"]>

  export type usuariosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    tipo?: boolean
    email?: boolean
    senha?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["usuarios"]>

  export type usuariosSelectScalar = {
    id?: boolean
    nome?: boolean
    tipo?: boolean
    email?: boolean
    senha?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type usuariosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nome" | "tipo" | "email" | "senha" | "createdAt" | "updatedAt", ExtArgs["result"]["usuarios"]>

  export type $usuariosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "usuarios"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      tipo: $Enums.enum_usuarios_tipo
      email: string | null
      senha: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["usuarios"]>
    composites: {}
  }

  type usuariosGetPayload<S extends boolean | null | undefined | usuariosDefaultArgs> = $Result.GetResult<Prisma.$usuariosPayload, S>

  type usuariosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usuariosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsuariosCountAggregateInputType | true
    }

  export interface usuariosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['usuarios'], meta: { name: 'usuarios' } }
    /**
     * Find zero or one Usuarios that matches the filter.
     * @param {usuariosFindUniqueArgs} args - Arguments to find a Usuarios
     * @example
     * // Get one Usuarios
     * const usuarios = await prisma.usuarios.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usuariosFindUniqueArgs>(args: SelectSubset<T, usuariosFindUniqueArgs<ExtArgs>>): Prisma__usuariosClient<$Result.GetResult<Prisma.$usuariosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Usuarios that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usuariosFindUniqueOrThrowArgs} args - Arguments to find a Usuarios
     * @example
     * // Get one Usuarios
     * const usuarios = await prisma.usuarios.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usuariosFindUniqueOrThrowArgs>(args: SelectSubset<T, usuariosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usuariosClient<$Result.GetResult<Prisma.$usuariosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosFindFirstArgs} args - Arguments to find a Usuarios
     * @example
     * // Get one Usuarios
     * const usuarios = await prisma.usuarios.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usuariosFindFirstArgs>(args?: SelectSubset<T, usuariosFindFirstArgs<ExtArgs>>): Prisma__usuariosClient<$Result.GetResult<Prisma.$usuariosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Usuarios that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosFindFirstOrThrowArgs} args - Arguments to find a Usuarios
     * @example
     * // Get one Usuarios
     * const usuarios = await prisma.usuarios.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usuariosFindFirstOrThrowArgs>(args?: SelectSubset<T, usuariosFindFirstOrThrowArgs<ExtArgs>>): Prisma__usuariosClient<$Result.GetResult<Prisma.$usuariosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuarios.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuarios.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuariosWithIdOnly = await prisma.usuarios.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usuariosFindManyArgs>(args?: SelectSubset<T, usuariosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usuariosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Usuarios.
     * @param {usuariosCreateArgs} args - Arguments to create a Usuarios.
     * @example
     * // Create one Usuarios
     * const Usuarios = await prisma.usuarios.create({
     *   data: {
     *     // ... data to create a Usuarios
     *   }
     * })
     * 
     */
    create<T extends usuariosCreateArgs>(args: SelectSubset<T, usuariosCreateArgs<ExtArgs>>): Prisma__usuariosClient<$Result.GetResult<Prisma.$usuariosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Usuarios.
     * @param {usuariosCreateManyArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuarios = await prisma.usuarios.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usuariosCreateManyArgs>(args?: SelectSubset<T, usuariosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Usuarios and returns the data saved in the database.
     * @param {usuariosCreateManyAndReturnArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuarios = await prisma.usuarios.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Usuarios and only return the `id`
     * const usuariosWithIdOnly = await prisma.usuarios.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends usuariosCreateManyAndReturnArgs>(args?: SelectSubset<T, usuariosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usuariosPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Usuarios.
     * @param {usuariosDeleteArgs} args - Arguments to delete one Usuarios.
     * @example
     * // Delete one Usuarios
     * const Usuarios = await prisma.usuarios.delete({
     *   where: {
     *     // ... filter to delete one Usuarios
     *   }
     * })
     * 
     */
    delete<T extends usuariosDeleteArgs>(args: SelectSubset<T, usuariosDeleteArgs<ExtArgs>>): Prisma__usuariosClient<$Result.GetResult<Prisma.$usuariosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Usuarios.
     * @param {usuariosUpdateArgs} args - Arguments to update one Usuarios.
     * @example
     * // Update one Usuarios
     * const usuarios = await prisma.usuarios.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usuariosUpdateArgs>(args: SelectSubset<T, usuariosUpdateArgs<ExtArgs>>): Prisma__usuariosClient<$Result.GetResult<Prisma.$usuariosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Usuarios.
     * @param {usuariosDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuarios.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usuariosDeleteManyArgs>(args?: SelectSubset<T, usuariosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuarios = await prisma.usuarios.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usuariosUpdateManyArgs>(args: SelectSubset<T, usuariosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios and returns the data updated in the database.
     * @param {usuariosUpdateManyAndReturnArgs} args - Arguments to update many Usuarios.
     * @example
     * // Update many Usuarios
     * const usuarios = await prisma.usuarios.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Usuarios and only return the `id`
     * const usuariosWithIdOnly = await prisma.usuarios.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends usuariosUpdateManyAndReturnArgs>(args: SelectSubset<T, usuariosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usuariosPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Usuarios.
     * @param {usuariosUpsertArgs} args - Arguments to update or create a Usuarios.
     * @example
     * // Update or create a Usuarios
     * const usuarios = await prisma.usuarios.upsert({
     *   create: {
     *     // ... data to create a Usuarios
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuarios we want to update
     *   }
     * })
     */
    upsert<T extends usuariosUpsertArgs>(args: SelectSubset<T, usuariosUpsertArgs<ExtArgs>>): Prisma__usuariosClient<$Result.GetResult<Prisma.$usuariosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuarios.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends usuariosCountArgs>(
      args?: Subset<T, usuariosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuariosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuariosAggregateArgs>(args: Subset<T, UsuariosAggregateArgs>): Prisma.PrismaPromise<GetUsuariosAggregateType<T>>

    /**
     * Group by Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usuariosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usuariosGroupByArgs['orderBy'] }
        : { orderBy?: usuariosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usuariosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuariosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the usuarios model
   */
  readonly fields: usuariosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for usuarios.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usuariosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the usuarios model
   */
  interface usuariosFieldRefs {
    readonly id: FieldRef<"usuarios", 'Int'>
    readonly nome: FieldRef<"usuarios", 'String'>
    readonly tipo: FieldRef<"usuarios", 'enum_usuarios_tipo'>
    readonly email: FieldRef<"usuarios", 'String'>
    readonly senha: FieldRef<"usuarios", 'String'>
    readonly createdAt: FieldRef<"usuarios", 'DateTime'>
    readonly updatedAt: FieldRef<"usuarios", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * usuarios findUnique
   */
  export type usuariosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuarios
     */
    omit?: usuariosOmit<ExtArgs> | null
    /**
     * Filter, which usuarios to fetch.
     */
    where: usuariosWhereUniqueInput
  }

  /**
   * usuarios findUniqueOrThrow
   */
  export type usuariosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuarios
     */
    omit?: usuariosOmit<ExtArgs> | null
    /**
     * Filter, which usuarios to fetch.
     */
    where: usuariosWhereUniqueInput
  }

  /**
   * usuarios findFirst
   */
  export type usuariosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuarios
     */
    omit?: usuariosOmit<ExtArgs> | null
    /**
     * Filter, which usuarios to fetch.
     */
    where?: usuariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: usuariosOrderByWithRelationInput | usuariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usuarios.
     */
    cursor?: usuariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usuarios.
     */
    distinct?: UsuariosScalarFieldEnum | UsuariosScalarFieldEnum[]
  }

  /**
   * usuarios findFirstOrThrow
   */
  export type usuariosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuarios
     */
    omit?: usuariosOmit<ExtArgs> | null
    /**
     * Filter, which usuarios to fetch.
     */
    where?: usuariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: usuariosOrderByWithRelationInput | usuariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usuarios.
     */
    cursor?: usuariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usuarios.
     */
    distinct?: UsuariosScalarFieldEnum | UsuariosScalarFieldEnum[]
  }

  /**
   * usuarios findMany
   */
  export type usuariosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuarios
     */
    omit?: usuariosOmit<ExtArgs> | null
    /**
     * Filter, which usuarios to fetch.
     */
    where?: usuariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: usuariosOrderByWithRelationInput | usuariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing usuarios.
     */
    cursor?: usuariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    distinct?: UsuariosScalarFieldEnum | UsuariosScalarFieldEnum[]
  }

  /**
   * usuarios create
   */
  export type usuariosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuarios
     */
    omit?: usuariosOmit<ExtArgs> | null
    /**
     * The data needed to create a usuarios.
     */
    data: XOR<usuariosCreateInput, usuariosUncheckedCreateInput>
  }

  /**
   * usuarios createMany
   */
  export type usuariosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many usuarios.
     */
    data: usuariosCreateManyInput | usuariosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * usuarios createManyAndReturn
   */
  export type usuariosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the usuarios
     */
    omit?: usuariosOmit<ExtArgs> | null
    /**
     * The data used to create many usuarios.
     */
    data: usuariosCreateManyInput | usuariosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * usuarios update
   */
  export type usuariosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuarios
     */
    omit?: usuariosOmit<ExtArgs> | null
    /**
     * The data needed to update a usuarios.
     */
    data: XOR<usuariosUpdateInput, usuariosUncheckedUpdateInput>
    /**
     * Choose, which usuarios to update.
     */
    where: usuariosWhereUniqueInput
  }

  /**
   * usuarios updateMany
   */
  export type usuariosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update usuarios.
     */
    data: XOR<usuariosUpdateManyMutationInput, usuariosUncheckedUpdateManyInput>
    /**
     * Filter which usuarios to update
     */
    where?: usuariosWhereInput
    /**
     * Limit how many usuarios to update.
     */
    limit?: number
  }

  /**
   * usuarios updateManyAndReturn
   */
  export type usuariosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the usuarios
     */
    omit?: usuariosOmit<ExtArgs> | null
    /**
     * The data used to update usuarios.
     */
    data: XOR<usuariosUpdateManyMutationInput, usuariosUncheckedUpdateManyInput>
    /**
     * Filter which usuarios to update
     */
    where?: usuariosWhereInput
    /**
     * Limit how many usuarios to update.
     */
    limit?: number
  }

  /**
   * usuarios upsert
   */
  export type usuariosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuarios
     */
    omit?: usuariosOmit<ExtArgs> | null
    /**
     * The filter to search for the usuarios to update in case it exists.
     */
    where: usuariosWhereUniqueInput
    /**
     * In case the usuarios found by the `where` argument doesn't exist, create a new usuarios with this data.
     */
    create: XOR<usuariosCreateInput, usuariosUncheckedCreateInput>
    /**
     * In case the usuarios was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usuariosUpdateInput, usuariosUncheckedUpdateInput>
  }

  /**
   * usuarios delete
   */
  export type usuariosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuarios
     */
    omit?: usuariosOmit<ExtArgs> | null
    /**
     * Filter which usuarios to delete.
     */
    where: usuariosWhereUniqueInput
  }

  /**
   * usuarios deleteMany
   */
  export type usuariosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usuarios to delete
     */
    where?: usuariosWhereInput
    /**
     * Limit how many usuarios to delete.
     */
    limit?: number
  }

  /**
   * usuarios without action
   */
  export type usuariosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuarios
     */
    omit?: usuariosOmit<ExtArgs> | null
  }


  /**
   * Model veiculos
   */

  export type AggregateVeiculos = {
    _count: VeiculosCountAggregateOutputType | null
    _avg: VeiculosAvgAggregateOutputType | null
    _sum: VeiculosSumAggregateOutputType | null
    _min: VeiculosMinAggregateOutputType | null
    _max: VeiculosMaxAggregateOutputType | null
  }

  export type VeiculosAvgAggregateOutputType = {
    id: number | null
    motorista_id: number | null
    ano: number | null
  }

  export type VeiculosSumAggregateOutputType = {
    id: number | null
    motorista_id: number | null
    ano: number | null
  }

  export type VeiculosMinAggregateOutputType = {
    id: number | null
    motorista_id: number | null
    modelo: string | null
    placa: string | null
    ano: number | null
    categoria: $Enums.enum_Veiculos_categoria | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VeiculosMaxAggregateOutputType = {
    id: number | null
    motorista_id: number | null
    modelo: string | null
    placa: string | null
    ano: number | null
    categoria: $Enums.enum_Veiculos_categoria | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VeiculosCountAggregateOutputType = {
    id: number
    motorista_id: number
    modelo: number
    placa: number
    ano: number
    categoria: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VeiculosAvgAggregateInputType = {
    id?: true
    motorista_id?: true
    ano?: true
  }

  export type VeiculosSumAggregateInputType = {
    id?: true
    motorista_id?: true
    ano?: true
  }

  export type VeiculosMinAggregateInputType = {
    id?: true
    motorista_id?: true
    modelo?: true
    placa?: true
    ano?: true
    categoria?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VeiculosMaxAggregateInputType = {
    id?: true
    motorista_id?: true
    modelo?: true
    placa?: true
    ano?: true
    categoria?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VeiculosCountAggregateInputType = {
    id?: true
    motorista_id?: true
    modelo?: true
    placa?: true
    ano?: true
    categoria?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VeiculosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which veiculos to aggregate.
     */
    where?: veiculosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of veiculos to fetch.
     */
    orderBy?: veiculosOrderByWithRelationInput | veiculosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: veiculosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` veiculos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` veiculos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned veiculos
    **/
    _count?: true | VeiculosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VeiculosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VeiculosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VeiculosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VeiculosMaxAggregateInputType
  }

  export type GetVeiculosAggregateType<T extends VeiculosAggregateArgs> = {
        [P in keyof T & keyof AggregateVeiculos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVeiculos[P]>
      : GetScalarType<T[P], AggregateVeiculos[P]>
  }




  export type veiculosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: veiculosWhereInput
    orderBy?: veiculosOrderByWithAggregationInput | veiculosOrderByWithAggregationInput[]
    by: VeiculosScalarFieldEnum[] | VeiculosScalarFieldEnum
    having?: veiculosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VeiculosCountAggregateInputType | true
    _avg?: VeiculosAvgAggregateInputType
    _sum?: VeiculosSumAggregateInputType
    _min?: VeiculosMinAggregateInputType
    _max?: VeiculosMaxAggregateInputType
  }

  export type VeiculosGroupByOutputType = {
    id: number
    motorista_id: number
    modelo: string
    placa: string
    ano: number
    categoria: $Enums.enum_Veiculos_categoria | null
    createdAt: Date
    updatedAt: Date
    _count: VeiculosCountAggregateOutputType | null
    _avg: VeiculosAvgAggregateOutputType | null
    _sum: VeiculosSumAggregateOutputType | null
    _min: VeiculosMinAggregateOutputType | null
    _max: VeiculosMaxAggregateOutputType | null
  }

  type GetVeiculosGroupByPayload<T extends veiculosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VeiculosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VeiculosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VeiculosGroupByOutputType[P]>
            : GetScalarType<T[P], VeiculosGroupByOutputType[P]>
        }
      >
    >


  export type veiculosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    motorista_id?: boolean
    modelo?: boolean
    placa?: boolean
    ano?: boolean
    categoria?: boolean
    status?: boolean
    observacoes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["veiculos"]>

  export type veiculosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    motorista_id?: boolean
    modelo?: boolean
    placa?: boolean
    ano?: boolean
    categoria?: boolean
    status?: boolean
    observacoes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["veiculos"]>

  export type veiculosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    motorista_id?: boolean
    modelo?: boolean
    placa?: boolean
    ano?: boolean
    categoria?: boolean
    status?: boolean
    observacoes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["veiculos"]>

  export type veiculosSelectScalar = {
    id?: boolean
    motorista_id?: boolean
    modelo?: boolean
    placa?: boolean
    ano?: boolean
    categoria?: boolean
    status?: boolean
    observacoes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type veiculosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "motorista_id" | "modelo" | "placa" | "ano" | "categoria" | "status" | "observacoes" | "createdAt" | "updatedAt", ExtArgs["result"]["veiculos"]>

  export type $veiculosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "veiculos"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      motorista_id: number
      modelo: string
      placa: string
      ano: number
      categoria: $Enums.enum_veiculos_categoria
      status: $Enums.enum_veiculos_status | null
      observacoes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["veiculos"]>
    composites: {}
  }

  type veiculosGetPayload<S extends boolean | null | undefined | veiculosDefaultArgs> = $Result.GetResult<Prisma.$veiculosPayload, S>

  type veiculosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<veiculosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VeiculosCountAggregateInputType | true
    }

  export interface veiculosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['veiculos'], meta: { name: 'veiculos' } }
    /**
     * Find zero or one Veiculos that matches the filter.
     * @param {veiculosFindUniqueArgs} args - Arguments to find a Veiculos
     * @example
     * // Get one Veiculos
     * const veiculos = await prisma.veiculos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends veiculosFindUniqueArgs>(args: SelectSubset<T, veiculosFindUniqueArgs<ExtArgs>>): Prisma__veiculosClient<$Result.GetResult<Prisma.$veiculosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Veiculos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {veiculosFindUniqueOrThrowArgs} args - Arguments to find a Veiculos
     * @example
     * // Get one Veiculos
     * const veiculos = await prisma.veiculos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends veiculosFindUniqueOrThrowArgs>(args: SelectSubset<T, veiculosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__veiculosClient<$Result.GetResult<Prisma.$veiculosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Veiculos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {veiculosFindFirstArgs} args - Arguments to find a Veiculos
     * @example
     * // Get one Veiculos
     * const veiculos = await prisma.veiculos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends veiculosFindFirstArgs>(args?: SelectSubset<T, veiculosFindFirstArgs<ExtArgs>>): Prisma__veiculosClient<$Result.GetResult<Prisma.$veiculosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Veiculos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {veiculosFindFirstOrThrowArgs} args - Arguments to find a Veiculos
     * @example
     * // Get one Veiculos
     * const veiculos = await prisma.veiculos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends veiculosFindFirstOrThrowArgs>(args?: SelectSubset<T, veiculosFindFirstOrThrowArgs<ExtArgs>>): Prisma__veiculosClient<$Result.GetResult<Prisma.$veiculosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Veiculos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {veiculosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Veiculos
     * const veiculos = await prisma.veiculos.findMany()
     * 
     * // Get first 10 Veiculos
     * const veiculos = await prisma.veiculos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const veiculosWithIdOnly = await prisma.veiculos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends veiculosFindManyArgs>(args?: SelectSubset<T, veiculosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$veiculosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Veiculos.
     * @param {veiculosCreateArgs} args - Arguments to create a Veiculos.
     * @example
     * // Create one Veiculos
     * const Veiculos = await prisma.veiculos.create({
     *   data: {
     *     // ... data to create a Veiculos
     *   }
     * })
     * 
     */
    create<T extends veiculosCreateArgs>(args: SelectSubset<T, veiculosCreateArgs<ExtArgs>>): Prisma__veiculosClient<$Result.GetResult<Prisma.$veiculosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Veiculos.
     * @param {veiculosCreateManyArgs} args - Arguments to create many Veiculos.
     * @example
     * // Create many Veiculos
     * const veiculos = await prisma.veiculos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends veiculosCreateManyArgs>(args?: SelectSubset<T, veiculosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Veiculos and returns the data saved in the database.
     * @param {veiculosCreateManyAndReturnArgs} args - Arguments to create many Veiculos.
     * @example
     * // Create many Veiculos
     * const veiculos = await prisma.veiculos.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Veiculos and only return the `id`
     * const veiculosWithIdOnly = await prisma.veiculos.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends veiculosCreateManyAndReturnArgs>(args?: SelectSubset<T, veiculosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$veiculosPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Veiculos.
     * @param {veiculosDeleteArgs} args - Arguments to delete one Veiculos.
     * @example
     * // Delete one Veiculos
     * const Veiculos = await prisma.veiculos.delete({
     *   where: {
     *     // ... filter to delete one Veiculos
     *   }
     * })
     * 
     */
    delete<T extends veiculosDeleteArgs>(args: SelectSubset<T, veiculosDeleteArgs<ExtArgs>>): Prisma__veiculosClient<$Result.GetResult<Prisma.$veiculosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Veiculos.
     * @param {veiculosUpdateArgs} args - Arguments to update one Veiculos.
     * @example
     * // Update one Veiculos
     * const veiculos = await prisma.veiculos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends veiculosUpdateArgs>(args: SelectSubset<T, veiculosUpdateArgs<ExtArgs>>): Prisma__veiculosClient<$Result.GetResult<Prisma.$veiculosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Veiculos.
     * @param {veiculosDeleteManyArgs} args - Arguments to filter Veiculos to delete.
     * @example
     * // Delete a few Veiculos
     * const { count } = await prisma.veiculos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends veiculosDeleteManyArgs>(args?: SelectSubset<T, veiculosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Veiculos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {veiculosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Veiculos
     * const veiculos = await prisma.veiculos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends veiculosUpdateManyArgs>(args: SelectSubset<T, veiculosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Veiculos and returns the data updated in the database.
     * @param {veiculosUpdateManyAndReturnArgs} args - Arguments to update many Veiculos.
     * @example
     * // Update many Veiculos
     * const veiculos = await prisma.veiculos.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Veiculos and only return the `id`
     * const veiculosWithIdOnly = await prisma.veiculos.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends veiculosUpdateManyAndReturnArgs>(args: SelectSubset<T, veiculosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$veiculosPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Veiculos.
     * @param {veiculosUpsertArgs} args - Arguments to update or create a Veiculos.
     * @example
     * // Update or create a Veiculos
     * const veiculos = await prisma.veiculos.upsert({
     *   create: {
     *     // ... data to create a Veiculos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Veiculos we want to update
     *   }
     * })
     */
    upsert<T extends veiculosUpsertArgs>(args: SelectSubset<T, veiculosUpsertArgs<ExtArgs>>): Prisma__veiculosClient<$Result.GetResult<Prisma.$veiculosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Veiculos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {veiculosCountArgs} args - Arguments to filter Veiculos to count.
     * @example
     * // Count the number of Veiculos
     * const count = await prisma.veiculos.count({
     *   where: {
     *     // ... the filter for the Veiculos we want to count
     *   }
     * })
    **/
    count<T extends veiculosCountArgs>(
      args?: Subset<T, veiculosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VeiculosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Veiculos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VeiculosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VeiculosAggregateArgs>(args: Subset<T, VeiculosAggregateArgs>): Prisma.PrismaPromise<GetVeiculosAggregateType<T>>

    /**
     * Group by Veiculos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {veiculosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends veiculosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: veiculosGroupByArgs['orderBy'] }
        : { orderBy?: veiculosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, veiculosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVeiculosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the veiculos model
   */
  readonly fields: veiculosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for veiculos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__veiculosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the veiculos model
   */
  interface veiculosFieldRefs {
    readonly id: FieldRef<"veiculos", 'Int'>
    readonly motorista_id: FieldRef<"veiculos", 'Int'>
    readonly modelo: FieldRef<"veiculos", 'String'>
    readonly placa: FieldRef<"veiculos", 'String'>
    readonly ano: FieldRef<"veiculos", 'Int'>
    readonly categoria: FieldRef<"veiculos", 'enum_veiculos_categoria'>
    readonly status: FieldRef<"veiculos", 'enum_veiculos_status'>
    readonly observacoes: FieldRef<"veiculos", 'String'>
    readonly createdAt: FieldRef<"veiculos", 'DateTime'>
    readonly updatedAt: FieldRef<"veiculos", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * veiculos findUnique
   */
  export type veiculosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the veiculos
     */
    select?: veiculosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the veiculos
     */
    omit?: veiculosOmit<ExtArgs> | null
    /**
     * Filter, which veiculos to fetch.
     */
    where: veiculosWhereUniqueInput
  }

  /**
   * veiculos findUniqueOrThrow
   */
  export type veiculosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the veiculos
     */
    select?: veiculosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the veiculos
     */
    omit?: veiculosOmit<ExtArgs> | null
    /**
     * Filter, which veiculos to fetch.
     */
    where: veiculosWhereUniqueInput
  }

  /**
   * veiculos findFirst
   */
  export type veiculosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the veiculos
     */
    select?: veiculosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the veiculos
     */
    omit?: veiculosOmit<ExtArgs> | null
    /**
     * Filter, which veiculos to fetch.
     */
    where?: veiculosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of veiculos to fetch.
     */
    orderBy?: veiculosOrderByWithRelationInput | veiculosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for veiculos.
     */
    cursor?: veiculosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` veiculos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` veiculos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of veiculos.
     */
    distinct?: VeiculosScalarFieldEnum | VeiculosScalarFieldEnum[]
  }

  /**
   * veiculos findFirstOrThrow
   */
  export type veiculosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the veiculos
     */
    select?: veiculosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the veiculos
     */
    omit?: veiculosOmit<ExtArgs> | null
    /**
     * Filter, which veiculos to fetch.
     */
    where?: veiculosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of veiculos to fetch.
     */
    orderBy?: veiculosOrderByWithRelationInput | veiculosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for veiculos.
     */
    cursor?: veiculosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` veiculos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` veiculos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of veiculos.
     */
    distinct?: VeiculosScalarFieldEnum | VeiculosScalarFieldEnum[]
  }

  /**
   * veiculos findMany
   */
  export type veiculosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the veiculos
     */
    select?: veiculosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the veiculos
     */
    omit?: veiculosOmit<ExtArgs> | null
    /**
     * Filter, which veiculos to fetch.
     */
    where?: veiculosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of veiculos to fetch.
     */
    orderBy?: veiculosOrderByWithRelationInput | veiculosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing veiculos.
     */
    cursor?: veiculosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` veiculos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` veiculos.
     */
    skip?: number
    distinct?: VeiculosScalarFieldEnum | VeiculosScalarFieldEnum[]
  }

  /**
   * veiculos create
   */
  export type veiculosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the veiculos
     */
    select?: veiculosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the veiculos
     */
    omit?: veiculosOmit<ExtArgs> | null
    /**
     * The data needed to create a veiculos.
     */
    data: XOR<veiculosCreateInput, veiculosUncheckedCreateInput>
  }

  /**
   * veiculos createMany
   */
  export type veiculosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many veiculos.
     */
    data: veiculosCreateManyInput | veiculosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * veiculos createManyAndReturn
   */
  export type veiculosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the veiculos
     */
    select?: veiculosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the veiculos
     */
    omit?: veiculosOmit<ExtArgs> | null
    /**
     * The data used to create many veiculos.
     */
    data: veiculosCreateManyInput | veiculosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * veiculos update
   */
  export type veiculosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the veiculos
     */
    select?: veiculosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the veiculos
     */
    omit?: veiculosOmit<ExtArgs> | null
    /**
     * The data needed to update a veiculos.
     */
    data: XOR<veiculosUpdateInput, veiculosUncheckedUpdateInput>
    /**
     * Choose, which veiculos to update.
     */
    where: veiculosWhereUniqueInput
  }

  /**
   * veiculos updateMany
   */
  export type veiculosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update veiculos.
     */
    data: XOR<veiculosUpdateManyMutationInput, veiculosUncheckedUpdateManyInput>
    /**
     * Filter which veiculos to update
     */
    where?: veiculosWhereInput
    /**
     * Limit how many veiculos to update.
     */
    limit?: number
  }

  /**
   * veiculos updateManyAndReturn
   */
  export type veiculosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the veiculos
     */
    select?: veiculosSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the veiculos
     */
    omit?: veiculosOmit<ExtArgs> | null
    /**
     * The data used to update veiculos.
     */
    data: XOR<veiculosUpdateManyMutationInput, veiculosUncheckedUpdateManyInput>
    /**
     * Filter which veiculos to update
     */
    where?: veiculosWhereInput
    /**
     * Limit how many veiculos to update.
     */
    limit?: number
  }

  /**
   * veiculos upsert
   */
  export type veiculosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the veiculos
     */
    select?: veiculosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the veiculos
     */
    omit?: veiculosOmit<ExtArgs> | null
    /**
     * The filter to search for the veiculos to update in case it exists.
     */
    where: veiculosWhereUniqueInput
    /**
     * In case the veiculos found by the `where` argument doesn't exist, create a new veiculos with this data.
     */
    create: XOR<veiculosCreateInput, veiculosUncheckedCreateInput>
    /**
     * In case the veiculos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<veiculosUpdateInput, veiculosUncheckedUpdateInput>
  }

  /**
   * veiculos delete
   */
  export type veiculosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the veiculos
     */
    select?: veiculosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the veiculos
     */
    omit?: veiculosOmit<ExtArgs> | null
    /**
     * Filter which veiculos to delete.
     */
    where: veiculosWhereUniqueInput
  }

  /**
   * veiculos deleteMany
   */
  export type veiculosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which veiculos to delete
     */
    where?: veiculosWhereInput
    /**
     * Limit how many veiculos to delete.
     */
    limit?: number
  }

  /**
   * veiculos without action
   */
  export type veiculosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the veiculos
     */
    select?: veiculosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the veiculos
     */
    omit?: veiculosOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const BairroPrioridadesScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    cidade: 'cidade',
    estado: 'estado',
    ativo: 'ativo',
    tipo_prioridade: 'tipo_prioridade',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BairroPrioridadesScalarFieldEnum = (typeof BairroPrioridadesScalarFieldEnum)[keyof typeof BairroPrioridadesScalarFieldEnum]


  export const CarteirasScalarFieldEnum: {
    id: 'id',
    usuarioId: 'usuarioId',
    saldo: 'saldo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CarteirasScalarFieldEnum = (typeof CarteirasScalarFieldEnum)[keyof typeof CarteirasScalarFieldEnum]


  export const CodigoIndicacaosScalarFieldEnum: {
    id: 'id',
    codigo: 'codigo',
    usuarioId: 'usuarioId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CodigoIndicacaosScalarFieldEnum = (typeof CodigoIndicacaosScalarFieldEnum)[keyof typeof CodigoIndicacaosScalarFieldEnum]


  export const CorridaAgendadasScalarFieldEnum: {
    id: 'id',
    passageiroCpf: 'passageiroCpf',
    motoristaCpf: 'motoristaCpf',
    origem: 'origem',
    destino: 'destino',
    dataHoraAgendada: 'dataHoraAgendada',
    status: 'status',
    tipo: 'tipo',
    valor: 'valor',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CorridaAgendadasScalarFieldEnum = (typeof CorridaAgendadasScalarFieldEnum)[keyof typeof CorridaAgendadasScalarFieldEnum]


  export const CorridasScalarFieldEnum: {
    id: 'id',
    origem: 'origem',
    destino: 'destino',
    status: 'status',
    valor: 'valor',
    tipo: 'tipo',
    horarioAgendado: 'horarioAgendado',
    usuarioId: 'usuarioId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CorridasScalarFieldEnum = (typeof CorridasScalarFieldEnum)[keyof typeof CorridasScalarFieldEnum]


  export const DenunciaScalarFieldEnum: {
    id: 'id',
    autor_id: 'autor_id',
    alvo_id: 'alvo_id',
    tipo_alvo: 'tipo_alvo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DenunciaScalarFieldEnum = (typeof DenunciaScalarFieldEnum)[keyof typeof DenunciaScalarFieldEnum]


  export const DocumentosScalarFieldEnum: {
    id: 'id',
    usuario_id: 'usuario_id',
    tipo_documento: 'tipo_documento',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DocumentosScalarFieldEnum = (typeof DocumentosScalarFieldEnum)[keyof typeof DocumentosScalarFieldEnum]


  export const EmailEnviadosScalarFieldEnum: {
    id: 'id',
    usuario_id: 'usuario_id',
    email: 'email',
    tipo: 'tipo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmailEnviadosScalarFieldEnum = (typeof EmailEnviadosScalarFieldEnum)[keyof typeof EmailEnviadosScalarFieldEnum]


  export const HistoricoIndicacaosScalarFieldEnum: {
    id: 'id',
    indicador_id: 'indicador_id',
    indicado_id: 'indicado_id',
    tipo: 'tipo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HistoricoIndicacaosScalarFieldEnum = (typeof HistoricoIndicacaosScalarFieldEnum)[keyof typeof HistoricoIndicacaosScalarFieldEnum]


  export const HistoricoSelfiesScalarFieldEnum: {
    id: 'id',
    usuario_id: 'usuario_id',
    tipo: 'tipo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HistoricoSelfiesScalarFieldEnum = (typeof HistoricoSelfiesScalarFieldEnum)[keyof typeof HistoricoSelfiesScalarFieldEnum]


  export const IdentidadesScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IdentidadesScalarFieldEnum = (typeof IdentidadesScalarFieldEnum)[keyof typeof IdentidadesScalarFieldEnum]


  export const IndicacaosScalarFieldEnum: {
    id: 'id',
    indicanteId: 'indicanteId',
    indicadoId: 'indicadoId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IndicacaosScalarFieldEnum = (typeof IndicacaosScalarFieldEnum)[keyof typeof IndicacaosScalarFieldEnum]


  export const LogAcessosScalarFieldEnum: {
    id: 'id',
    usuario_id: 'usuario_id',
    tipo_usuario: 'tipo_usuario',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LogAcessosScalarFieldEnum = (typeof LogAcessosScalarFieldEnum)[keyof typeof LogAcessosScalarFieldEnum]


  export const MensagemSuportesScalarFieldEnum: {
    id: 'id',
    usuario_id: 'usuario_id',
    tipo_usuario: 'tipo_usuario',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MensagemSuportesScalarFieldEnum = (typeof MensagemSuportesScalarFieldEnum)[keyof typeof MensagemSuportesScalarFieldEnum]


  export const RecompensasScalarFieldEnum: {
    id: 'id',
    usuarioId: 'usuarioId',
    descricao: 'descricao',
    valor: 'valor',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RecompensasScalarFieldEnum = (typeof RecompensasScalarFieldEnum)[keyof typeof RecompensasScalarFieldEnum]


  export const SaquesScalarFieldEnum: {
    id: 'id',
    usuarioId: 'usuarioId',
    valor: 'valor',
    status: 'status',
    tipo: 'tipo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SaquesScalarFieldEnum = (typeof SaquesScalarFieldEnum)[keyof typeof SaquesScalarFieldEnum]


  export const TransacaosScalarFieldEnum: {
    id: 'id',
    usuario_id: 'usuario_id',
    tipo: 'tipo',
    valor: 'valor',
    data: 'data',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransacaosScalarFieldEnum = (typeof TransacaosScalarFieldEnum)[keyof typeof TransacaosScalarFieldEnum]


  export const UsuariosScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    email: 'email',
    cpf: 'cpf',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UsuariosScalarFieldEnum = (typeof UsuariosScalarFieldEnum)[keyof typeof UsuariosScalarFieldEnum]


  export const VeiculosScalarFieldEnum: {
    id: 'id',
    motorista_id: 'motorista_id',
    modelo: 'modelo',
    placa: 'placa',
    ano: 'ano',
    categoria: 'categoria',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VeiculosScalarFieldEnum = (typeof VeiculosScalarFieldEnum)[keyof typeof VeiculosScalarFieldEnum]


  export const Agenda_corridasScalarFieldEnum: {
    id: 'id',
    passageiro_id: 'passageiro_id',
    categoria: 'categoria',
    endereco_origem: 'endereco_origem',
    endereco_destino: 'endereco_destino',
    data_hora: 'data_hora',
    status: 'status',
    motorista_id: 'motorista_id',
    valor_previsto: 'valor_previsto',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Agenda_corridasScalarFieldEnum = (typeof Agenda_corridasScalarFieldEnum)[keyof typeof Agenda_corridasScalarFieldEnum]


  export const AvaliacoesScalarFieldEnum: {
    id: 'id',
    avaliador_id: 'avaliador_id',
    avaliado_id: 'avaliado_id',
    tipo: 'tipo',
    nota: 'nota',
    comentario: 'comentario',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AvaliacoesScalarFieldEnum = (typeof AvaliacoesScalarFieldEnum)[keyof typeof AvaliacoesScalarFieldEnum]


  export const Bairros_prioridadeScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    cidade: 'cidade',
    estado: 'estado',
    ativo: 'ativo',
    tipo_prioridade: 'tipo_prioridade',
    observacoes: 'observacoes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Bairros_prioridadeScalarFieldEnum = (typeof Bairros_prioridadeScalarFieldEnum)[keyof typeof Bairros_prioridadeScalarFieldEnum]


  export const CarteirasScalarFieldEnum: {
    id: 'id',
    usuario_id: 'usuario_id',
    tipo: 'tipo',
    saldo: 'saldo',
    ultima_atualizacao: 'ultima_atualizacao',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CarteirasScalarFieldEnum = (typeof CarteirasScalarFieldEnum)[keyof typeof CarteirasScalarFieldEnum]


  export const CorridasScalarFieldEnum: {
    id: 'id',
    id_motorista: 'id_motorista',
    id_passageiro: 'id_passageiro',
    origem: 'origem',
    destino: 'destino',
    status: 'status',
    distancia_km: 'distancia_km',
    valor_total: 'valor_total',
    forma_pagamento: 'forma_pagamento',
    data_hora: 'data_hora',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CorridasScalarFieldEnum = (typeof CorridasScalarFieldEnum)[keyof typeof CorridasScalarFieldEnum]


  export const DenunciasScalarFieldEnum: {
    id: 'id',
    autor_id: 'autor_id',
    alvo_id: 'alvo_id',
    tipo_alvo: 'tipo_alvo',
    corrida_id: 'corrida_id',
    motivo: 'motivo',
    descricao: 'descricao',
    status: 'status',
    data_denuncia: 'data_denuncia',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DenunciasScalarFieldEnum = (typeof DenunciasScalarFieldEnum)[keyof typeof DenunciasScalarFieldEnum]


  export const DocumentosScalarFieldEnum: {
    id: 'id',
    usuario_id: 'usuario_id',
    tipo_documento: 'tipo_documento',
    arquivo_url: 'arquivo_url',
    status: 'status',
    motivo_rejeicao: 'motivo_rejeicao',
    data_envio: 'data_envio',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DocumentosScalarFieldEnum = (typeof DocumentosScalarFieldEnum)[keyof typeof DocumentosScalarFieldEnum]


  export const Emails_enviadosScalarFieldEnum: {
    id: 'id',
    usuario_id: 'usuario_id',
    email: 'email',
    tipo: 'tipo',
    titulo: 'titulo',
    conteudo: 'conteudo',
    status_envio: 'status_envio',
    data_envio: 'data_envio',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Emails_enviadosScalarFieldEnum = (typeof Emails_enviadosScalarFieldEnum)[keyof typeof Emails_enviadosScalarFieldEnum]


  export const Historico_indicacoesScalarFieldEnum: {
    id: 'id',
    indicador_id: 'indicador_id',
    indicado_id: 'indicado_id',
    tipo: 'tipo',
    data_vinculo: 'data_vinculo',
    codigo_utilizado: 'codigo_utilizado',
    ativo: 'ativo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Historico_indicacoesScalarFieldEnum = (typeof Historico_indicacoesScalarFieldEnum)[keyof typeof Historico_indicacoesScalarFieldEnum]


  export const Historico_selfiesScalarFieldEnum: {
    id: 'id',
    usuario_id: 'usuario_id',
    tipo: 'tipo',
    imagem_url: 'imagem_url',
    resultado: 'resultado',
    motivo_falha: 'motivo_falha',
    data_envio: 'data_envio',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Historico_selfiesScalarFieldEnum = (typeof Historico_selfiesScalarFieldEnum)[keyof typeof Historico_selfiesScalarFieldEnum]


  export const Logs_acessoScalarFieldEnum: {
    id: 'id',
    usuario_id: 'usuario_id',
    tipo_usuario: 'tipo_usuario',
    acao: 'acao',
    descricao: 'descricao',
    ip: 'ip',
    dispositivo: 'dispositivo',
    data: 'data',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Logs_acessoScalarFieldEnum = (typeof Logs_acessoScalarFieldEnum)[keyof typeof Logs_acessoScalarFieldEnum]


  export const Mensagens_suporteScalarFieldEnum: {
    id: 'id',
    usuario_id: 'usuario_id',
    tipo_usuario: 'tipo_usuario',
    mensagem: 'mensagem',
    resposta_sistema: 'resposta_sistema',
    status: 'status',
    data_envio: 'data_envio',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Mensagens_suporteScalarFieldEnum = (typeof Mensagens_suporteScalarFieldEnum)[keyof typeof Mensagens_suporteScalarFieldEnum]


  export const Pagamentos_pessoaisScalarFieldEnum: {
    id: 'id',
    motorista_id: 'motorista_id',
    passageiro_id: 'passageiro_id',
    valor: 'valor',
    valor_maximo: 'valor_maximo',
    aceito_pelo_app: 'aceito_pelo_app',
    data_corrida: 'data_corrida',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Pagamentos_pessoaisScalarFieldEnum = (typeof Pagamentos_pessoaisScalarFieldEnum)[keyof typeof Pagamentos_pessoaisScalarFieldEnum]


  export const ParadasScalarFieldEnum: {
    id: 'id',
    corrida_id: 'corrida_id',
    ordem: 'ordem',
    endereco: 'endereco',
    latitude: 'latitude',
    longitude: 'longitude',
    tempo_espera: 'tempo_espera',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ParadasScalarFieldEnum = (typeof ParadasScalarFieldEnum)[keyof typeof ParadasScalarFieldEnum]


  export const RecompensasScalarFieldEnum: {
    id: 'id',
    indicador_id: 'indicador_id',
    indicado_id: 'indicado_id',
    tipo: 'tipo',
    valor: 'valor',
    status: 'status',
    data_gerada: 'data_gerada',
    referencia_corrida: 'referencia_corrida',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RecompensasScalarFieldEnum = (typeof RecompensasScalarFieldEnum)[keyof typeof RecompensasScalarFieldEnum]


  export const SaquesScalarFieldEnum: {
    id: 'id',
    usuario_id: 'usuario_id',
    valor: 'valor',
    status: 'status',
    tipo: 'tipo',
    pix: 'pix',
    data_pedido: 'data_pedido',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SaquesScalarFieldEnum = (typeof SaquesScalarFieldEnum)[keyof typeof SaquesScalarFieldEnum]


  export const TransacoesScalarFieldEnum: {
    id: 'id',
    usuario_id: 'usuario_id',
    tipo: 'tipo',
    origem: 'origem',
    descricao: 'descricao',
    valor: 'valor',
    data_transacao: 'data_transacao',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransacoesScalarFieldEnum = (typeof TransacoesScalarFieldEnum)[keyof typeof TransacoesScalarFieldEnum]


  export const UsuariosScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    tipo: 'tipo',
    email: 'email',
    senha: 'senha',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UsuariosScalarFieldEnum = (typeof UsuariosScalarFieldEnum)[keyof typeof UsuariosScalarFieldEnum]


  export const VeiculosScalarFieldEnum: {
    id: 'id',
    motorista_id: 'motorista_id',
    modelo: 'modelo',
    placa: 'placa',
    ano: 'ano',
    categoria: 'categoria',
    status: 'status',
    observacoes: 'observacoes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VeiculosScalarFieldEnum = (typeof VeiculosScalarFieldEnum)[keyof typeof VeiculosScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'enum_BairroPrioridades_tipo_prioridade'
   */
  export type Enumenum_BairroPrioridades_tipo_prioridadeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_BairroPrioridades_tipo_prioridade'>
    


  /**
   * Reference to a field of type 'enum_BairroPrioridades_tipo_prioridade[]'
   */
  export type ListEnumenum_BairroPrioridades_tipo_prioridadeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_BairroPrioridades_tipo_prioridade[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'enum_Corridas_tipo'
   */
  export type Enumenum_Corridas_tipoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_Corridas_tipo'>
    


  /**
   * Reference to a field of type 'enum_Corridas_tipo[]'
   */
  export type ListEnumenum_Corridas_tipoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_Corridas_tipo[]'>
    


  /**
   * Reference to a field of type 'enum_Denuncia_tipo_alvo'
   */
  export type Enumenum_Denuncia_tipo_alvoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_Denuncia_tipo_alvo'>
    


  /**
   * Reference to a field of type 'enum_Denuncia_tipo_alvo[]'
   */
  export type ListEnumenum_Denuncia_tipo_alvoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_Denuncia_tipo_alvo[]'>
    


  /**
   * Reference to a field of type 'enum_Documentos_tipo_documento'
   */
  export type Enumenum_Documentos_tipo_documentoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_Documentos_tipo_documento'>
    


  /**
   * Reference to a field of type 'enum_Documentos_tipo_documento[]'
   */
  export type ListEnumenum_Documentos_tipo_documentoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_Documentos_tipo_documento[]'>
    


  /**
   * Reference to a field of type 'enum_EmailEnviados_tipo'
   */
  export type Enumenum_EmailEnviados_tipoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_EmailEnviados_tipo'>
    


  /**
   * Reference to a field of type 'enum_EmailEnviados_tipo[]'
   */
  export type ListEnumenum_EmailEnviados_tipoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_EmailEnviados_tipo[]'>
    


  /**
   * Reference to a field of type 'enum_HistoricoIndicacaos_tipo'
   */
  export type Enumenum_HistoricoIndicacaos_tipoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_HistoricoIndicacaos_tipo'>
    


  /**
   * Reference to a field of type 'enum_HistoricoIndicacaos_tipo[]'
   */
  export type ListEnumenum_HistoricoIndicacaos_tipoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_HistoricoIndicacaos_tipo[]'>
    


  /**
   * Reference to a field of type 'enum_HistoricoSelfies_tipo'
   */
  export type Enumenum_HistoricoSelfies_tipoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_HistoricoSelfies_tipo'>
    


  /**
   * Reference to a field of type 'enum_HistoricoSelfies_tipo[]'
   */
  export type ListEnumenum_HistoricoSelfies_tipoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_HistoricoSelfies_tipo[]'>
    


  /**
   * Reference to a field of type 'enum_LogAcessos_tipo_usuario'
   */
  export type Enumenum_LogAcessos_tipo_usuarioFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_LogAcessos_tipo_usuario'>
    


  /**
   * Reference to a field of type 'enum_LogAcessos_tipo_usuario[]'
   */
  export type ListEnumenum_LogAcessos_tipo_usuarioFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_LogAcessos_tipo_usuario[]'>
    


  /**
   * Reference to a field of type 'enum_MensagemSuportes_tipo_usuario'
   */
  export type Enumenum_MensagemSuportes_tipo_usuarioFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_MensagemSuportes_tipo_usuario'>
    


  /**
   * Reference to a field of type 'enum_MensagemSuportes_tipo_usuario[]'
   */
  export type ListEnumenum_MensagemSuportes_tipo_usuarioFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_MensagemSuportes_tipo_usuario[]'>
    


  /**
   * Reference to a field of type 'enum_Recompensas_status'
   */
  export type Enumenum_Recompensas_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_Recompensas_status'>
    


  /**
   * Reference to a field of type 'enum_Recompensas_status[]'
   */
  export type ListEnumenum_Recompensas_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_Recompensas_status[]'>
    


  /**
   * Reference to a field of type 'enum_Saques_status'
   */
  export type Enumenum_Saques_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_Saques_status'>
    


  /**
   * Reference to a field of type 'enum_Saques_status[]'
   */
  export type ListEnumenum_Saques_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_Saques_status[]'>
    


  /**
   * Reference to a field of type 'enum_Saques_tipo'
   */
  export type Enumenum_Saques_tipoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_Saques_tipo'>
    


  /**
   * Reference to a field of type 'enum_Saques_tipo[]'
   */
  export type ListEnumenum_Saques_tipoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_Saques_tipo[]'>
    


  /**
   * Reference to a field of type 'enum_Transacaos_tipo'
   */
  export type Enumenum_Transacaos_tipoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_Transacaos_tipo'>
    


  /**
   * Reference to a field of type 'enum_Transacaos_tipo[]'
   */
  export type ListEnumenum_Transacaos_tipoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_Transacaos_tipo[]'>
    


  /**
   * Reference to a field of type 'enum_Veiculos_categoria'
   */
  export type Enumenum_Veiculos_categoriaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_Veiculos_categoria'>
    


  /**
   * Reference to a field of type 'enum_Veiculos_categoria[]'
   */
  export type ListEnumenum_Veiculos_categoriaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_Veiculos_categoria[]'>
    


  /**
   * Reference to a field of type 'enum_agenda_corridas_categoria'
   */
  export type Enumenum_agenda_corridas_categoriaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_agenda_corridas_categoria'>
    


  /**
   * Reference to a field of type 'enum_agenda_corridas_categoria[]'
   */
  export type ListEnumenum_agenda_corridas_categoriaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_agenda_corridas_categoria[]'>
    


  /**
   * Reference to a field of type 'enum_agenda_corridas_status'
   */
  export type Enumenum_agenda_corridas_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_agenda_corridas_status'>
    


  /**
   * Reference to a field of type 'enum_agenda_corridas_status[]'
   */
  export type ListEnumenum_agenda_corridas_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_agenda_corridas_status[]'>
    


  /**
   * Reference to a field of type 'enum_avaliacoes_tipo'
   */
  export type Enumenum_avaliacoes_tipoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_avaliacoes_tipo'>
    


  /**
   * Reference to a field of type 'enum_avaliacoes_tipo[]'
   */
  export type ListEnumenum_avaliacoes_tipoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_avaliacoes_tipo[]'>
    


  /**
   * Reference to a field of type 'enum_bairros_prioridade_tipo_prioridade'
   */
  export type Enumenum_bairros_prioridade_tipo_prioridadeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_bairros_prioridade_tipo_prioridade'>
    


  /**
   * Reference to a field of type 'enum_bairros_prioridade_tipo_prioridade[]'
   */
  export type ListEnumenum_bairros_prioridade_tipo_prioridadeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_bairros_prioridade_tipo_prioridade[]'>
    


  /**
   * Reference to a field of type 'enum_carteiras_tipo'
   */
  export type Enumenum_carteiras_tipoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_carteiras_tipo'>
    


  /**
   * Reference to a field of type 'enum_carteiras_tipo[]'
   */
  export type ListEnumenum_carteiras_tipoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_carteiras_tipo[]'>
    


  /**
   * Reference to a field of type 'enum_corridas_status'
   */
  export type Enumenum_corridas_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_corridas_status'>
    


  /**
   * Reference to a field of type 'enum_corridas_status[]'
   */
  export type ListEnumenum_corridas_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_corridas_status[]'>
    


  /**
   * Reference to a field of type 'enum_corridas_forma_pagamento'
   */
  export type Enumenum_corridas_forma_pagamentoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_corridas_forma_pagamento'>
    


  /**
   * Reference to a field of type 'enum_corridas_forma_pagamento[]'
   */
  export type ListEnumenum_corridas_forma_pagamentoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_corridas_forma_pagamento[]'>
    


  /**
   * Reference to a field of type 'enum_denuncias_tipo_alvo'
   */
  export type Enumenum_denuncias_tipo_alvoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_denuncias_tipo_alvo'>
    


  /**
   * Reference to a field of type 'enum_denuncias_tipo_alvo[]'
   */
  export type ListEnumenum_denuncias_tipo_alvoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_denuncias_tipo_alvo[]'>
    


  /**
   * Reference to a field of type 'enum_denuncias_status'
   */
  export type Enumenum_denuncias_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_denuncias_status'>
    


  /**
   * Reference to a field of type 'enum_denuncias_status[]'
   */
  export type ListEnumenum_denuncias_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_denuncias_status[]'>
    


  /**
   * Reference to a field of type 'enum_documentos_tipo_documento'
   */
  export type Enumenum_documentos_tipo_documentoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_documentos_tipo_documento'>
    


  /**
   * Reference to a field of type 'enum_documentos_tipo_documento[]'
   */
  export type ListEnumenum_documentos_tipo_documentoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_documentos_tipo_documento[]'>
    


  /**
   * Reference to a field of type 'enum_documentos_status'
   */
  export type Enumenum_documentos_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_documentos_status'>
    


  /**
   * Reference to a field of type 'enum_documentos_status[]'
   */
  export type ListEnumenum_documentos_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_documentos_status[]'>
    


  /**
   * Reference to a field of type 'enum_emails_enviados_tipo'
   */
  export type Enumenum_emails_enviados_tipoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_emails_enviados_tipo'>
    


  /**
   * Reference to a field of type 'enum_emails_enviados_tipo[]'
   */
  export type ListEnumenum_emails_enviados_tipoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_emails_enviados_tipo[]'>
    


  /**
   * Reference to a field of type 'enum_emails_enviados_status_envio'
   */
  export type Enumenum_emails_enviados_status_envioFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_emails_enviados_status_envio'>
    


  /**
   * Reference to a field of type 'enum_emails_enviados_status_envio[]'
   */
  export type ListEnumenum_emails_enviados_status_envioFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_emails_enviados_status_envio[]'>
    


  /**
   * Reference to a field of type 'enum_historico_indicacoes_tipo'
   */
  export type Enumenum_historico_indicacoes_tipoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_historico_indicacoes_tipo'>
    


  /**
   * Reference to a field of type 'enum_historico_indicacoes_tipo[]'
   */
  export type ListEnumenum_historico_indicacoes_tipoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_historico_indicacoes_tipo[]'>
    


  /**
   * Reference to a field of type 'enum_historico_selfies_tipo'
   */
  export type Enumenum_historico_selfies_tipoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_historico_selfies_tipo'>
    


  /**
   * Reference to a field of type 'enum_historico_selfies_tipo[]'
   */
  export type ListEnumenum_historico_selfies_tipoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_historico_selfies_tipo[]'>
    


  /**
   * Reference to a field of type 'enum_historico_selfies_resultado'
   */
  export type Enumenum_historico_selfies_resultadoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_historico_selfies_resultado'>
    


  /**
   * Reference to a field of type 'enum_historico_selfies_resultado[]'
   */
  export type ListEnumenum_historico_selfies_resultadoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_historico_selfies_resultado[]'>
    


  /**
   * Reference to a field of type 'enum_logs_acesso_tipo_usuario'
   */
  export type Enumenum_logs_acesso_tipo_usuarioFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_logs_acesso_tipo_usuario'>
    


  /**
   * Reference to a field of type 'enum_logs_acesso_tipo_usuario[]'
   */
  export type ListEnumenum_logs_acesso_tipo_usuarioFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_logs_acesso_tipo_usuario[]'>
    


  /**
   * Reference to a field of type 'enum_mensagens_suporte_tipo_usuario'
   */
  export type Enumenum_mensagens_suporte_tipo_usuarioFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_mensagens_suporte_tipo_usuario'>
    


  /**
   * Reference to a field of type 'enum_mensagens_suporte_tipo_usuario[]'
   */
  export type ListEnumenum_mensagens_suporte_tipo_usuarioFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_mensagens_suporte_tipo_usuario[]'>
    


  /**
   * Reference to a field of type 'enum_mensagens_suporte_status'
   */
  export type Enumenum_mensagens_suporte_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_mensagens_suporte_status'>
    


  /**
   * Reference to a field of type 'enum_mensagens_suporte_status[]'
   */
  export type ListEnumenum_mensagens_suporte_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_mensagens_suporte_status[]'>
    


  /**
   * Reference to a field of type 'enum_recompensas_tipo'
   */
  export type Enumenum_recompensas_tipoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_recompensas_tipo'>
    


  /**
   * Reference to a field of type 'enum_recompensas_tipo[]'
   */
  export type ListEnumenum_recompensas_tipoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_recompensas_tipo[]'>
    


  /**
   * Reference to a field of type 'enum_recompensas_status'
   */
  export type Enumenum_recompensas_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_recompensas_status'>
    


  /**
   * Reference to a field of type 'enum_recompensas_status[]'
   */
  export type ListEnumenum_recompensas_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_recompensas_status[]'>
    


  /**
   * Reference to a field of type 'enum_saques_status'
   */
  export type Enumenum_saques_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_saques_status'>
    


  /**
   * Reference to a field of type 'enum_saques_status[]'
   */
  export type ListEnumenum_saques_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_saques_status[]'>
    


  /**
   * Reference to a field of type 'enum_saques_tipo'
   */
  export type Enumenum_saques_tipoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_saques_tipo'>
    


  /**
   * Reference to a field of type 'enum_saques_tipo[]'
   */
  export type ListEnumenum_saques_tipoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_saques_tipo[]'>
    


  /**
   * Reference to a field of type 'enum_transacoes_tipo'
   */
  export type Enumenum_transacoes_tipoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_transacoes_tipo'>
    


  /**
   * Reference to a field of type 'enum_transacoes_tipo[]'
   */
  export type ListEnumenum_transacoes_tipoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_transacoes_tipo[]'>
    


  /**
   * Reference to a field of type 'enum_transacoes_origem'
   */
  export type Enumenum_transacoes_origemFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_transacoes_origem'>
    


  /**
   * Reference to a field of type 'enum_transacoes_origem[]'
   */
  export type ListEnumenum_transacoes_origemFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_transacoes_origem[]'>
    


  /**
   * Reference to a field of type 'enum_usuarios_tipo'
   */
  export type Enumenum_usuarios_tipoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_usuarios_tipo'>
    


  /**
   * Reference to a field of type 'enum_usuarios_tipo[]'
   */
  export type ListEnumenum_usuarios_tipoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_usuarios_tipo[]'>
    


  /**
   * Reference to a field of type 'enum_veiculos_categoria'
   */
  export type Enumenum_veiculos_categoriaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_veiculos_categoria'>
    


  /**
   * Reference to a field of type 'enum_veiculos_categoria[]'
   */
  export type ListEnumenum_veiculos_categoriaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_veiculos_categoria[]'>
    


  /**
   * Reference to a field of type 'enum_veiculos_status'
   */
  export type Enumenum_veiculos_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_veiculos_status'>
    


  /**
   * Reference to a field of type 'enum_veiculos_status[]'
   */
  export type ListEnumenum_veiculos_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_veiculos_status[]'>
    
  /**
   * Deep Input Types
   */


  export type BairroPrioridadesWhereInput = {
    AND?: BairroPrioridadesWhereInput | BairroPrioridadesWhereInput[]
    OR?: BairroPrioridadesWhereInput[]
    NOT?: BairroPrioridadesWhereInput | BairroPrioridadesWhereInput[]
    id?: IntFilter<"BairroPrioridades"> | number
    nome?: StringFilter<"BairroPrioridades"> | string
    cidade?: StringFilter<"BairroPrioridades"> | string
    estado?: StringFilter<"BairroPrioridades"> | string
    ativo?: BoolNullableFilter<"BairroPrioridades"> | boolean | null
    tipo_prioridade?: Enumenum_BairroPrioridades_tipo_prioridadeNullableFilter<"BairroPrioridades"> | $Enums.enum_BairroPrioridades_tipo_prioridade | null
    createdAt?: DateTimeFilter<"BairroPrioridades"> | Date | string
    updatedAt?: DateTimeFilter<"BairroPrioridades"> | Date | string
  }

  export type BairroPrioridadesOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    cidade?: SortOrder
    estado?: SortOrder
    ativo?: SortOrderInput | SortOrder
    tipo_prioridade?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BairroPrioridadesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BairroPrioridadesWhereInput | BairroPrioridadesWhereInput[]
    OR?: BairroPrioridadesWhereInput[]
    NOT?: BairroPrioridadesWhereInput | BairroPrioridadesWhereInput[]
    nome?: StringFilter<"BairroPrioridades"> | string
    cidade?: StringFilter<"BairroPrioridades"> | string
    estado?: StringFilter<"BairroPrioridades"> | string
    ativo?: BoolNullableFilter<"BairroPrioridades"> | boolean | null
    tipo_prioridade?: Enumenum_BairroPrioridades_tipo_prioridadeNullableFilter<"BairroPrioridades"> | $Enums.enum_BairroPrioridades_tipo_prioridade | null
    createdAt?: DateTimeFilter<"BairroPrioridades"> | Date | string
    updatedAt?: DateTimeFilter<"BairroPrioridades"> | Date | string
  }, "id">

  export type BairroPrioridadesOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    cidade?: SortOrder
    estado?: SortOrder
    ativo?: SortOrderInput | SortOrder
    tipo_prioridade?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BairroPrioridadesCountOrderByAggregateInput
    _avg?: BairroPrioridadesAvgOrderByAggregateInput
    _max?: BairroPrioridadesMaxOrderByAggregateInput
    _min?: BairroPrioridadesMinOrderByAggregateInput
    _sum?: BairroPrioridadesSumOrderByAggregateInput
  }

  export type BairroPrioridadesScalarWhereWithAggregatesInput = {
    AND?: BairroPrioridadesScalarWhereWithAggregatesInput | BairroPrioridadesScalarWhereWithAggregatesInput[]
    OR?: BairroPrioridadesScalarWhereWithAggregatesInput[]
    NOT?: BairroPrioridadesScalarWhereWithAggregatesInput | BairroPrioridadesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BairroPrioridades"> | number
    nome?: StringWithAggregatesFilter<"BairroPrioridades"> | string
    cidade?: StringWithAggregatesFilter<"BairroPrioridades"> | string
    estado?: StringWithAggregatesFilter<"BairroPrioridades"> | string
    ativo?: BoolNullableWithAggregatesFilter<"BairroPrioridades"> | boolean | null
    tipo_prioridade?: Enumenum_BairroPrioridades_tipo_prioridadeNullableWithAggregatesFilter<"BairroPrioridades"> | $Enums.enum_BairroPrioridades_tipo_prioridade | null
    createdAt?: DateTimeWithAggregatesFilter<"BairroPrioridades"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BairroPrioridades"> | Date | string
  }

  export type CarteirasWhereInput = {
    AND?: CarteirasWhereInput | CarteirasWhereInput[]
    OR?: CarteirasWhereInput[]
    NOT?: CarteirasWhereInput | CarteirasWhereInput[]
    id?: IntFilter<"Carteiras"> | number
    usuarioId?: IntFilter<"Carteiras"> | number
    saldo?: DecimalNullableFilter<"Carteiras"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"Carteiras"> | Date | string
    updatedAt?: DateTimeFilter<"Carteiras"> | Date | string
  }

  export type CarteirasOrderByWithRelationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    saldo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CarteirasWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CarteirasWhereInput | CarteirasWhereInput[]
    OR?: CarteirasWhereInput[]
    NOT?: CarteirasWhereInput | CarteirasWhereInput[]
    usuarioId?: IntFilter<"Carteiras"> | number
    saldo?: DecimalNullableFilter<"Carteiras"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"Carteiras"> | Date | string
    updatedAt?: DateTimeFilter<"Carteiras"> | Date | string
  }, "id">

  export type CarteirasOrderByWithAggregationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    saldo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CarteirasCountOrderByAggregateInput
    _avg?: CarteirasAvgOrderByAggregateInput
    _max?: CarteirasMaxOrderByAggregateInput
    _min?: CarteirasMinOrderByAggregateInput
    _sum?: CarteirasSumOrderByAggregateInput
  }

  export type CarteirasScalarWhereWithAggregatesInput = {
    AND?: CarteirasScalarWhereWithAggregatesInput | CarteirasScalarWhereWithAggregatesInput[]
    OR?: CarteirasScalarWhereWithAggregatesInput[]
    NOT?: CarteirasScalarWhereWithAggregatesInput | CarteirasScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Carteiras"> | number
    usuarioId?: IntWithAggregatesFilter<"Carteiras"> | number
    saldo?: DecimalNullableWithAggregatesFilter<"Carteiras"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Carteiras"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Carteiras"> | Date | string
  }

  export type CodigoIndicacaosWhereInput = {
    AND?: CodigoIndicacaosWhereInput | CodigoIndicacaosWhereInput[]
    OR?: CodigoIndicacaosWhereInput[]
    NOT?: CodigoIndicacaosWhereInput | CodigoIndicacaosWhereInput[]
    id?: IntFilter<"CodigoIndicacaos"> | number
    codigo?: StringFilter<"CodigoIndicacaos"> | string
    usuarioId?: IntFilter<"CodigoIndicacaos"> | number
    createdAt?: DateTimeFilter<"CodigoIndicacaos"> | Date | string
    updatedAt?: DateTimeFilter<"CodigoIndicacaos"> | Date | string
  }

  export type CodigoIndicacaosOrderByWithRelationInput = {
    id?: SortOrder
    codigo?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CodigoIndicacaosWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    codigo?: string
    AND?: CodigoIndicacaosWhereInput | CodigoIndicacaosWhereInput[]
    OR?: CodigoIndicacaosWhereInput[]
    NOT?: CodigoIndicacaosWhereInput | CodigoIndicacaosWhereInput[]
    usuarioId?: IntFilter<"CodigoIndicacaos"> | number
    createdAt?: DateTimeFilter<"CodigoIndicacaos"> | Date | string
    updatedAt?: DateTimeFilter<"CodigoIndicacaos"> | Date | string
  }, "id" | "codigo">

  export type CodigoIndicacaosOrderByWithAggregationInput = {
    id?: SortOrder
    codigo?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CodigoIndicacaosCountOrderByAggregateInput
    _avg?: CodigoIndicacaosAvgOrderByAggregateInput
    _max?: CodigoIndicacaosMaxOrderByAggregateInput
    _min?: CodigoIndicacaosMinOrderByAggregateInput
    _sum?: CodigoIndicacaosSumOrderByAggregateInput
  }

  export type CodigoIndicacaosScalarWhereWithAggregatesInput = {
    AND?: CodigoIndicacaosScalarWhereWithAggregatesInput | CodigoIndicacaosScalarWhereWithAggregatesInput[]
    OR?: CodigoIndicacaosScalarWhereWithAggregatesInput[]
    NOT?: CodigoIndicacaosScalarWhereWithAggregatesInput | CodigoIndicacaosScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CodigoIndicacaos"> | number
    codigo?: StringWithAggregatesFilter<"CodigoIndicacaos"> | string
    usuarioId?: IntWithAggregatesFilter<"CodigoIndicacaos"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CodigoIndicacaos"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CodigoIndicacaos"> | Date | string
  }

  export type CorridaAgendadasWhereInput = {
    AND?: CorridaAgendadasWhereInput | CorridaAgendadasWhereInput[]
    OR?: CorridaAgendadasWhereInput[]
    NOT?: CorridaAgendadasWhereInput | CorridaAgendadasWhereInput[]
    id?: IntFilter<"CorridaAgendadas"> | number
    passageiroCpf?: StringFilter<"CorridaAgendadas"> | string
    motoristaCpf?: StringNullableFilter<"CorridaAgendadas"> | string | null
    origem?: StringFilter<"CorridaAgendadas"> | string
    destino?: StringFilter<"CorridaAgendadas"> | string
    dataHoraAgendada?: DateTimeFilter<"CorridaAgendadas"> | Date | string
    status?: StringNullableFilter<"CorridaAgendadas"> | string | null
    tipo?: StringFilter<"CorridaAgendadas"> | string
    valor?: FloatNullableFilter<"CorridaAgendadas"> | number | null
    createdAt?: DateTimeFilter<"CorridaAgendadas"> | Date | string
    updatedAt?: DateTimeFilter<"CorridaAgendadas"> | Date | string
  }

  export type CorridaAgendadasOrderByWithRelationInput = {
    id?: SortOrder
    passageiroCpf?: SortOrder
    motoristaCpf?: SortOrderInput | SortOrder
    origem?: SortOrder
    destino?: SortOrder
    dataHoraAgendada?: SortOrder
    status?: SortOrderInput | SortOrder
    tipo?: SortOrder
    valor?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CorridaAgendadasWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CorridaAgendadasWhereInput | CorridaAgendadasWhereInput[]
    OR?: CorridaAgendadasWhereInput[]
    NOT?: CorridaAgendadasWhereInput | CorridaAgendadasWhereInput[]
    passageiroCpf?: StringFilter<"CorridaAgendadas"> | string
    motoristaCpf?: StringNullableFilter<"CorridaAgendadas"> | string | null
    origem?: StringFilter<"CorridaAgendadas"> | string
    destino?: StringFilter<"CorridaAgendadas"> | string
    dataHoraAgendada?: DateTimeFilter<"CorridaAgendadas"> | Date | string
    status?: StringNullableFilter<"CorridaAgendadas"> | string | null
    tipo?: StringFilter<"CorridaAgendadas"> | string
    valor?: FloatNullableFilter<"CorridaAgendadas"> | number | null
    createdAt?: DateTimeFilter<"CorridaAgendadas"> | Date | string
    updatedAt?: DateTimeFilter<"CorridaAgendadas"> | Date | string
  }, "id">

  export type CorridaAgendadasOrderByWithAggregationInput = {
    id?: SortOrder
    passageiroCpf?: SortOrder
    motoristaCpf?: SortOrderInput | SortOrder
    origem?: SortOrder
    destino?: SortOrder
    dataHoraAgendada?: SortOrder
    status?: SortOrderInput | SortOrder
    tipo?: SortOrder
    valor?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CorridaAgendadasCountOrderByAggregateInput
    _avg?: CorridaAgendadasAvgOrderByAggregateInput
    _max?: CorridaAgendadasMaxOrderByAggregateInput
    _min?: CorridaAgendadasMinOrderByAggregateInput
    _sum?: CorridaAgendadasSumOrderByAggregateInput
  }

  export type CorridaAgendadasScalarWhereWithAggregatesInput = {
    AND?: CorridaAgendadasScalarWhereWithAggregatesInput | CorridaAgendadasScalarWhereWithAggregatesInput[]
    OR?: CorridaAgendadasScalarWhereWithAggregatesInput[]
    NOT?: CorridaAgendadasScalarWhereWithAggregatesInput | CorridaAgendadasScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CorridaAgendadas"> | number
    passageiroCpf?: StringWithAggregatesFilter<"CorridaAgendadas"> | string
    motoristaCpf?: StringNullableWithAggregatesFilter<"CorridaAgendadas"> | string | null
    origem?: StringWithAggregatesFilter<"CorridaAgendadas"> | string
    destino?: StringWithAggregatesFilter<"CorridaAgendadas"> | string
    dataHoraAgendada?: DateTimeWithAggregatesFilter<"CorridaAgendadas"> | Date | string
    status?: StringNullableWithAggregatesFilter<"CorridaAgendadas"> | string | null
    tipo?: StringWithAggregatesFilter<"CorridaAgendadas"> | string
    valor?: FloatNullableWithAggregatesFilter<"CorridaAgendadas"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"CorridaAgendadas"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CorridaAgendadas"> | Date | string
  }

  export type CorridasWhereInput = {
    AND?: CorridasWhereInput | CorridasWhereInput[]
    OR?: CorridasWhereInput[]
    NOT?: CorridasWhereInput | CorridasWhereInput[]
    id?: IntFilter<"Corridas"> | number
    origem?: StringNullableFilter<"Corridas"> | string | null
    destino?: StringNullableFilter<"Corridas"> | string | null
    status?: StringNullableFilter<"Corridas"> | string | null
    valor?: DecimalNullableFilter<"Corridas"> | Decimal | DecimalJsLike | number | string | null
    tipo?: Enumenum_Corridas_tipoNullableFilter<"Corridas"> | $Enums.enum_Corridas_tipo | null
    horarioAgendado?: DateTimeNullableFilter<"Corridas"> | Date | string | null
    usuarioId?: IntNullableFilter<"Corridas"> | number | null
    createdAt?: DateTimeFilter<"Corridas"> | Date | string
    updatedAt?: DateTimeFilter<"Corridas"> | Date | string
  }

  export type CorridasOrderByWithRelationInput = {
    id?: SortOrder
    origem?: SortOrderInput | SortOrder
    destino?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    valor?: SortOrderInput | SortOrder
    tipo?: SortOrderInput | SortOrder
    horarioAgendado?: SortOrderInput | SortOrder
    usuarioId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CorridasWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CorridasWhereInput | CorridasWhereInput[]
    OR?: CorridasWhereInput[]
    NOT?: CorridasWhereInput | CorridasWhereInput[]
    origem?: StringNullableFilter<"Corridas"> | string | null
    destino?: StringNullableFilter<"Corridas"> | string | null
    status?: StringNullableFilter<"Corridas"> | string | null
    valor?: DecimalNullableFilter<"Corridas"> | Decimal | DecimalJsLike | number | string | null
    tipo?: Enumenum_Corridas_tipoNullableFilter<"Corridas"> | $Enums.enum_Corridas_tipo | null
    horarioAgendado?: DateTimeNullableFilter<"Corridas"> | Date | string | null
    usuarioId?: IntNullableFilter<"Corridas"> | number | null
    createdAt?: DateTimeFilter<"Corridas"> | Date | string
    updatedAt?: DateTimeFilter<"Corridas"> | Date | string
  }, "id">

  export type CorridasOrderByWithAggregationInput = {
    id?: SortOrder
    origem?: SortOrderInput | SortOrder
    destino?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    valor?: SortOrderInput | SortOrder
    tipo?: SortOrderInput | SortOrder
    horarioAgendado?: SortOrderInput | SortOrder
    usuarioId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CorridasCountOrderByAggregateInput
    _avg?: CorridasAvgOrderByAggregateInput
    _max?: CorridasMaxOrderByAggregateInput
    _min?: CorridasMinOrderByAggregateInput
    _sum?: CorridasSumOrderByAggregateInput
  }

  export type CorridasScalarWhereWithAggregatesInput = {
    AND?: CorridasScalarWhereWithAggregatesInput | CorridasScalarWhereWithAggregatesInput[]
    OR?: CorridasScalarWhereWithAggregatesInput[]
    NOT?: CorridasScalarWhereWithAggregatesInput | CorridasScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Corridas"> | number
    origem?: StringNullableWithAggregatesFilter<"Corridas"> | string | null
    destino?: StringNullableWithAggregatesFilter<"Corridas"> | string | null
    status?: StringNullableWithAggregatesFilter<"Corridas"> | string | null
    valor?: DecimalNullableWithAggregatesFilter<"Corridas"> | Decimal | DecimalJsLike | number | string | null
    tipo?: Enumenum_Corridas_tipoNullableWithAggregatesFilter<"Corridas"> | $Enums.enum_Corridas_tipo | null
    horarioAgendado?: DateTimeNullableWithAggregatesFilter<"Corridas"> | Date | string | null
    usuarioId?: IntNullableWithAggregatesFilter<"Corridas"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Corridas"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Corridas"> | Date | string
  }

  export type DenunciaWhereInput = {
    AND?: DenunciaWhereInput | DenunciaWhereInput[]
    OR?: DenunciaWhereInput[]
    NOT?: DenunciaWhereInput | DenunciaWhereInput[]
    id?: IntFilter<"Denuncia"> | number
    autor_id?: IntFilter<"Denuncia"> | number
    alvo_id?: IntFilter<"Denuncia"> | number
    tipo_alvo?: Enumenum_Denuncia_tipo_alvoFilter<"Denuncia"> | $Enums.enum_Denuncia_tipo_alvo
    createdAt?: DateTimeFilter<"Denuncia"> | Date | string
    updatedAt?: DateTimeFilter<"Denuncia"> | Date | string
  }

  export type DenunciaOrderByWithRelationInput = {
    id?: SortOrder
    autor_id?: SortOrder
    alvo_id?: SortOrder
    tipo_alvo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DenunciaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DenunciaWhereInput | DenunciaWhereInput[]
    OR?: DenunciaWhereInput[]
    NOT?: DenunciaWhereInput | DenunciaWhereInput[]
    autor_id?: IntFilter<"Denuncia"> | number
    alvo_id?: IntFilter<"Denuncia"> | number
    tipo_alvo?: Enumenum_Denuncia_tipo_alvoFilter<"Denuncia"> | $Enums.enum_Denuncia_tipo_alvo
    createdAt?: DateTimeFilter<"Denuncia"> | Date | string
    updatedAt?: DateTimeFilter<"Denuncia"> | Date | string
  }, "id">

  export type DenunciaOrderByWithAggregationInput = {
    id?: SortOrder
    autor_id?: SortOrder
    alvo_id?: SortOrder
    tipo_alvo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DenunciaCountOrderByAggregateInput
    _avg?: DenunciaAvgOrderByAggregateInput
    _max?: DenunciaMaxOrderByAggregateInput
    _min?: DenunciaMinOrderByAggregateInput
    _sum?: DenunciaSumOrderByAggregateInput
  }

  export type DenunciaScalarWhereWithAggregatesInput = {
    AND?: DenunciaScalarWhereWithAggregatesInput | DenunciaScalarWhereWithAggregatesInput[]
    OR?: DenunciaScalarWhereWithAggregatesInput[]
    NOT?: DenunciaScalarWhereWithAggregatesInput | DenunciaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Denuncia"> | number
    autor_id?: IntWithAggregatesFilter<"Denuncia"> | number
    alvo_id?: IntWithAggregatesFilter<"Denuncia"> | number
    tipo_alvo?: Enumenum_Denuncia_tipo_alvoWithAggregatesFilter<"Denuncia"> | $Enums.enum_Denuncia_tipo_alvo
    createdAt?: DateTimeWithAggregatesFilter<"Denuncia"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Denuncia"> | Date | string
  }

  export type DocumentosWhereInput = {
    AND?: DocumentosWhereInput | DocumentosWhereInput[]
    OR?: DocumentosWhereInput[]
    NOT?: DocumentosWhereInput | DocumentosWhereInput[]
    id?: IntFilter<"Documentos"> | number
    usuario_id?: IntFilter<"Documentos"> | number
    tipo_documento?: Enumenum_Documentos_tipo_documentoFilter<"Documentos"> | $Enums.enum_Documentos_tipo_documento
    createdAt?: DateTimeFilter<"Documentos"> | Date | string
    updatedAt?: DateTimeFilter<"Documentos"> | Date | string
  }

  export type DocumentosOrderByWithRelationInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    tipo_documento?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentosWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DocumentosWhereInput | DocumentosWhereInput[]
    OR?: DocumentosWhereInput[]
    NOT?: DocumentosWhereInput | DocumentosWhereInput[]
    usuario_id?: IntFilter<"Documentos"> | number
    tipo_documento?: Enumenum_Documentos_tipo_documentoFilter<"Documentos"> | $Enums.enum_Documentos_tipo_documento
    createdAt?: DateTimeFilter<"Documentos"> | Date | string
    updatedAt?: DateTimeFilter<"Documentos"> | Date | string
  }, "id">

  export type DocumentosOrderByWithAggregationInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    tipo_documento?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DocumentosCountOrderByAggregateInput
    _avg?: DocumentosAvgOrderByAggregateInput
    _max?: DocumentosMaxOrderByAggregateInput
    _min?: DocumentosMinOrderByAggregateInput
    _sum?: DocumentosSumOrderByAggregateInput
  }

  export type DocumentosScalarWhereWithAggregatesInput = {
    AND?: DocumentosScalarWhereWithAggregatesInput | DocumentosScalarWhereWithAggregatesInput[]
    OR?: DocumentosScalarWhereWithAggregatesInput[]
    NOT?: DocumentosScalarWhereWithAggregatesInput | DocumentosScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Documentos"> | number
    usuario_id?: IntWithAggregatesFilter<"Documentos"> | number
    tipo_documento?: Enumenum_Documentos_tipo_documentoWithAggregatesFilter<"Documentos"> | $Enums.enum_Documentos_tipo_documento
    createdAt?: DateTimeWithAggregatesFilter<"Documentos"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Documentos"> | Date | string
  }

  export type EmailEnviadosWhereInput = {
    AND?: EmailEnviadosWhereInput | EmailEnviadosWhereInput[]
    OR?: EmailEnviadosWhereInput[]
    NOT?: EmailEnviadosWhereInput | EmailEnviadosWhereInput[]
    id?: IntFilter<"EmailEnviados"> | number
    usuario_id?: IntFilter<"EmailEnviados"> | number
    email?: StringFilter<"EmailEnviados"> | string
    tipo?: Enumenum_EmailEnviados_tipoNullableFilter<"EmailEnviados"> | $Enums.enum_EmailEnviados_tipo | null
    createdAt?: DateTimeFilter<"EmailEnviados"> | Date | string
    updatedAt?: DateTimeFilter<"EmailEnviados"> | Date | string
  }

  export type EmailEnviadosOrderByWithRelationInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    email?: SortOrder
    tipo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailEnviadosWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EmailEnviadosWhereInput | EmailEnviadosWhereInput[]
    OR?: EmailEnviadosWhereInput[]
    NOT?: EmailEnviadosWhereInput | EmailEnviadosWhereInput[]
    usuario_id?: IntFilter<"EmailEnviados"> | number
    email?: StringFilter<"EmailEnviados"> | string
    tipo?: Enumenum_EmailEnviados_tipoNullableFilter<"EmailEnviados"> | $Enums.enum_EmailEnviados_tipo | null
    createdAt?: DateTimeFilter<"EmailEnviados"> | Date | string
    updatedAt?: DateTimeFilter<"EmailEnviados"> | Date | string
  }, "id">

  export type EmailEnviadosOrderByWithAggregationInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    email?: SortOrder
    tipo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmailEnviadosCountOrderByAggregateInput
    _avg?: EmailEnviadosAvgOrderByAggregateInput
    _max?: EmailEnviadosMaxOrderByAggregateInput
    _min?: EmailEnviadosMinOrderByAggregateInput
    _sum?: EmailEnviadosSumOrderByAggregateInput
  }

  export type EmailEnviadosScalarWhereWithAggregatesInput = {
    AND?: EmailEnviadosScalarWhereWithAggregatesInput | EmailEnviadosScalarWhereWithAggregatesInput[]
    OR?: EmailEnviadosScalarWhereWithAggregatesInput[]
    NOT?: EmailEnviadosScalarWhereWithAggregatesInput | EmailEnviadosScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EmailEnviados"> | number
    usuario_id?: IntWithAggregatesFilter<"EmailEnviados"> | number
    email?: StringWithAggregatesFilter<"EmailEnviados"> | string
    tipo?: Enumenum_EmailEnviados_tipoNullableWithAggregatesFilter<"EmailEnviados"> | $Enums.enum_EmailEnviados_tipo | null
    createdAt?: DateTimeWithAggregatesFilter<"EmailEnviados"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmailEnviados"> | Date | string
  }

  export type HistoricoIndicacaosWhereInput = {
    AND?: HistoricoIndicacaosWhereInput | HistoricoIndicacaosWhereInput[]
    OR?: HistoricoIndicacaosWhereInput[]
    NOT?: HistoricoIndicacaosWhereInput | HistoricoIndicacaosWhereInput[]
    id?: IntFilter<"HistoricoIndicacaos"> | number
    indicador_id?: IntFilter<"HistoricoIndicacaos"> | number
    indicado_id?: IntFilter<"HistoricoIndicacaos"> | number
    tipo?: Enumenum_HistoricoIndicacaos_tipoNullableFilter<"HistoricoIndicacaos"> | $Enums.enum_HistoricoIndicacaos_tipo | null
    createdAt?: DateTimeFilter<"HistoricoIndicacaos"> | Date | string
    updatedAt?: DateTimeFilter<"HistoricoIndicacaos"> | Date | string
  }

  export type HistoricoIndicacaosOrderByWithRelationInput = {
    id?: SortOrder
    indicador_id?: SortOrder
    indicado_id?: SortOrder
    tipo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HistoricoIndicacaosWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: HistoricoIndicacaosWhereInput | HistoricoIndicacaosWhereInput[]
    OR?: HistoricoIndicacaosWhereInput[]
    NOT?: HistoricoIndicacaosWhereInput | HistoricoIndicacaosWhereInput[]
    indicador_id?: IntFilter<"HistoricoIndicacaos"> | number
    indicado_id?: IntFilter<"HistoricoIndicacaos"> | number
    tipo?: Enumenum_HistoricoIndicacaos_tipoNullableFilter<"HistoricoIndicacaos"> | $Enums.enum_HistoricoIndicacaos_tipo | null
    createdAt?: DateTimeFilter<"HistoricoIndicacaos"> | Date | string
    updatedAt?: DateTimeFilter<"HistoricoIndicacaos"> | Date | string
  }, "id">

  export type HistoricoIndicacaosOrderByWithAggregationInput = {
    id?: SortOrder
    indicador_id?: SortOrder
    indicado_id?: SortOrder
    tipo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HistoricoIndicacaosCountOrderByAggregateInput
    _avg?: HistoricoIndicacaosAvgOrderByAggregateInput
    _max?: HistoricoIndicacaosMaxOrderByAggregateInput
    _min?: HistoricoIndicacaosMinOrderByAggregateInput
    _sum?: HistoricoIndicacaosSumOrderByAggregateInput
  }

  export type HistoricoIndicacaosScalarWhereWithAggregatesInput = {
    AND?: HistoricoIndicacaosScalarWhereWithAggregatesInput | HistoricoIndicacaosScalarWhereWithAggregatesInput[]
    OR?: HistoricoIndicacaosScalarWhereWithAggregatesInput[]
    NOT?: HistoricoIndicacaosScalarWhereWithAggregatesInput | HistoricoIndicacaosScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"HistoricoIndicacaos"> | number
    indicador_id?: IntWithAggregatesFilter<"HistoricoIndicacaos"> | number
    indicado_id?: IntWithAggregatesFilter<"HistoricoIndicacaos"> | number
    tipo?: Enumenum_HistoricoIndicacaos_tipoNullableWithAggregatesFilter<"HistoricoIndicacaos"> | $Enums.enum_HistoricoIndicacaos_tipo | null
    createdAt?: DateTimeWithAggregatesFilter<"HistoricoIndicacaos"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HistoricoIndicacaos"> | Date | string
  }

  export type HistoricoSelfiesWhereInput = {
    AND?: HistoricoSelfiesWhereInput | HistoricoSelfiesWhereInput[]
    OR?: HistoricoSelfiesWhereInput[]
    NOT?: HistoricoSelfiesWhereInput | HistoricoSelfiesWhereInput[]
    id?: IntFilter<"HistoricoSelfies"> | number
    usuario_id?: IntFilter<"HistoricoSelfies"> | number
    tipo?: Enumenum_HistoricoSelfies_tipoNullableFilter<"HistoricoSelfies"> | $Enums.enum_HistoricoSelfies_tipo | null
    createdAt?: DateTimeFilter<"HistoricoSelfies"> | Date | string
    updatedAt?: DateTimeFilter<"HistoricoSelfies"> | Date | string
  }

  export type HistoricoSelfiesOrderByWithRelationInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    tipo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HistoricoSelfiesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: HistoricoSelfiesWhereInput | HistoricoSelfiesWhereInput[]
    OR?: HistoricoSelfiesWhereInput[]
    NOT?: HistoricoSelfiesWhereInput | HistoricoSelfiesWhereInput[]
    usuario_id?: IntFilter<"HistoricoSelfies"> | number
    tipo?: Enumenum_HistoricoSelfies_tipoNullableFilter<"HistoricoSelfies"> | $Enums.enum_HistoricoSelfies_tipo | null
    createdAt?: DateTimeFilter<"HistoricoSelfies"> | Date | string
    updatedAt?: DateTimeFilter<"HistoricoSelfies"> | Date | string
  }, "id">

  export type HistoricoSelfiesOrderByWithAggregationInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    tipo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HistoricoSelfiesCountOrderByAggregateInput
    _avg?: HistoricoSelfiesAvgOrderByAggregateInput
    _max?: HistoricoSelfiesMaxOrderByAggregateInput
    _min?: HistoricoSelfiesMinOrderByAggregateInput
    _sum?: HistoricoSelfiesSumOrderByAggregateInput
  }

  export type HistoricoSelfiesScalarWhereWithAggregatesInput = {
    AND?: HistoricoSelfiesScalarWhereWithAggregatesInput | HistoricoSelfiesScalarWhereWithAggregatesInput[]
    OR?: HistoricoSelfiesScalarWhereWithAggregatesInput[]
    NOT?: HistoricoSelfiesScalarWhereWithAggregatesInput | HistoricoSelfiesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"HistoricoSelfies"> | number
    usuario_id?: IntWithAggregatesFilter<"HistoricoSelfies"> | number
    tipo?: Enumenum_HistoricoSelfies_tipoNullableWithAggregatesFilter<"HistoricoSelfies"> | $Enums.enum_HistoricoSelfies_tipo | null
    createdAt?: DateTimeWithAggregatesFilter<"HistoricoSelfies"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HistoricoSelfies"> | Date | string
  }

  export type IdentidadesWhereInput = {
    AND?: IdentidadesWhereInput | IdentidadesWhereInput[]
    OR?: IdentidadesWhereInput[]
    NOT?: IdentidadesWhereInput | IdentidadesWhereInput[]
    id?: IntFilter<"Identidades"> | number
    createdAt?: DateTimeFilter<"Identidades"> | Date | string
    updatedAt?: DateTimeFilter<"Identidades"> | Date | string
  }

  export type IdentidadesOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IdentidadesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: IdentidadesWhereInput | IdentidadesWhereInput[]
    OR?: IdentidadesWhereInput[]
    NOT?: IdentidadesWhereInput | IdentidadesWhereInput[]
    createdAt?: DateTimeFilter<"Identidades"> | Date | string
    updatedAt?: DateTimeFilter<"Identidades"> | Date | string
  }, "id">

  export type IdentidadesOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IdentidadesCountOrderByAggregateInput
    _avg?: IdentidadesAvgOrderByAggregateInput
    _max?: IdentidadesMaxOrderByAggregateInput
    _min?: IdentidadesMinOrderByAggregateInput
    _sum?: IdentidadesSumOrderByAggregateInput
  }

  export type IdentidadesScalarWhereWithAggregatesInput = {
    AND?: IdentidadesScalarWhereWithAggregatesInput | IdentidadesScalarWhereWithAggregatesInput[]
    OR?: IdentidadesScalarWhereWithAggregatesInput[]
    NOT?: IdentidadesScalarWhereWithAggregatesInput | IdentidadesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Identidades"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Identidades"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Identidades"> | Date | string
  }

  export type IndicacaosWhereInput = {
    AND?: IndicacaosWhereInput | IndicacaosWhereInput[]
    OR?: IndicacaosWhereInput[]
    NOT?: IndicacaosWhereInput | IndicacaosWhereInput[]
    id?: IntFilter<"Indicacaos"> | number
    indicanteId?: IntFilter<"Indicacaos"> | number
    indicadoId?: IntFilter<"Indicacaos"> | number
    createdAt?: DateTimeFilter<"Indicacaos"> | Date | string
    updatedAt?: DateTimeFilter<"Indicacaos"> | Date | string
    Usuarios_Indicacaos_indicadoIdToUsuarios?: XOR<UsuariosScalarRelationFilter, UsuariosWhereInput>
    Usuarios_Indicacaos_indicanteIdToUsuarios?: XOR<UsuariosScalarRelationFilter, UsuariosWhereInput>
  }

  export type IndicacaosOrderByWithRelationInput = {
    id?: SortOrder
    indicanteId?: SortOrder
    indicadoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Usuarios_Indicacaos_indicadoIdToUsuarios?: UsuariosOrderByWithRelationInput
    Usuarios_Indicacaos_indicanteIdToUsuarios?: UsuariosOrderByWithRelationInput
  }

  export type IndicacaosWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: IndicacaosWhereInput | IndicacaosWhereInput[]
    OR?: IndicacaosWhereInput[]
    NOT?: IndicacaosWhereInput | IndicacaosWhereInput[]
    indicanteId?: IntFilter<"Indicacaos"> | number
    indicadoId?: IntFilter<"Indicacaos"> | number
    createdAt?: DateTimeFilter<"Indicacaos"> | Date | string
    updatedAt?: DateTimeFilter<"Indicacaos"> | Date | string
    Usuarios_Indicacaos_indicadoIdToUsuarios?: XOR<UsuariosScalarRelationFilter, UsuariosWhereInput>
    Usuarios_Indicacaos_indicanteIdToUsuarios?: XOR<UsuariosScalarRelationFilter, UsuariosWhereInput>
  }, "id">

  export type IndicacaosOrderByWithAggregationInput = {
    id?: SortOrder
    indicanteId?: SortOrder
    indicadoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IndicacaosCountOrderByAggregateInput
    _avg?: IndicacaosAvgOrderByAggregateInput
    _max?: IndicacaosMaxOrderByAggregateInput
    _min?: IndicacaosMinOrderByAggregateInput
    _sum?: IndicacaosSumOrderByAggregateInput
  }

  export type IndicacaosScalarWhereWithAggregatesInput = {
    AND?: IndicacaosScalarWhereWithAggregatesInput | IndicacaosScalarWhereWithAggregatesInput[]
    OR?: IndicacaosScalarWhereWithAggregatesInput[]
    NOT?: IndicacaosScalarWhereWithAggregatesInput | IndicacaosScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Indicacaos"> | number
    indicanteId?: IntWithAggregatesFilter<"Indicacaos"> | number
    indicadoId?: IntWithAggregatesFilter<"Indicacaos"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Indicacaos"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Indicacaos"> | Date | string
  }

  export type LogAcessosWhereInput = {
    AND?: LogAcessosWhereInput | LogAcessosWhereInput[]
    OR?: LogAcessosWhereInput[]
    NOT?: LogAcessosWhereInput | LogAcessosWhereInput[]
    id?: IntFilter<"LogAcessos"> | number
    usuario_id?: IntFilter<"LogAcessos"> | number
    tipo_usuario?: Enumenum_LogAcessos_tipo_usuarioNullableFilter<"LogAcessos"> | $Enums.enum_LogAcessos_tipo_usuario | null
    createdAt?: DateTimeFilter<"LogAcessos"> | Date | string
    updatedAt?: DateTimeFilter<"LogAcessos"> | Date | string
  }

  export type LogAcessosOrderByWithRelationInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    tipo_usuario?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LogAcessosWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LogAcessosWhereInput | LogAcessosWhereInput[]
    OR?: LogAcessosWhereInput[]
    NOT?: LogAcessosWhereInput | LogAcessosWhereInput[]
    usuario_id?: IntFilter<"LogAcessos"> | number
    tipo_usuario?: Enumenum_LogAcessos_tipo_usuarioNullableFilter<"LogAcessos"> | $Enums.enum_LogAcessos_tipo_usuario | null
    createdAt?: DateTimeFilter<"LogAcessos"> | Date | string
    updatedAt?: DateTimeFilter<"LogAcessos"> | Date | string
  }, "id">

  export type LogAcessosOrderByWithAggregationInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    tipo_usuario?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LogAcessosCountOrderByAggregateInput
    _avg?: LogAcessosAvgOrderByAggregateInput
    _max?: LogAcessosMaxOrderByAggregateInput
    _min?: LogAcessosMinOrderByAggregateInput
    _sum?: LogAcessosSumOrderByAggregateInput
  }

  export type LogAcessosScalarWhereWithAggregatesInput = {
    AND?: LogAcessosScalarWhereWithAggregatesInput | LogAcessosScalarWhereWithAggregatesInput[]
    OR?: LogAcessosScalarWhereWithAggregatesInput[]
    NOT?: LogAcessosScalarWhereWithAggregatesInput | LogAcessosScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LogAcessos"> | number
    usuario_id?: IntWithAggregatesFilter<"LogAcessos"> | number
    tipo_usuario?: Enumenum_LogAcessos_tipo_usuarioNullableWithAggregatesFilter<"LogAcessos"> | $Enums.enum_LogAcessos_tipo_usuario | null
    createdAt?: DateTimeWithAggregatesFilter<"LogAcessos"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LogAcessos"> | Date | string
  }

  export type MensagemSuportesWhereInput = {
    AND?: MensagemSuportesWhereInput | MensagemSuportesWhereInput[]
    OR?: MensagemSuportesWhereInput[]
    NOT?: MensagemSuportesWhereInput | MensagemSuportesWhereInput[]
    id?: IntFilter<"MensagemSuportes"> | number
    usuario_id?: IntFilter<"MensagemSuportes"> | number
    tipo_usuario?: Enumenum_MensagemSuportes_tipo_usuarioNullableFilter<"MensagemSuportes"> | $Enums.enum_MensagemSuportes_tipo_usuario | null
    createdAt?: DateTimeFilter<"MensagemSuportes"> | Date | string
    updatedAt?: DateTimeFilter<"MensagemSuportes"> | Date | string
  }

  export type MensagemSuportesOrderByWithRelationInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    tipo_usuario?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MensagemSuportesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MensagemSuportesWhereInput | MensagemSuportesWhereInput[]
    OR?: MensagemSuportesWhereInput[]
    NOT?: MensagemSuportesWhereInput | MensagemSuportesWhereInput[]
    usuario_id?: IntFilter<"MensagemSuportes"> | number
    tipo_usuario?: Enumenum_MensagemSuportes_tipo_usuarioNullableFilter<"MensagemSuportes"> | $Enums.enum_MensagemSuportes_tipo_usuario | null
    createdAt?: DateTimeFilter<"MensagemSuportes"> | Date | string
    updatedAt?: DateTimeFilter<"MensagemSuportes"> | Date | string
  }, "id">

  export type MensagemSuportesOrderByWithAggregationInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    tipo_usuario?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MensagemSuportesCountOrderByAggregateInput
    _avg?: MensagemSuportesAvgOrderByAggregateInput
    _max?: MensagemSuportesMaxOrderByAggregateInput
    _min?: MensagemSuportesMinOrderByAggregateInput
    _sum?: MensagemSuportesSumOrderByAggregateInput
  }

  export type MensagemSuportesScalarWhereWithAggregatesInput = {
    AND?: MensagemSuportesScalarWhereWithAggregatesInput | MensagemSuportesScalarWhereWithAggregatesInput[]
    OR?: MensagemSuportesScalarWhereWithAggregatesInput[]
    NOT?: MensagemSuportesScalarWhereWithAggregatesInput | MensagemSuportesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MensagemSuportes"> | number
    usuario_id?: IntWithAggregatesFilter<"MensagemSuportes"> | number
    tipo_usuario?: Enumenum_MensagemSuportes_tipo_usuarioNullableWithAggregatesFilter<"MensagemSuportes"> | $Enums.enum_MensagemSuportes_tipo_usuario | null
    createdAt?: DateTimeWithAggregatesFilter<"MensagemSuportes"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MensagemSuportes"> | Date | string
  }

  export type RecompensasWhereInput = {
    AND?: RecompensasWhereInput | RecompensasWhereInput[]
    OR?: RecompensasWhereInput[]
    NOT?: RecompensasWhereInput | RecompensasWhereInput[]
    id?: IntFilter<"Recompensas"> | number
    usuarioId?: IntFilter<"Recompensas"> | number
    descricao?: StringFilter<"Recompensas"> | string
    valor?: FloatFilter<"Recompensas"> | number
    status?: Enumenum_Recompensas_statusNullableFilter<"Recompensas"> | $Enums.enum_Recompensas_status | null
    createdAt?: DateTimeFilter<"Recompensas"> | Date | string
    updatedAt?: DateTimeFilter<"Recompensas"> | Date | string
    Usuarios?: XOR<UsuariosScalarRelationFilter, UsuariosWhereInput>
  }

  export type RecompensasOrderByWithRelationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    descricao?: SortOrder
    valor?: SortOrder
    status?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Usuarios?: UsuariosOrderByWithRelationInput
  }

  export type RecompensasWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RecompensasWhereInput | RecompensasWhereInput[]
    OR?: RecompensasWhereInput[]
    NOT?: RecompensasWhereInput | RecompensasWhereInput[]
    usuarioId?: IntFilter<"Recompensas"> | number
    descricao?: StringFilter<"Recompensas"> | string
    valor?: FloatFilter<"Recompensas"> | number
    status?: Enumenum_Recompensas_statusNullableFilter<"Recompensas"> | $Enums.enum_Recompensas_status | null
    createdAt?: DateTimeFilter<"Recompensas"> | Date | string
    updatedAt?: DateTimeFilter<"Recompensas"> | Date | string
    Usuarios?: XOR<UsuariosScalarRelationFilter, UsuariosWhereInput>
  }, "id">

  export type RecompensasOrderByWithAggregationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    descricao?: SortOrder
    valor?: SortOrder
    status?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RecompensasCountOrderByAggregateInput
    _avg?: RecompensasAvgOrderByAggregateInput
    _max?: RecompensasMaxOrderByAggregateInput
    _min?: RecompensasMinOrderByAggregateInput
    _sum?: RecompensasSumOrderByAggregateInput
  }

  export type RecompensasScalarWhereWithAggregatesInput = {
    AND?: RecompensasScalarWhereWithAggregatesInput | RecompensasScalarWhereWithAggregatesInput[]
    OR?: RecompensasScalarWhereWithAggregatesInput[]
    NOT?: RecompensasScalarWhereWithAggregatesInput | RecompensasScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Recompensas"> | number
    usuarioId?: IntWithAggregatesFilter<"Recompensas"> | number
    descricao?: StringWithAggregatesFilter<"Recompensas"> | string
    valor?: FloatWithAggregatesFilter<"Recompensas"> | number
    status?: Enumenum_Recompensas_statusNullableWithAggregatesFilter<"Recompensas"> | $Enums.enum_Recompensas_status | null
    createdAt?: DateTimeWithAggregatesFilter<"Recompensas"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Recompensas"> | Date | string
  }

  export type SaquesWhereInput = {
    AND?: SaquesWhereInput | SaquesWhereInput[]
    OR?: SaquesWhereInput[]
    NOT?: SaquesWhereInput | SaquesWhereInput[]
    id?: IntFilter<"Saques"> | number
    usuarioId?: IntFilter<"Saques"> | number
    valor?: DecimalFilter<"Saques"> | Decimal | DecimalJsLike | number | string
    status?: Enumenum_Saques_statusNullableFilter<"Saques"> | $Enums.enum_Saques_status | null
    tipo?: Enumenum_Saques_tipoFilter<"Saques"> | $Enums.enum_Saques_tipo
    createdAt?: DateTimeFilter<"Saques"> | Date | string
    updatedAt?: DateTimeFilter<"Saques"> | Date | string
    Usuarios?: XOR<UsuariosScalarRelationFilter, UsuariosWhereInput>
  }

  export type SaquesOrderByWithRelationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    valor?: SortOrder
    status?: SortOrderInput | SortOrder
    tipo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Usuarios?: UsuariosOrderByWithRelationInput
  }

  export type SaquesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SaquesWhereInput | SaquesWhereInput[]
    OR?: SaquesWhereInput[]
    NOT?: SaquesWhereInput | SaquesWhereInput[]
    usuarioId?: IntFilter<"Saques"> | number
    valor?: DecimalFilter<"Saques"> | Decimal | DecimalJsLike | number | string
    status?: Enumenum_Saques_statusNullableFilter<"Saques"> | $Enums.enum_Saques_status | null
    tipo?: Enumenum_Saques_tipoFilter<"Saques"> | $Enums.enum_Saques_tipo
    createdAt?: DateTimeFilter<"Saques"> | Date | string
    updatedAt?: DateTimeFilter<"Saques"> | Date | string
    Usuarios?: XOR<UsuariosScalarRelationFilter, UsuariosWhereInput>
  }, "id">

  export type SaquesOrderByWithAggregationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    valor?: SortOrder
    status?: SortOrderInput | SortOrder
    tipo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SaquesCountOrderByAggregateInput
    _avg?: SaquesAvgOrderByAggregateInput
    _max?: SaquesMaxOrderByAggregateInput
    _min?: SaquesMinOrderByAggregateInput
    _sum?: SaquesSumOrderByAggregateInput
  }

  export type SaquesScalarWhereWithAggregatesInput = {
    AND?: SaquesScalarWhereWithAggregatesInput | SaquesScalarWhereWithAggregatesInput[]
    OR?: SaquesScalarWhereWithAggregatesInput[]
    NOT?: SaquesScalarWhereWithAggregatesInput | SaquesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Saques"> | number
    usuarioId?: IntWithAggregatesFilter<"Saques"> | number
    valor?: DecimalWithAggregatesFilter<"Saques"> | Decimal | DecimalJsLike | number | string
    status?: Enumenum_Saques_statusNullableWithAggregatesFilter<"Saques"> | $Enums.enum_Saques_status | null
    tipo?: Enumenum_Saques_tipoWithAggregatesFilter<"Saques"> | $Enums.enum_Saques_tipo
    createdAt?: DateTimeWithAggregatesFilter<"Saques"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Saques"> | Date | string
  }

  export type TransacaosWhereInput = {
    AND?: TransacaosWhereInput | TransacaosWhereInput[]
    OR?: TransacaosWhereInput[]
    NOT?: TransacaosWhereInput | TransacaosWhereInput[]
    id?: IntFilter<"Transacaos"> | number
    usuario_id?: IntFilter<"Transacaos"> | number
    tipo?: Enumenum_Transacaos_tipoFilter<"Transacaos"> | $Enums.enum_Transacaos_tipo
    valor?: FloatFilter<"Transacaos"> | number
    data?: DateTimeFilter<"Transacaos"> | Date | string
    createdAt?: DateTimeFilter<"Transacaos"> | Date | string
    updatedAt?: DateTimeFilter<"Transacaos"> | Date | string
    Usuarios?: XOR<UsuariosScalarRelationFilter, UsuariosWhereInput>
  }

  export type TransacaosOrderByWithRelationInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    tipo?: SortOrder
    valor?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Usuarios?: UsuariosOrderByWithRelationInput
  }

  export type TransacaosWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TransacaosWhereInput | TransacaosWhereInput[]
    OR?: TransacaosWhereInput[]
    NOT?: TransacaosWhereInput | TransacaosWhereInput[]
    usuario_id?: IntFilter<"Transacaos"> | number
    tipo?: Enumenum_Transacaos_tipoFilter<"Transacaos"> | $Enums.enum_Transacaos_tipo
    valor?: FloatFilter<"Transacaos"> | number
    data?: DateTimeFilter<"Transacaos"> | Date | string
    createdAt?: DateTimeFilter<"Transacaos"> | Date | string
    updatedAt?: DateTimeFilter<"Transacaos"> | Date | string
    Usuarios?: XOR<UsuariosScalarRelationFilter, UsuariosWhereInput>
  }, "id">

  export type TransacaosOrderByWithAggregationInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    tipo?: SortOrder
    valor?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransacaosCountOrderByAggregateInput
    _avg?: TransacaosAvgOrderByAggregateInput
    _max?: TransacaosMaxOrderByAggregateInput
    _min?: TransacaosMinOrderByAggregateInput
    _sum?: TransacaosSumOrderByAggregateInput
  }

  export type TransacaosScalarWhereWithAggregatesInput = {
    AND?: TransacaosScalarWhereWithAggregatesInput | TransacaosScalarWhereWithAggregatesInput[]
    OR?: TransacaosScalarWhereWithAggregatesInput[]
    NOT?: TransacaosScalarWhereWithAggregatesInput | TransacaosScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Transacaos"> | number
    usuario_id?: IntWithAggregatesFilter<"Transacaos"> | number
    tipo?: Enumenum_Transacaos_tipoWithAggregatesFilter<"Transacaos"> | $Enums.enum_Transacaos_tipo
    valor?: FloatWithAggregatesFilter<"Transacaos"> | number
    data?: DateTimeWithAggregatesFilter<"Transacaos"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Transacaos"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Transacaos"> | Date | string
  }

  export type UsuariosWhereInput = {
    AND?: UsuariosWhereInput | UsuariosWhereInput[]
    OR?: UsuariosWhereInput[]
    NOT?: UsuariosWhereInput | UsuariosWhereInput[]
    id?: IntFilter<"Usuarios"> | number
    nome?: StringFilter<"Usuarios"> | string
    email?: StringFilter<"Usuarios"> | string
    cpf?: StringNullableFilter<"Usuarios"> | string | null
    createdAt?: DateTimeFilter<"Usuarios"> | Date | string
    updatedAt?: DateTimeFilter<"Usuarios"> | Date | string
    Indicacaos_Indicacaos_indicadoIdToUsuarios?: IndicacaosListRelationFilter
    Indicacaos_Indicacaos_indicanteIdToUsuarios?: IndicacaosListRelationFilter
    Recompensas?: RecompensasListRelationFilter
    Saques?: SaquesListRelationFilter
    Transacaos?: TransacaosListRelationFilter
  }

  export type UsuariosOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    cpf?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Indicacaos_Indicacaos_indicadoIdToUsuarios?: IndicacaosOrderByRelationAggregateInput
    Indicacaos_Indicacaos_indicanteIdToUsuarios?: IndicacaosOrderByRelationAggregateInput
    Recompensas?: RecompensasOrderByRelationAggregateInput
    Saques?: SaquesOrderByRelationAggregateInput
    Transacaos?: TransacaosOrderByRelationAggregateInput
  }

  export type UsuariosWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UsuariosWhereInput | UsuariosWhereInput[]
    OR?: UsuariosWhereInput[]
    NOT?: UsuariosWhereInput | UsuariosWhereInput[]
    nome?: StringFilter<"Usuarios"> | string
    cpf?: StringNullableFilter<"Usuarios"> | string | null
    createdAt?: DateTimeFilter<"Usuarios"> | Date | string
    updatedAt?: DateTimeFilter<"Usuarios"> | Date | string
    Indicacaos_Indicacaos_indicadoIdToUsuarios?: IndicacaosListRelationFilter
    Indicacaos_Indicacaos_indicanteIdToUsuarios?: IndicacaosListRelationFilter
    Recompensas?: RecompensasListRelationFilter
    Saques?: SaquesListRelationFilter
    Transacaos?: TransacaosListRelationFilter
  }, "id" | "email">

  export type UsuariosOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    cpf?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UsuariosCountOrderByAggregateInput
    _avg?: UsuariosAvgOrderByAggregateInput
    _max?: UsuariosMaxOrderByAggregateInput
    _min?: UsuariosMinOrderByAggregateInput
    _sum?: UsuariosSumOrderByAggregateInput
  }

  export type UsuariosScalarWhereWithAggregatesInput = {
    AND?: UsuariosScalarWhereWithAggregatesInput | UsuariosScalarWhereWithAggregatesInput[]
    OR?: UsuariosScalarWhereWithAggregatesInput[]
    NOT?: UsuariosScalarWhereWithAggregatesInput | UsuariosScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Usuarios"> | number
    nome?: StringWithAggregatesFilter<"Usuarios"> | string
    email?: StringWithAggregatesFilter<"Usuarios"> | string
    cpf?: StringNullableWithAggregatesFilter<"Usuarios"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Usuarios"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Usuarios"> | Date | string
  }

  export type VeiculosWhereInput = {
    AND?: VeiculosWhereInput | VeiculosWhereInput[]
    OR?: VeiculosWhereInput[]
    NOT?: VeiculosWhereInput | VeiculosWhereInput[]
    id?: IntFilter<"Veiculos"> | number
    motorista_id?: IntFilter<"Veiculos"> | number
    modelo?: StringFilter<"Veiculos"> | string
    placa?: StringFilter<"Veiculos"> | string
    ano?: IntFilter<"Veiculos"> | number
    categoria?: Enumenum_Veiculos_categoriaNullableFilter<"Veiculos"> | $Enums.enum_Veiculos_categoria | null
    createdAt?: DateTimeFilter<"Veiculos"> | Date | string
    updatedAt?: DateTimeFilter<"Veiculos"> | Date | string
  }

  export type VeiculosOrderByWithRelationInput = {
    id?: SortOrder
    motorista_id?: SortOrder
    modelo?: SortOrder
    placa?: SortOrder
    ano?: SortOrder
    categoria?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VeiculosWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    placa?: string
    AND?: VeiculosWhereInput | VeiculosWhereInput[]
    OR?: VeiculosWhereInput[]
    NOT?: VeiculosWhereInput | VeiculosWhereInput[]
    motorista_id?: IntFilter<"Veiculos"> | number
    modelo?: StringFilter<"Veiculos"> | string
    ano?: IntFilter<"Veiculos"> | number
    categoria?: Enumenum_Veiculos_categoriaNullableFilter<"Veiculos"> | $Enums.enum_Veiculos_categoria | null
    createdAt?: DateTimeFilter<"Veiculos"> | Date | string
    updatedAt?: DateTimeFilter<"Veiculos"> | Date | string
  }, "id" | "placa">

  export type VeiculosOrderByWithAggregationInput = {
    id?: SortOrder
    motorista_id?: SortOrder
    modelo?: SortOrder
    placa?: SortOrder
    ano?: SortOrder
    categoria?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VeiculosCountOrderByAggregateInput
    _avg?: VeiculosAvgOrderByAggregateInput
    _max?: VeiculosMaxOrderByAggregateInput
    _min?: VeiculosMinOrderByAggregateInput
    _sum?: VeiculosSumOrderByAggregateInput
  }

  export type VeiculosScalarWhereWithAggregatesInput = {
    AND?: VeiculosScalarWhereWithAggregatesInput | VeiculosScalarWhereWithAggregatesInput[]
    OR?: VeiculosScalarWhereWithAggregatesInput[]
    NOT?: VeiculosScalarWhereWithAggregatesInput | VeiculosScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Veiculos"> | number
    motorista_id?: IntWithAggregatesFilter<"Veiculos"> | number
    modelo?: StringWithAggregatesFilter<"Veiculos"> | string
    placa?: StringWithAggregatesFilter<"Veiculos"> | string
    ano?: IntWithAggregatesFilter<"Veiculos"> | number
    categoria?: Enumenum_Veiculos_categoriaNullableWithAggregatesFilter<"Veiculos"> | $Enums.enum_Veiculos_categoria | null
    createdAt?: DateTimeWithAggregatesFilter<"Veiculos"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Veiculos"> | Date | string
  }

  export type agenda_corridasWhereInput = {
    AND?: agenda_corridasWhereInput | agenda_corridasWhereInput[]
    OR?: agenda_corridasWhereInput[]
    NOT?: agenda_corridasWhereInput | agenda_corridasWhereInput[]
    id?: IntFilter<"agenda_corridas"> | number
    passageiro_id?: IntFilter<"agenda_corridas"> | number
    categoria?: Enumenum_agenda_corridas_categoriaFilter<"agenda_corridas"> | $Enums.enum_agenda_corridas_categoria
    endereco_origem?: StringFilter<"agenda_corridas"> | string
    endereco_destino?: StringFilter<"agenda_corridas"> | string
    data_hora?: DateTimeFilter<"agenda_corridas"> | Date | string
    status?: Enumenum_agenda_corridas_statusNullableFilter<"agenda_corridas"> | $Enums.enum_agenda_corridas_status | null
    motorista_id?: IntNullableFilter<"agenda_corridas"> | number | null
    valor_previsto?: FloatNullableFilter<"agenda_corridas"> | number | null
    createdAt?: DateTimeFilter<"agenda_corridas"> | Date | string
    updatedAt?: DateTimeFilter<"agenda_corridas"> | Date | string
  }

  export type agenda_corridasOrderByWithRelationInput = {
    id?: SortOrder
    passageiro_id?: SortOrder
    categoria?: SortOrder
    endereco_origem?: SortOrder
    endereco_destino?: SortOrder
    data_hora?: SortOrder
    status?: SortOrderInput | SortOrder
    motorista_id?: SortOrderInput | SortOrder
    valor_previsto?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type agenda_corridasWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: agenda_corridasWhereInput | agenda_corridasWhereInput[]
    OR?: agenda_corridasWhereInput[]
    NOT?: agenda_corridasWhereInput | agenda_corridasWhereInput[]
    passageiro_id?: IntFilter<"agenda_corridas"> | number
    categoria?: Enumenum_agenda_corridas_categoriaFilter<"agenda_corridas"> | $Enums.enum_agenda_corridas_categoria
    endereco_origem?: StringFilter<"agenda_corridas"> | string
    endereco_destino?: StringFilter<"agenda_corridas"> | string
    data_hora?: DateTimeFilter<"agenda_corridas"> | Date | string
    status?: Enumenum_agenda_corridas_statusNullableFilter<"agenda_corridas"> | $Enums.enum_agenda_corridas_status | null
    motorista_id?: IntNullableFilter<"agenda_corridas"> | number | null
    valor_previsto?: FloatNullableFilter<"agenda_corridas"> | number | null
    createdAt?: DateTimeFilter<"agenda_corridas"> | Date | string
    updatedAt?: DateTimeFilter<"agenda_corridas"> | Date | string
  }, "id">

  export type agenda_corridasOrderByWithAggregationInput = {
    id?: SortOrder
    passageiro_id?: SortOrder
    categoria?: SortOrder
    endereco_origem?: SortOrder
    endereco_destino?: SortOrder
    data_hora?: SortOrder
    status?: SortOrderInput | SortOrder
    motorista_id?: SortOrderInput | SortOrder
    valor_previsto?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: agenda_corridasCountOrderByAggregateInput
    _avg?: agenda_corridasAvgOrderByAggregateInput
    _max?: agenda_corridasMaxOrderByAggregateInput
    _min?: agenda_corridasMinOrderByAggregateInput
    _sum?: agenda_corridasSumOrderByAggregateInput
  }

  export type agenda_corridasScalarWhereWithAggregatesInput = {
    AND?: agenda_corridasScalarWhereWithAggregatesInput | agenda_corridasScalarWhereWithAggregatesInput[]
    OR?: agenda_corridasScalarWhereWithAggregatesInput[]
    NOT?: agenda_corridasScalarWhereWithAggregatesInput | agenda_corridasScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"agenda_corridas"> | number
    passageiro_id?: IntWithAggregatesFilter<"agenda_corridas"> | number
    categoria?: Enumenum_agenda_corridas_categoriaWithAggregatesFilter<"agenda_corridas"> | $Enums.enum_agenda_corridas_categoria
    endereco_origem?: StringWithAggregatesFilter<"agenda_corridas"> | string
    endereco_destino?: StringWithAggregatesFilter<"agenda_corridas"> | string
    data_hora?: DateTimeWithAggregatesFilter<"agenda_corridas"> | Date | string
    status?: Enumenum_agenda_corridas_statusNullableWithAggregatesFilter<"agenda_corridas"> | $Enums.enum_agenda_corridas_status | null
    motorista_id?: IntNullableWithAggregatesFilter<"agenda_corridas"> | number | null
    valor_previsto?: FloatNullableWithAggregatesFilter<"agenda_corridas"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"agenda_corridas"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"agenda_corridas"> | Date | string
  }

  export type avaliacoesWhereInput = {
    AND?: avaliacoesWhereInput | avaliacoesWhereInput[]
    OR?: avaliacoesWhereInput[]
    NOT?: avaliacoesWhereInput | avaliacoesWhereInput[]
    id?: IntFilter<"avaliacoes"> | number
    avaliador_id?: IntFilter<"avaliacoes"> | number
    avaliado_id?: IntFilter<"avaliacoes"> | number
    tipo?: Enumenum_avaliacoes_tipoFilter<"avaliacoes"> | $Enums.enum_avaliacoes_tipo
    nota?: FloatFilter<"avaliacoes"> | number
    comentario?: StringNullableFilter<"avaliacoes"> | string | null
    createdAt?: DateTimeFilter<"avaliacoes"> | Date | string
    updatedAt?: DateTimeFilter<"avaliacoes"> | Date | string
  }

  export type avaliacoesOrderByWithRelationInput = {
    id?: SortOrder
    avaliador_id?: SortOrder
    avaliado_id?: SortOrder
    tipo?: SortOrder
    nota?: SortOrder
    comentario?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type avaliacoesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: avaliacoesWhereInput | avaliacoesWhereInput[]
    OR?: avaliacoesWhereInput[]
    NOT?: avaliacoesWhereInput | avaliacoesWhereInput[]
    avaliador_id?: IntFilter<"avaliacoes"> | number
    avaliado_id?: IntFilter<"avaliacoes"> | number
    tipo?: Enumenum_avaliacoes_tipoFilter<"avaliacoes"> | $Enums.enum_avaliacoes_tipo
    nota?: FloatFilter<"avaliacoes"> | number
    comentario?: StringNullableFilter<"avaliacoes"> | string | null
    createdAt?: DateTimeFilter<"avaliacoes"> | Date | string
    updatedAt?: DateTimeFilter<"avaliacoes"> | Date | string
  }, "id">

  export type avaliacoesOrderByWithAggregationInput = {
    id?: SortOrder
    avaliador_id?: SortOrder
    avaliado_id?: SortOrder
    tipo?: SortOrder
    nota?: SortOrder
    comentario?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: avaliacoesCountOrderByAggregateInput
    _avg?: avaliacoesAvgOrderByAggregateInput
    _max?: avaliacoesMaxOrderByAggregateInput
    _min?: avaliacoesMinOrderByAggregateInput
    _sum?: avaliacoesSumOrderByAggregateInput
  }

  export type avaliacoesScalarWhereWithAggregatesInput = {
    AND?: avaliacoesScalarWhereWithAggregatesInput | avaliacoesScalarWhereWithAggregatesInput[]
    OR?: avaliacoesScalarWhereWithAggregatesInput[]
    NOT?: avaliacoesScalarWhereWithAggregatesInput | avaliacoesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"avaliacoes"> | number
    avaliador_id?: IntWithAggregatesFilter<"avaliacoes"> | number
    avaliado_id?: IntWithAggregatesFilter<"avaliacoes"> | number
    tipo?: Enumenum_avaliacoes_tipoWithAggregatesFilter<"avaliacoes"> | $Enums.enum_avaliacoes_tipo
    nota?: FloatWithAggregatesFilter<"avaliacoes"> | number
    comentario?: StringNullableWithAggregatesFilter<"avaliacoes"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"avaliacoes"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"avaliacoes"> | Date | string
  }

  export type bairros_prioridadeWhereInput = {
    AND?: bairros_prioridadeWhereInput | bairros_prioridadeWhereInput[]
    OR?: bairros_prioridadeWhereInput[]
    NOT?: bairros_prioridadeWhereInput | bairros_prioridadeWhereInput[]
    id?: IntFilter<"bairros_prioridade"> | number
    nome?: StringFilter<"bairros_prioridade"> | string
    cidade?: StringFilter<"bairros_prioridade"> | string
    estado?: StringFilter<"bairros_prioridade"> | string
    ativo?: BoolNullableFilter<"bairros_prioridade"> | boolean | null
    tipo_prioridade?: Enumenum_bairros_prioridade_tipo_prioridadeFilter<"bairros_prioridade"> | $Enums.enum_bairros_prioridade_tipo_prioridade
    observacoes?: StringNullableFilter<"bairros_prioridade"> | string | null
    createdAt?: DateTimeFilter<"bairros_prioridade"> | Date | string
    updatedAt?: DateTimeFilter<"bairros_prioridade"> | Date | string
  }

  export type bairros_prioridadeOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    cidade?: SortOrder
    estado?: SortOrder
    ativo?: SortOrderInput | SortOrder
    tipo_prioridade?: SortOrder
    observacoes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type bairros_prioridadeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: bairros_prioridadeWhereInput | bairros_prioridadeWhereInput[]
    OR?: bairros_prioridadeWhereInput[]
    NOT?: bairros_prioridadeWhereInput | bairros_prioridadeWhereInput[]
    nome?: StringFilter<"bairros_prioridade"> | string
    cidade?: StringFilter<"bairros_prioridade"> | string
    estado?: StringFilter<"bairros_prioridade"> | string
    ativo?: BoolNullableFilter<"bairros_prioridade"> | boolean | null
    tipo_prioridade?: Enumenum_bairros_prioridade_tipo_prioridadeFilter<"bairros_prioridade"> | $Enums.enum_bairros_prioridade_tipo_prioridade
    observacoes?: StringNullableFilter<"bairros_prioridade"> | string | null
    createdAt?: DateTimeFilter<"bairros_prioridade"> | Date | string
    updatedAt?: DateTimeFilter<"bairros_prioridade"> | Date | string
  }, "id">

  export type bairros_prioridadeOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    cidade?: SortOrder
    estado?: SortOrder
    ativo?: SortOrderInput | SortOrder
    tipo_prioridade?: SortOrder
    observacoes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: bairros_prioridadeCountOrderByAggregateInput
    _avg?: bairros_prioridadeAvgOrderByAggregateInput
    _max?: bairros_prioridadeMaxOrderByAggregateInput
    _min?: bairros_prioridadeMinOrderByAggregateInput
    _sum?: bairros_prioridadeSumOrderByAggregateInput
  }

  export type bairros_prioridadeScalarWhereWithAggregatesInput = {
    AND?: bairros_prioridadeScalarWhereWithAggregatesInput | bairros_prioridadeScalarWhereWithAggregatesInput[]
    OR?: bairros_prioridadeScalarWhereWithAggregatesInput[]
    NOT?: bairros_prioridadeScalarWhereWithAggregatesInput | bairros_prioridadeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"bairros_prioridade"> | number
    nome?: StringWithAggregatesFilter<"bairros_prioridade"> | string
    cidade?: StringWithAggregatesFilter<"bairros_prioridade"> | string
    estado?: StringWithAggregatesFilter<"bairros_prioridade"> | string
    ativo?: BoolNullableWithAggregatesFilter<"bairros_prioridade"> | boolean | null
    tipo_prioridade?: Enumenum_bairros_prioridade_tipo_prioridadeWithAggregatesFilter<"bairros_prioridade"> | $Enums.enum_bairros_prioridade_tipo_prioridade
    observacoes?: StringNullableWithAggregatesFilter<"bairros_prioridade"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"bairros_prioridade"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"bairros_prioridade"> | Date | string
  }

  export type carteirasWhereInput = {
    AND?: carteirasWhereInput | carteirasWhereInput[]
    OR?: carteirasWhereInput[]
    NOT?: carteirasWhereInput | carteirasWhereInput[]
    id?: IntFilter<"carteiras"> | number
    usuario_id?: IntFilter<"carteiras"> | number
    tipo?: Enumenum_carteiras_tipoFilter<"carteiras"> | $Enums.enum_carteiras_tipo
    saldo?: FloatFilter<"carteiras"> | number
    ultima_atualizacao?: DateTimeNullableFilter<"carteiras"> | Date | string | null
    createdAt?: DateTimeFilter<"carteiras"> | Date | string
    updatedAt?: DateTimeFilter<"carteiras"> | Date | string
  }

  export type carteirasOrderByWithRelationInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    tipo?: SortOrder
    saldo?: SortOrder
    ultima_atualizacao?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type carteirasWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: carteirasWhereInput | carteirasWhereInput[]
    OR?: carteirasWhereInput[]
    NOT?: carteirasWhereInput | carteirasWhereInput[]
    usuario_id?: IntFilter<"carteiras"> | number
    tipo?: Enumenum_carteiras_tipoFilter<"carteiras"> | $Enums.enum_carteiras_tipo
    saldo?: FloatFilter<"carteiras"> | number
    ultima_atualizacao?: DateTimeNullableFilter<"carteiras"> | Date | string | null
    createdAt?: DateTimeFilter<"carteiras"> | Date | string
    updatedAt?: DateTimeFilter<"carteiras"> | Date | string
  }, "id">

  export type carteirasOrderByWithAggregationInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    tipo?: SortOrder
    saldo?: SortOrder
    ultima_atualizacao?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: carteirasCountOrderByAggregateInput
    _avg?: carteirasAvgOrderByAggregateInput
    _max?: carteirasMaxOrderByAggregateInput
    _min?: carteirasMinOrderByAggregateInput
    _sum?: carteirasSumOrderByAggregateInput
  }

  export type carteirasScalarWhereWithAggregatesInput = {
    AND?: carteirasScalarWhereWithAggregatesInput | carteirasScalarWhereWithAggregatesInput[]
    OR?: carteirasScalarWhereWithAggregatesInput[]
    NOT?: carteirasScalarWhereWithAggregatesInput | carteirasScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"carteiras"> | number
    usuario_id?: IntWithAggregatesFilter<"carteiras"> | number
    tipo?: Enumenum_carteiras_tipoWithAggregatesFilter<"carteiras"> | $Enums.enum_carteiras_tipo
    saldo?: FloatWithAggregatesFilter<"carteiras"> | number
    ultima_atualizacao?: DateTimeNullableWithAggregatesFilter<"carteiras"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"carteiras"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"carteiras"> | Date | string
  }

  export type corridasWhereInput = {
    AND?: corridasWhereInput | corridasWhereInput[]
    OR?: corridasWhereInput[]
    NOT?: corridasWhereInput | corridasWhereInput[]
    id?: IntFilter<"corridas"> | number
    id_motorista?: IntFilter<"corridas"> | number
    id_passageiro?: IntFilter<"corridas"> | number
    origem?: StringFilter<"corridas"> | string
    destino?: StringFilter<"corridas"> | string
    status?: Enumenum_corridas_statusNullableFilter<"corridas"> | $Enums.enum_corridas_status | null
    distancia_km?: FloatFilter<"corridas"> | number
    valor_total?: FloatFilter<"corridas"> | number
    forma_pagamento?: Enumenum_corridas_forma_pagamentoFilter<"corridas"> | $Enums.enum_corridas_forma_pagamento
    data_hora?: DateTimeNullableFilter<"corridas"> | Date | string | null
    createdAt?: DateTimeFilter<"corridas"> | Date | string
    updatedAt?: DateTimeFilter<"corridas"> | Date | string
  }

  export type corridasOrderByWithRelationInput = {
    id?: SortOrder
    id_motorista?: SortOrder
    id_passageiro?: SortOrder
    origem?: SortOrder
    destino?: SortOrder
    status?: SortOrderInput | SortOrder
    distancia_km?: SortOrder
    valor_total?: SortOrder
    forma_pagamento?: SortOrder
    data_hora?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type corridasWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: corridasWhereInput | corridasWhereInput[]
    OR?: corridasWhereInput[]
    NOT?: corridasWhereInput | corridasWhereInput[]
    id_motorista?: IntFilter<"corridas"> | number
    id_passageiro?: IntFilter<"corridas"> | number
    origem?: StringFilter<"corridas"> | string
    destino?: StringFilter<"corridas"> | string
    status?: Enumenum_corridas_statusNullableFilter<"corridas"> | $Enums.enum_corridas_status | null
    distancia_km?: FloatFilter<"corridas"> | number
    valor_total?: FloatFilter<"corridas"> | number
    forma_pagamento?: Enumenum_corridas_forma_pagamentoFilter<"corridas"> | $Enums.enum_corridas_forma_pagamento
    data_hora?: DateTimeNullableFilter<"corridas"> | Date | string | null
    createdAt?: DateTimeFilter<"corridas"> | Date | string
    updatedAt?: DateTimeFilter<"corridas"> | Date | string
  }, "id">

  export type corridasOrderByWithAggregationInput = {
    id?: SortOrder
    id_motorista?: SortOrder
    id_passageiro?: SortOrder
    origem?: SortOrder
    destino?: SortOrder
    status?: SortOrderInput | SortOrder
    distancia_km?: SortOrder
    valor_total?: SortOrder
    forma_pagamento?: SortOrder
    data_hora?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: corridasCountOrderByAggregateInput
    _avg?: corridasAvgOrderByAggregateInput
    _max?: corridasMaxOrderByAggregateInput
    _min?: corridasMinOrderByAggregateInput
    _sum?: corridasSumOrderByAggregateInput
  }

  export type corridasScalarWhereWithAggregatesInput = {
    AND?: corridasScalarWhereWithAggregatesInput | corridasScalarWhereWithAggregatesInput[]
    OR?: corridasScalarWhereWithAggregatesInput[]
    NOT?: corridasScalarWhereWithAggregatesInput | corridasScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"corridas"> | number
    id_motorista?: IntWithAggregatesFilter<"corridas"> | number
    id_passageiro?: IntWithAggregatesFilter<"corridas"> | number
    origem?: StringWithAggregatesFilter<"corridas"> | string
    destino?: StringWithAggregatesFilter<"corridas"> | string
    status?: Enumenum_corridas_statusNullableWithAggregatesFilter<"corridas"> | $Enums.enum_corridas_status | null
    distancia_km?: FloatWithAggregatesFilter<"corridas"> | number
    valor_total?: FloatWithAggregatesFilter<"corridas"> | number
    forma_pagamento?: Enumenum_corridas_forma_pagamentoWithAggregatesFilter<"corridas"> | $Enums.enum_corridas_forma_pagamento
    data_hora?: DateTimeNullableWithAggregatesFilter<"corridas"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"corridas"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"corridas"> | Date | string
  }

  export type denunciasWhereInput = {
    AND?: denunciasWhereInput | denunciasWhereInput[]
    OR?: denunciasWhereInput[]
    NOT?: denunciasWhereInput | denunciasWhereInput[]
    id?: IntFilter<"denuncias"> | number
    autor_id?: IntFilter<"denuncias"> | number
    alvo_id?: IntFilter<"denuncias"> | number
    tipo_alvo?: Enumenum_denuncias_tipo_alvoFilter<"denuncias"> | $Enums.enum_denuncias_tipo_alvo
    corrida_id?: IntNullableFilter<"denuncias"> | number | null
    motivo?: StringFilter<"denuncias"> | string
    descricao?: StringNullableFilter<"denuncias"> | string | null
    status?: Enumenum_denuncias_statusNullableFilter<"denuncias"> | $Enums.enum_denuncias_status | null
    data_denuncia?: DateTimeNullableFilter<"denuncias"> | Date | string | null
    createdAt?: DateTimeFilter<"denuncias"> | Date | string
    updatedAt?: DateTimeFilter<"denuncias"> | Date | string
  }

  export type denunciasOrderByWithRelationInput = {
    id?: SortOrder
    autor_id?: SortOrder
    alvo_id?: SortOrder
    tipo_alvo?: SortOrder
    corrida_id?: SortOrderInput | SortOrder
    motivo?: SortOrder
    descricao?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    data_denuncia?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type denunciasWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: denunciasWhereInput | denunciasWhereInput[]
    OR?: denunciasWhereInput[]
    NOT?: denunciasWhereInput | denunciasWhereInput[]
    autor_id?: IntFilter<"denuncias"> | number
    alvo_id?: IntFilter<"denuncias"> | number
    tipo_alvo?: Enumenum_denuncias_tipo_alvoFilter<"denuncias"> | $Enums.enum_denuncias_tipo_alvo
    corrida_id?: IntNullableFilter<"denuncias"> | number | null
    motivo?: StringFilter<"denuncias"> | string
    descricao?: StringNullableFilter<"denuncias"> | string | null
    status?: Enumenum_denuncias_statusNullableFilter<"denuncias"> | $Enums.enum_denuncias_status | null
    data_denuncia?: DateTimeNullableFilter<"denuncias"> | Date | string | null
    createdAt?: DateTimeFilter<"denuncias"> | Date | string
    updatedAt?: DateTimeFilter<"denuncias"> | Date | string
  }, "id">

  export type denunciasOrderByWithAggregationInput = {
    id?: SortOrder
    autor_id?: SortOrder
    alvo_id?: SortOrder
    tipo_alvo?: SortOrder
    corrida_id?: SortOrderInput | SortOrder
    motivo?: SortOrder
    descricao?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    data_denuncia?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: denunciasCountOrderByAggregateInput
    _avg?: denunciasAvgOrderByAggregateInput
    _max?: denunciasMaxOrderByAggregateInput
    _min?: denunciasMinOrderByAggregateInput
    _sum?: denunciasSumOrderByAggregateInput
  }

  export type denunciasScalarWhereWithAggregatesInput = {
    AND?: denunciasScalarWhereWithAggregatesInput | denunciasScalarWhereWithAggregatesInput[]
    OR?: denunciasScalarWhereWithAggregatesInput[]
    NOT?: denunciasScalarWhereWithAggregatesInput | denunciasScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"denuncias"> | number
    autor_id?: IntWithAggregatesFilter<"denuncias"> | number
    alvo_id?: IntWithAggregatesFilter<"denuncias"> | number
    tipo_alvo?: Enumenum_denuncias_tipo_alvoWithAggregatesFilter<"denuncias"> | $Enums.enum_denuncias_tipo_alvo
    corrida_id?: IntNullableWithAggregatesFilter<"denuncias"> | number | null
    motivo?: StringWithAggregatesFilter<"denuncias"> | string
    descricao?: StringNullableWithAggregatesFilter<"denuncias"> | string | null
    status?: Enumenum_denuncias_statusNullableWithAggregatesFilter<"denuncias"> | $Enums.enum_denuncias_status | null
    data_denuncia?: DateTimeNullableWithAggregatesFilter<"denuncias"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"denuncias"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"denuncias"> | Date | string
  }

  export type documentosWhereInput = {
    AND?: documentosWhereInput | documentosWhereInput[]
    OR?: documentosWhereInput[]
    NOT?: documentosWhereInput | documentosWhereInput[]
    id?: IntFilter<"documentos"> | number
    usuario_id?: IntFilter<"documentos"> | number
    tipo_documento?: Enumenum_documentos_tipo_documentoFilter<"documentos"> | $Enums.enum_documentos_tipo_documento
    arquivo_url?: StringFilter<"documentos"> | string
    status?: Enumenum_documentos_statusNullableFilter<"documentos"> | $Enums.enum_documentos_status | null
    motivo_rejeicao?: StringNullableFilter<"documentos"> | string | null
    data_envio?: DateTimeNullableFilter<"documentos"> | Date | string | null
    createdAt?: DateTimeFilter<"documentos"> | Date | string
    updatedAt?: DateTimeFilter<"documentos"> | Date | string
  }

  export type documentosOrderByWithRelationInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    tipo_documento?: SortOrder
    arquivo_url?: SortOrder
    status?: SortOrderInput | SortOrder
    motivo_rejeicao?: SortOrderInput | SortOrder
    data_envio?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type documentosWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: documentosWhereInput | documentosWhereInput[]
    OR?: documentosWhereInput[]
    NOT?: documentosWhereInput | documentosWhereInput[]
    usuario_id?: IntFilter<"documentos"> | number
    tipo_documento?: Enumenum_documentos_tipo_documentoFilter<"documentos"> | $Enums.enum_documentos_tipo_documento
    arquivo_url?: StringFilter<"documentos"> | string
    status?: Enumenum_documentos_statusNullableFilter<"documentos"> | $Enums.enum_documentos_status | null
    motivo_rejeicao?: StringNullableFilter<"documentos"> | string | null
    data_envio?: DateTimeNullableFilter<"documentos"> | Date | string | null
    createdAt?: DateTimeFilter<"documentos"> | Date | string
    updatedAt?: DateTimeFilter<"documentos"> | Date | string
  }, "id">

  export type documentosOrderByWithAggregationInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    tipo_documento?: SortOrder
    arquivo_url?: SortOrder
    status?: SortOrderInput | SortOrder
    motivo_rejeicao?: SortOrderInput | SortOrder
    data_envio?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: documentosCountOrderByAggregateInput
    _avg?: documentosAvgOrderByAggregateInput
    _max?: documentosMaxOrderByAggregateInput
    _min?: documentosMinOrderByAggregateInput
    _sum?: documentosSumOrderByAggregateInput
  }

  export type documentosScalarWhereWithAggregatesInput = {
    AND?: documentosScalarWhereWithAggregatesInput | documentosScalarWhereWithAggregatesInput[]
    OR?: documentosScalarWhereWithAggregatesInput[]
    NOT?: documentosScalarWhereWithAggregatesInput | documentosScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"documentos"> | number
    usuario_id?: IntWithAggregatesFilter<"documentos"> | number
    tipo_documento?: Enumenum_documentos_tipo_documentoWithAggregatesFilter<"documentos"> | $Enums.enum_documentos_tipo_documento
    arquivo_url?: StringWithAggregatesFilter<"documentos"> | string
    status?: Enumenum_documentos_statusNullableWithAggregatesFilter<"documentos"> | $Enums.enum_documentos_status | null
    motivo_rejeicao?: StringNullableWithAggregatesFilter<"documentos"> | string | null
    data_envio?: DateTimeNullableWithAggregatesFilter<"documentos"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"documentos"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"documentos"> | Date | string
  }

  export type emails_enviadosWhereInput = {
    AND?: emails_enviadosWhereInput | emails_enviadosWhereInput[]
    OR?: emails_enviadosWhereInput[]
    NOT?: emails_enviadosWhereInput | emails_enviadosWhereInput[]
    id?: IntFilter<"emails_enviados"> | number
    usuario_id?: IntFilter<"emails_enviados"> | number
    email?: StringFilter<"emails_enviados"> | string
    tipo?: Enumenum_emails_enviados_tipoFilter<"emails_enviados"> | $Enums.enum_emails_enviados_tipo
    titulo?: StringFilter<"emails_enviados"> | string
    conteudo?: StringNullableFilter<"emails_enviados"> | string | null
    status_envio?: Enumenum_emails_enviados_status_envioNullableFilter<"emails_enviados"> | $Enums.enum_emails_enviados_status_envio | null
    data_envio?: DateTimeNullableFilter<"emails_enviados"> | Date | string | null
    createdAt?: DateTimeFilter<"emails_enviados"> | Date | string
    updatedAt?: DateTimeFilter<"emails_enviados"> | Date | string
  }

  export type emails_enviadosOrderByWithRelationInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    email?: SortOrder
    tipo?: SortOrder
    titulo?: SortOrder
    conteudo?: SortOrderInput | SortOrder
    status_envio?: SortOrderInput | SortOrder
    data_envio?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type emails_enviadosWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: emails_enviadosWhereInput | emails_enviadosWhereInput[]
    OR?: emails_enviadosWhereInput[]
    NOT?: emails_enviadosWhereInput | emails_enviadosWhereInput[]
    usuario_id?: IntFilter<"emails_enviados"> | number
    email?: StringFilter<"emails_enviados"> | string
    tipo?: Enumenum_emails_enviados_tipoFilter<"emails_enviados"> | $Enums.enum_emails_enviados_tipo
    titulo?: StringFilter<"emails_enviados"> | string
    conteudo?: StringNullableFilter<"emails_enviados"> | string | null
    status_envio?: Enumenum_emails_enviados_status_envioNullableFilter<"emails_enviados"> | $Enums.enum_emails_enviados_status_envio | null
    data_envio?: DateTimeNullableFilter<"emails_enviados"> | Date | string | null
    createdAt?: DateTimeFilter<"emails_enviados"> | Date | string
    updatedAt?: DateTimeFilter<"emails_enviados"> | Date | string
  }, "id">

  export type emails_enviadosOrderByWithAggregationInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    email?: SortOrder
    tipo?: SortOrder
    titulo?: SortOrder
    conteudo?: SortOrderInput | SortOrder
    status_envio?: SortOrderInput | SortOrder
    data_envio?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: emails_enviadosCountOrderByAggregateInput
    _avg?: emails_enviadosAvgOrderByAggregateInput
    _max?: emails_enviadosMaxOrderByAggregateInput
    _min?: emails_enviadosMinOrderByAggregateInput
    _sum?: emails_enviadosSumOrderByAggregateInput
  }

  export type emails_enviadosScalarWhereWithAggregatesInput = {
    AND?: emails_enviadosScalarWhereWithAggregatesInput | emails_enviadosScalarWhereWithAggregatesInput[]
    OR?: emails_enviadosScalarWhereWithAggregatesInput[]
    NOT?: emails_enviadosScalarWhereWithAggregatesInput | emails_enviadosScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"emails_enviados"> | number
    usuario_id?: IntWithAggregatesFilter<"emails_enviados"> | number
    email?: StringWithAggregatesFilter<"emails_enviados"> | string
    tipo?: Enumenum_emails_enviados_tipoWithAggregatesFilter<"emails_enviados"> | $Enums.enum_emails_enviados_tipo
    titulo?: StringWithAggregatesFilter<"emails_enviados"> | string
    conteudo?: StringNullableWithAggregatesFilter<"emails_enviados"> | string | null
    status_envio?: Enumenum_emails_enviados_status_envioNullableWithAggregatesFilter<"emails_enviados"> | $Enums.enum_emails_enviados_status_envio | null
    data_envio?: DateTimeNullableWithAggregatesFilter<"emails_enviados"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"emails_enviados"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"emails_enviados"> | Date | string
  }

  export type historico_indicacoesWhereInput = {
    AND?: historico_indicacoesWhereInput | historico_indicacoesWhereInput[]
    OR?: historico_indicacoesWhereInput[]
    NOT?: historico_indicacoesWhereInput | historico_indicacoesWhereInput[]
    id?: IntFilter<"historico_indicacoes"> | number
    indicador_id?: IntFilter<"historico_indicacoes"> | number
    indicado_id?: IntFilter<"historico_indicacoes"> | number
    tipo?: Enumenum_historico_indicacoes_tipoFilter<"historico_indicacoes"> | $Enums.enum_historico_indicacoes_tipo
    data_vinculo?: DateTimeNullableFilter<"historico_indicacoes"> | Date | string | null
    codigo_utilizado?: StringNullableFilter<"historico_indicacoes"> | string | null
    ativo?: BoolNullableFilter<"historico_indicacoes"> | boolean | null
    createdAt?: DateTimeFilter<"historico_indicacoes"> | Date | string
    updatedAt?: DateTimeFilter<"historico_indicacoes"> | Date | string
  }

  export type historico_indicacoesOrderByWithRelationInput = {
    id?: SortOrder
    indicador_id?: SortOrder
    indicado_id?: SortOrder
    tipo?: SortOrder
    data_vinculo?: SortOrderInput | SortOrder
    codigo_utilizado?: SortOrderInput | SortOrder
    ativo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type historico_indicacoesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: historico_indicacoesWhereInput | historico_indicacoesWhereInput[]
    OR?: historico_indicacoesWhereInput[]
    NOT?: historico_indicacoesWhereInput | historico_indicacoesWhereInput[]
    indicador_id?: IntFilter<"historico_indicacoes"> | number
    indicado_id?: IntFilter<"historico_indicacoes"> | number
    tipo?: Enumenum_historico_indicacoes_tipoFilter<"historico_indicacoes"> | $Enums.enum_historico_indicacoes_tipo
    data_vinculo?: DateTimeNullableFilter<"historico_indicacoes"> | Date | string | null
    codigo_utilizado?: StringNullableFilter<"historico_indicacoes"> | string | null
    ativo?: BoolNullableFilter<"historico_indicacoes"> | boolean | null
    createdAt?: DateTimeFilter<"historico_indicacoes"> | Date | string
    updatedAt?: DateTimeFilter<"historico_indicacoes"> | Date | string
  }, "id">

  export type historico_indicacoesOrderByWithAggregationInput = {
    id?: SortOrder
    indicador_id?: SortOrder
    indicado_id?: SortOrder
    tipo?: SortOrder
    data_vinculo?: SortOrderInput | SortOrder
    codigo_utilizado?: SortOrderInput | SortOrder
    ativo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: historico_indicacoesCountOrderByAggregateInput
    _avg?: historico_indicacoesAvgOrderByAggregateInput
    _max?: historico_indicacoesMaxOrderByAggregateInput
    _min?: historico_indicacoesMinOrderByAggregateInput
    _sum?: historico_indicacoesSumOrderByAggregateInput
  }

  export type historico_indicacoesScalarWhereWithAggregatesInput = {
    AND?: historico_indicacoesScalarWhereWithAggregatesInput | historico_indicacoesScalarWhereWithAggregatesInput[]
    OR?: historico_indicacoesScalarWhereWithAggregatesInput[]
    NOT?: historico_indicacoesScalarWhereWithAggregatesInput | historico_indicacoesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"historico_indicacoes"> | number
    indicador_id?: IntWithAggregatesFilter<"historico_indicacoes"> | number
    indicado_id?: IntWithAggregatesFilter<"historico_indicacoes"> | number
    tipo?: Enumenum_historico_indicacoes_tipoWithAggregatesFilter<"historico_indicacoes"> | $Enums.enum_historico_indicacoes_tipo
    data_vinculo?: DateTimeNullableWithAggregatesFilter<"historico_indicacoes"> | Date | string | null
    codigo_utilizado?: StringNullableWithAggregatesFilter<"historico_indicacoes"> | string | null
    ativo?: BoolNullableWithAggregatesFilter<"historico_indicacoes"> | boolean | null
    createdAt?: DateTimeWithAggregatesFilter<"historico_indicacoes"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"historico_indicacoes"> | Date | string
  }

  export type historico_selfiesWhereInput = {
    AND?: historico_selfiesWhereInput | historico_selfiesWhereInput[]
    OR?: historico_selfiesWhereInput[]
    NOT?: historico_selfiesWhereInput | historico_selfiesWhereInput[]
    id?: IntFilter<"historico_selfies"> | number
    usuario_id?: IntFilter<"historico_selfies"> | number
    tipo?: Enumenum_historico_selfies_tipoFilter<"historico_selfies"> | $Enums.enum_historico_selfies_tipo
    imagem_url?: StringFilter<"historico_selfies"> | string
    resultado?: Enumenum_historico_selfies_resultadoNullableFilter<"historico_selfies"> | $Enums.enum_historico_selfies_resultado | null
    motivo_falha?: StringNullableFilter<"historico_selfies"> | string | null
    data_envio?: DateTimeNullableFilter<"historico_selfies"> | Date | string | null
    createdAt?: DateTimeFilter<"historico_selfies"> | Date | string
    updatedAt?: DateTimeFilter<"historico_selfies"> | Date | string
  }

  export type historico_selfiesOrderByWithRelationInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    tipo?: SortOrder
    imagem_url?: SortOrder
    resultado?: SortOrderInput | SortOrder
    motivo_falha?: SortOrderInput | SortOrder
    data_envio?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type historico_selfiesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: historico_selfiesWhereInput | historico_selfiesWhereInput[]
    OR?: historico_selfiesWhereInput[]
    NOT?: historico_selfiesWhereInput | historico_selfiesWhereInput[]
    usuario_id?: IntFilter<"historico_selfies"> | number
    tipo?: Enumenum_historico_selfies_tipoFilter<"historico_selfies"> | $Enums.enum_historico_selfies_tipo
    imagem_url?: StringFilter<"historico_selfies"> | string
    resultado?: Enumenum_historico_selfies_resultadoNullableFilter<"historico_selfies"> | $Enums.enum_historico_selfies_resultado | null
    motivo_falha?: StringNullableFilter<"historico_selfies"> | string | null
    data_envio?: DateTimeNullableFilter<"historico_selfies"> | Date | string | null
    createdAt?: DateTimeFilter<"historico_selfies"> | Date | string
    updatedAt?: DateTimeFilter<"historico_selfies"> | Date | string
  }, "id">

  export type historico_selfiesOrderByWithAggregationInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    tipo?: SortOrder
    imagem_url?: SortOrder
    resultado?: SortOrderInput | SortOrder
    motivo_falha?: SortOrderInput | SortOrder
    data_envio?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: historico_selfiesCountOrderByAggregateInput
    _avg?: historico_selfiesAvgOrderByAggregateInput
    _max?: historico_selfiesMaxOrderByAggregateInput
    _min?: historico_selfiesMinOrderByAggregateInput
    _sum?: historico_selfiesSumOrderByAggregateInput
  }

  export type historico_selfiesScalarWhereWithAggregatesInput = {
    AND?: historico_selfiesScalarWhereWithAggregatesInput | historico_selfiesScalarWhereWithAggregatesInput[]
    OR?: historico_selfiesScalarWhereWithAggregatesInput[]
    NOT?: historico_selfiesScalarWhereWithAggregatesInput | historico_selfiesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"historico_selfies"> | number
    usuario_id?: IntWithAggregatesFilter<"historico_selfies"> | number
    tipo?: Enumenum_historico_selfies_tipoWithAggregatesFilter<"historico_selfies"> | $Enums.enum_historico_selfies_tipo
    imagem_url?: StringWithAggregatesFilter<"historico_selfies"> | string
    resultado?: Enumenum_historico_selfies_resultadoNullableWithAggregatesFilter<"historico_selfies"> | $Enums.enum_historico_selfies_resultado | null
    motivo_falha?: StringNullableWithAggregatesFilter<"historico_selfies"> | string | null
    data_envio?: DateTimeNullableWithAggregatesFilter<"historico_selfies"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"historico_selfies"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"historico_selfies"> | Date | string
  }

  export type logs_acessoWhereInput = {
    AND?: logs_acessoWhereInput | logs_acessoWhereInput[]
    OR?: logs_acessoWhereInput[]
    NOT?: logs_acessoWhereInput | logs_acessoWhereInput[]
    id?: IntFilter<"logs_acesso"> | number
    usuario_id?: IntFilter<"logs_acesso"> | number
    tipo_usuario?: Enumenum_logs_acesso_tipo_usuarioFilter<"logs_acesso"> | $Enums.enum_logs_acesso_tipo_usuario
    acao?: StringFilter<"logs_acesso"> | string
    descricao?: StringNullableFilter<"logs_acesso"> | string | null
    ip?: StringNullableFilter<"logs_acesso"> | string | null
    dispositivo?: StringNullableFilter<"logs_acesso"> | string | null
    data?: DateTimeNullableFilter<"logs_acesso"> | Date | string | null
    createdAt?: DateTimeFilter<"logs_acesso"> | Date | string
    updatedAt?: DateTimeFilter<"logs_acesso"> | Date | string
  }

  export type logs_acessoOrderByWithRelationInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    tipo_usuario?: SortOrder
    acao?: SortOrder
    descricao?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    dispositivo?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type logs_acessoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: logs_acessoWhereInput | logs_acessoWhereInput[]
    OR?: logs_acessoWhereInput[]
    NOT?: logs_acessoWhereInput | logs_acessoWhereInput[]
    usuario_id?: IntFilter<"logs_acesso"> | number
    tipo_usuario?: Enumenum_logs_acesso_tipo_usuarioFilter<"logs_acesso"> | $Enums.enum_logs_acesso_tipo_usuario
    acao?: StringFilter<"logs_acesso"> | string
    descricao?: StringNullableFilter<"logs_acesso"> | string | null
    ip?: StringNullableFilter<"logs_acesso"> | string | null
    dispositivo?: StringNullableFilter<"logs_acesso"> | string | null
    data?: DateTimeNullableFilter<"logs_acesso"> | Date | string | null
    createdAt?: DateTimeFilter<"logs_acesso"> | Date | string
    updatedAt?: DateTimeFilter<"logs_acesso"> | Date | string
  }, "id">

  export type logs_acessoOrderByWithAggregationInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    tipo_usuario?: SortOrder
    acao?: SortOrder
    descricao?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    dispositivo?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: logs_acessoCountOrderByAggregateInput
    _avg?: logs_acessoAvgOrderByAggregateInput
    _max?: logs_acessoMaxOrderByAggregateInput
    _min?: logs_acessoMinOrderByAggregateInput
    _sum?: logs_acessoSumOrderByAggregateInput
  }

  export type logs_acessoScalarWhereWithAggregatesInput = {
    AND?: logs_acessoScalarWhereWithAggregatesInput | logs_acessoScalarWhereWithAggregatesInput[]
    OR?: logs_acessoScalarWhereWithAggregatesInput[]
    NOT?: logs_acessoScalarWhereWithAggregatesInput | logs_acessoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"logs_acesso"> | number
    usuario_id?: IntWithAggregatesFilter<"logs_acesso"> | number
    tipo_usuario?: Enumenum_logs_acesso_tipo_usuarioWithAggregatesFilter<"logs_acesso"> | $Enums.enum_logs_acesso_tipo_usuario
    acao?: StringWithAggregatesFilter<"logs_acesso"> | string
    descricao?: StringNullableWithAggregatesFilter<"logs_acesso"> | string | null
    ip?: StringNullableWithAggregatesFilter<"logs_acesso"> | string | null
    dispositivo?: StringNullableWithAggregatesFilter<"logs_acesso"> | string | null
    data?: DateTimeNullableWithAggregatesFilter<"logs_acesso"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"logs_acesso"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"logs_acesso"> | Date | string
  }

  export type mensagens_suporteWhereInput = {
    AND?: mensagens_suporteWhereInput | mensagens_suporteWhereInput[]
    OR?: mensagens_suporteWhereInput[]
    NOT?: mensagens_suporteWhereInput | mensagens_suporteWhereInput[]
    id?: IntFilter<"mensagens_suporte"> | number
    usuario_id?: IntFilter<"mensagens_suporte"> | number
    tipo_usuario?: Enumenum_mensagens_suporte_tipo_usuarioFilter<"mensagens_suporte"> | $Enums.enum_mensagens_suporte_tipo_usuario
    mensagem?: StringFilter<"mensagens_suporte"> | string
    resposta_sistema?: BoolNullableFilter<"mensagens_suporte"> | boolean | null
    status?: Enumenum_mensagens_suporte_statusNullableFilter<"mensagens_suporte"> | $Enums.enum_mensagens_suporte_status | null
    data_envio?: DateTimeNullableFilter<"mensagens_suporte"> | Date | string | null
    createdAt?: DateTimeFilter<"mensagens_suporte"> | Date | string
    updatedAt?: DateTimeFilter<"mensagens_suporte"> | Date | string
  }

  export type mensagens_suporteOrderByWithRelationInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    tipo_usuario?: SortOrder
    mensagem?: SortOrder
    resposta_sistema?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    data_envio?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type mensagens_suporteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: mensagens_suporteWhereInput | mensagens_suporteWhereInput[]
    OR?: mensagens_suporteWhereInput[]
    NOT?: mensagens_suporteWhereInput | mensagens_suporteWhereInput[]
    usuario_id?: IntFilter<"mensagens_suporte"> | number
    tipo_usuario?: Enumenum_mensagens_suporte_tipo_usuarioFilter<"mensagens_suporte"> | $Enums.enum_mensagens_suporte_tipo_usuario
    mensagem?: StringFilter<"mensagens_suporte"> | string
    resposta_sistema?: BoolNullableFilter<"mensagens_suporte"> | boolean | null
    status?: Enumenum_mensagens_suporte_statusNullableFilter<"mensagens_suporte"> | $Enums.enum_mensagens_suporte_status | null
    data_envio?: DateTimeNullableFilter<"mensagens_suporte"> | Date | string | null
    createdAt?: DateTimeFilter<"mensagens_suporte"> | Date | string
    updatedAt?: DateTimeFilter<"mensagens_suporte"> | Date | string
  }, "id">

  export type mensagens_suporteOrderByWithAggregationInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    tipo_usuario?: SortOrder
    mensagem?: SortOrder
    resposta_sistema?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    data_envio?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: mensagens_suporteCountOrderByAggregateInput
    _avg?: mensagens_suporteAvgOrderByAggregateInput
    _max?: mensagens_suporteMaxOrderByAggregateInput
    _min?: mensagens_suporteMinOrderByAggregateInput
    _sum?: mensagens_suporteSumOrderByAggregateInput
  }

  export type mensagens_suporteScalarWhereWithAggregatesInput = {
    AND?: mensagens_suporteScalarWhereWithAggregatesInput | mensagens_suporteScalarWhereWithAggregatesInput[]
    OR?: mensagens_suporteScalarWhereWithAggregatesInput[]
    NOT?: mensagens_suporteScalarWhereWithAggregatesInput | mensagens_suporteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"mensagens_suporte"> | number
    usuario_id?: IntWithAggregatesFilter<"mensagens_suporte"> | number
    tipo_usuario?: Enumenum_mensagens_suporte_tipo_usuarioWithAggregatesFilter<"mensagens_suporte"> | $Enums.enum_mensagens_suporte_tipo_usuario
    mensagem?: StringWithAggregatesFilter<"mensagens_suporte"> | string
    resposta_sistema?: BoolNullableWithAggregatesFilter<"mensagens_suporte"> | boolean | null
    status?: Enumenum_mensagens_suporte_statusNullableWithAggregatesFilter<"mensagens_suporte"> | $Enums.enum_mensagens_suporte_status | null
    data_envio?: DateTimeNullableWithAggregatesFilter<"mensagens_suporte"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"mensagens_suporte"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"mensagens_suporte"> | Date | string
  }

  export type pagamentos_pessoaisWhereInput = {
    AND?: pagamentos_pessoaisWhereInput | pagamentos_pessoaisWhereInput[]
    OR?: pagamentos_pessoaisWhereInput[]
    NOT?: pagamentos_pessoaisWhereInput | pagamentos_pessoaisWhereInput[]
    id?: IntFilter<"pagamentos_pessoais"> | number
    motorista_id?: IntFilter<"pagamentos_pessoais"> | number
    passageiro_id?: IntFilter<"pagamentos_pessoais"> | number
    valor?: FloatFilter<"pagamentos_pessoais"> | number
    valor_maximo?: FloatFilter<"pagamentos_pessoais"> | number
    aceito_pelo_app?: BoolNullableFilter<"pagamentos_pessoais"> | boolean | null
    data_corrida?: DateTimeNullableFilter<"pagamentos_pessoais"> | Date | string | null
    createdAt?: DateTimeFilter<"pagamentos_pessoais"> | Date | string
    updatedAt?: DateTimeFilter<"pagamentos_pessoais"> | Date | string
  }

  export type pagamentos_pessoaisOrderByWithRelationInput = {
    id?: SortOrder
    motorista_id?: SortOrder
    passageiro_id?: SortOrder
    valor?: SortOrder
    valor_maximo?: SortOrder
    aceito_pelo_app?: SortOrderInput | SortOrder
    data_corrida?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type pagamentos_pessoaisWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: pagamentos_pessoaisWhereInput | pagamentos_pessoaisWhereInput[]
    OR?: pagamentos_pessoaisWhereInput[]
    NOT?: pagamentos_pessoaisWhereInput | pagamentos_pessoaisWhereInput[]
    motorista_id?: IntFilter<"pagamentos_pessoais"> | number
    passageiro_id?: IntFilter<"pagamentos_pessoais"> | number
    valor?: FloatFilter<"pagamentos_pessoais"> | number
    valor_maximo?: FloatFilter<"pagamentos_pessoais"> | number
    aceito_pelo_app?: BoolNullableFilter<"pagamentos_pessoais"> | boolean | null
    data_corrida?: DateTimeNullableFilter<"pagamentos_pessoais"> | Date | string | null
    createdAt?: DateTimeFilter<"pagamentos_pessoais"> | Date | string
    updatedAt?: DateTimeFilter<"pagamentos_pessoais"> | Date | string
  }, "id">

  export type pagamentos_pessoaisOrderByWithAggregationInput = {
    id?: SortOrder
    motorista_id?: SortOrder
    passageiro_id?: SortOrder
    valor?: SortOrder
    valor_maximo?: SortOrder
    aceito_pelo_app?: SortOrderInput | SortOrder
    data_corrida?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: pagamentos_pessoaisCountOrderByAggregateInput
    _avg?: pagamentos_pessoaisAvgOrderByAggregateInput
    _max?: pagamentos_pessoaisMaxOrderByAggregateInput
    _min?: pagamentos_pessoaisMinOrderByAggregateInput
    _sum?: pagamentos_pessoaisSumOrderByAggregateInput
  }

  export type pagamentos_pessoaisScalarWhereWithAggregatesInput = {
    AND?: pagamentos_pessoaisScalarWhereWithAggregatesInput | pagamentos_pessoaisScalarWhereWithAggregatesInput[]
    OR?: pagamentos_pessoaisScalarWhereWithAggregatesInput[]
    NOT?: pagamentos_pessoaisScalarWhereWithAggregatesInput | pagamentos_pessoaisScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"pagamentos_pessoais"> | number
    motorista_id?: IntWithAggregatesFilter<"pagamentos_pessoais"> | number
    passageiro_id?: IntWithAggregatesFilter<"pagamentos_pessoais"> | number
    valor?: FloatWithAggregatesFilter<"pagamentos_pessoais"> | number
    valor_maximo?: FloatWithAggregatesFilter<"pagamentos_pessoais"> | number
    aceito_pelo_app?: BoolNullableWithAggregatesFilter<"pagamentos_pessoais"> | boolean | null
    data_corrida?: DateTimeNullableWithAggregatesFilter<"pagamentos_pessoais"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"pagamentos_pessoais"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"pagamentos_pessoais"> | Date | string
  }

  export type paradasWhereInput = {
    AND?: paradasWhereInput | paradasWhereInput[]
    OR?: paradasWhereInput[]
    NOT?: paradasWhereInput | paradasWhereInput[]
    id?: IntFilter<"paradas"> | number
    corrida_id?: IntFilter<"paradas"> | number
    ordem?: IntFilter<"paradas"> | number
    endereco?: StringFilter<"paradas"> | string
    latitude?: FloatNullableFilter<"paradas"> | number | null
    longitude?: FloatNullableFilter<"paradas"> | number | null
    tempo_espera?: IntNullableFilter<"paradas"> | number | null
    createdAt?: DateTimeFilter<"paradas"> | Date | string
    updatedAt?: DateTimeFilter<"paradas"> | Date | string
  }

  export type paradasOrderByWithRelationInput = {
    id?: SortOrder
    corrida_id?: SortOrder
    ordem?: SortOrder
    endereco?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    tempo_espera?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type paradasWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: paradasWhereInput | paradasWhereInput[]
    OR?: paradasWhereInput[]
    NOT?: paradasWhereInput | paradasWhereInput[]
    corrida_id?: IntFilter<"paradas"> | number
    ordem?: IntFilter<"paradas"> | number
    endereco?: StringFilter<"paradas"> | string
    latitude?: FloatNullableFilter<"paradas"> | number | null
    longitude?: FloatNullableFilter<"paradas"> | number | null
    tempo_espera?: IntNullableFilter<"paradas"> | number | null
    createdAt?: DateTimeFilter<"paradas"> | Date | string
    updatedAt?: DateTimeFilter<"paradas"> | Date | string
  }, "id">

  export type paradasOrderByWithAggregationInput = {
    id?: SortOrder
    corrida_id?: SortOrder
    ordem?: SortOrder
    endereco?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    tempo_espera?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: paradasCountOrderByAggregateInput
    _avg?: paradasAvgOrderByAggregateInput
    _max?: paradasMaxOrderByAggregateInput
    _min?: paradasMinOrderByAggregateInput
    _sum?: paradasSumOrderByAggregateInput
  }

  export type paradasScalarWhereWithAggregatesInput = {
    AND?: paradasScalarWhereWithAggregatesInput | paradasScalarWhereWithAggregatesInput[]
    OR?: paradasScalarWhereWithAggregatesInput[]
    NOT?: paradasScalarWhereWithAggregatesInput | paradasScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"paradas"> | number
    corrida_id?: IntWithAggregatesFilter<"paradas"> | number
    ordem?: IntWithAggregatesFilter<"paradas"> | number
    endereco?: StringWithAggregatesFilter<"paradas"> | string
    latitude?: FloatNullableWithAggregatesFilter<"paradas"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"paradas"> | number | null
    tempo_espera?: IntNullableWithAggregatesFilter<"paradas"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"paradas"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"paradas"> | Date | string
  }

  export type recompensasWhereInput = {
    AND?: recompensasWhereInput | recompensasWhereInput[]
    OR?: recompensasWhereInput[]
    NOT?: recompensasWhereInput | recompensasWhereInput[]
    id?: IntFilter<"recompensas"> | number
    indicador_id?: IntFilter<"recompensas"> | number
    indicado_id?: IntFilter<"recompensas"> | number
    tipo?: Enumenum_recompensas_tipoFilter<"recompensas"> | $Enums.enum_recompensas_tipo
    valor?: FloatFilter<"recompensas"> | number
    status?: Enumenum_recompensas_statusNullableFilter<"recompensas"> | $Enums.enum_recompensas_status | null
    data_gerada?: DateTimeNullableFilter<"recompensas"> | Date | string | null
    referencia_corrida?: IntNullableFilter<"recompensas"> | number | null
    createdAt?: DateTimeFilter<"recompensas"> | Date | string
    updatedAt?: DateTimeFilter<"recompensas"> | Date | string
  }

  export type recompensasOrderByWithRelationInput = {
    id?: SortOrder
    indicador_id?: SortOrder
    indicado_id?: SortOrder
    tipo?: SortOrder
    valor?: SortOrder
    status?: SortOrderInput | SortOrder
    data_gerada?: SortOrderInput | SortOrder
    referencia_corrida?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type recompensasWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: recompensasWhereInput | recompensasWhereInput[]
    OR?: recompensasWhereInput[]
    NOT?: recompensasWhereInput | recompensasWhereInput[]
    indicador_id?: IntFilter<"recompensas"> | number
    indicado_id?: IntFilter<"recompensas"> | number
    tipo?: Enumenum_recompensas_tipoFilter<"recompensas"> | $Enums.enum_recompensas_tipo
    valor?: FloatFilter<"recompensas"> | number
    status?: Enumenum_recompensas_statusNullableFilter<"recompensas"> | $Enums.enum_recompensas_status | null
    data_gerada?: DateTimeNullableFilter<"recompensas"> | Date | string | null
    referencia_corrida?: IntNullableFilter<"recompensas"> | number | null
    createdAt?: DateTimeFilter<"recompensas"> | Date | string
    updatedAt?: DateTimeFilter<"recompensas"> | Date | string
  }, "id">

  export type recompensasOrderByWithAggregationInput = {
    id?: SortOrder
    indicador_id?: SortOrder
    indicado_id?: SortOrder
    tipo?: SortOrder
    valor?: SortOrder
    status?: SortOrderInput | SortOrder
    data_gerada?: SortOrderInput | SortOrder
    referencia_corrida?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: recompensasCountOrderByAggregateInput
    _avg?: recompensasAvgOrderByAggregateInput
    _max?: recompensasMaxOrderByAggregateInput
    _min?: recompensasMinOrderByAggregateInput
    _sum?: recompensasSumOrderByAggregateInput
  }

  export type recompensasScalarWhereWithAggregatesInput = {
    AND?: recompensasScalarWhereWithAggregatesInput | recompensasScalarWhereWithAggregatesInput[]
    OR?: recompensasScalarWhereWithAggregatesInput[]
    NOT?: recompensasScalarWhereWithAggregatesInput | recompensasScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"recompensas"> | number
    indicador_id?: IntWithAggregatesFilter<"recompensas"> | number
    indicado_id?: IntWithAggregatesFilter<"recompensas"> | number
    tipo?: Enumenum_recompensas_tipoWithAggregatesFilter<"recompensas"> | $Enums.enum_recompensas_tipo
    valor?: FloatWithAggregatesFilter<"recompensas"> | number
    status?: Enumenum_recompensas_statusNullableWithAggregatesFilter<"recompensas"> | $Enums.enum_recompensas_status | null
    data_gerada?: DateTimeNullableWithAggregatesFilter<"recompensas"> | Date | string | null
    referencia_corrida?: IntNullableWithAggregatesFilter<"recompensas"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"recompensas"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"recompensas"> | Date | string
  }

  export type saquesWhereInput = {
    AND?: saquesWhereInput | saquesWhereInput[]
    OR?: saquesWhereInput[]
    NOT?: saquesWhereInput | saquesWhereInput[]
    id?: IntFilter<"saques"> | number
    usuario_id?: IntFilter<"saques"> | number
    valor?: FloatFilter<"saques"> | number
    status?: Enumenum_saques_statusNullableFilter<"saques"> | $Enums.enum_saques_status | null
    tipo?: Enumenum_saques_tipoFilter<"saques"> | $Enums.enum_saques_tipo
    pix?: StringFilter<"saques"> | string
    data_pedido?: DateTimeNullableFilter<"saques"> | Date | string | null
    createdAt?: DateTimeFilter<"saques"> | Date | string
    updatedAt?: DateTimeFilter<"saques"> | Date | string
  }

  export type saquesOrderByWithRelationInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    valor?: SortOrder
    status?: SortOrderInput | SortOrder
    tipo?: SortOrder
    pix?: SortOrder
    data_pedido?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type saquesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: saquesWhereInput | saquesWhereInput[]
    OR?: saquesWhereInput[]
    NOT?: saquesWhereInput | saquesWhereInput[]
    usuario_id?: IntFilter<"saques"> | number
    valor?: FloatFilter<"saques"> | number
    status?: Enumenum_saques_statusNullableFilter<"saques"> | $Enums.enum_saques_status | null
    tipo?: Enumenum_saques_tipoFilter<"saques"> | $Enums.enum_saques_tipo
    pix?: StringFilter<"saques"> | string
    data_pedido?: DateTimeNullableFilter<"saques"> | Date | string | null
    createdAt?: DateTimeFilter<"saques"> | Date | string
    updatedAt?: DateTimeFilter<"saques"> | Date | string
  }, "id">

  export type saquesOrderByWithAggregationInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    valor?: SortOrder
    status?: SortOrderInput | SortOrder
    tipo?: SortOrder
    pix?: SortOrder
    data_pedido?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: saquesCountOrderByAggregateInput
    _avg?: saquesAvgOrderByAggregateInput
    _max?: saquesMaxOrderByAggregateInput
    _min?: saquesMinOrderByAggregateInput
    _sum?: saquesSumOrderByAggregateInput
  }

  export type saquesScalarWhereWithAggregatesInput = {
    AND?: saquesScalarWhereWithAggregatesInput | saquesScalarWhereWithAggregatesInput[]
    OR?: saquesScalarWhereWithAggregatesInput[]
    NOT?: saquesScalarWhereWithAggregatesInput | saquesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"saques"> | number
    usuario_id?: IntWithAggregatesFilter<"saques"> | number
    valor?: FloatWithAggregatesFilter<"saques"> | number
    status?: Enumenum_saques_statusNullableWithAggregatesFilter<"saques"> | $Enums.enum_saques_status | null
    tipo?: Enumenum_saques_tipoWithAggregatesFilter<"saques"> | $Enums.enum_saques_tipo
    pix?: StringWithAggregatesFilter<"saques"> | string
    data_pedido?: DateTimeNullableWithAggregatesFilter<"saques"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"saques"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"saques"> | Date | string
  }

  export type transacoesWhereInput = {
    AND?: transacoesWhereInput | transacoesWhereInput[]
    OR?: transacoesWhereInput[]
    NOT?: transacoesWhereInput | transacoesWhereInput[]
    id?: IntFilter<"transacoes"> | number
    usuario_id?: IntFilter<"transacoes"> | number
    tipo?: Enumenum_transacoes_tipoFilter<"transacoes"> | $Enums.enum_transacoes_tipo
    origem?: Enumenum_transacoes_origemFilter<"transacoes"> | $Enums.enum_transacoes_origem
    descricao?: StringNullableFilter<"transacoes"> | string | null
    valor?: FloatFilter<"transacoes"> | number
    data_transacao?: DateTimeNullableFilter<"transacoes"> | Date | string | null
    createdAt?: DateTimeFilter<"transacoes"> | Date | string
    updatedAt?: DateTimeFilter<"transacoes"> | Date | string
  }

  export type transacoesOrderByWithRelationInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    tipo?: SortOrder
    origem?: SortOrder
    descricao?: SortOrderInput | SortOrder
    valor?: SortOrder
    data_transacao?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type transacoesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: transacoesWhereInput | transacoesWhereInput[]
    OR?: transacoesWhereInput[]
    NOT?: transacoesWhereInput | transacoesWhereInput[]
    usuario_id?: IntFilter<"transacoes"> | number
    tipo?: Enumenum_transacoes_tipoFilter<"transacoes"> | $Enums.enum_transacoes_tipo
    origem?: Enumenum_transacoes_origemFilter<"transacoes"> | $Enums.enum_transacoes_origem
    descricao?: StringNullableFilter<"transacoes"> | string | null
    valor?: FloatFilter<"transacoes"> | number
    data_transacao?: DateTimeNullableFilter<"transacoes"> | Date | string | null
    createdAt?: DateTimeFilter<"transacoes"> | Date | string
    updatedAt?: DateTimeFilter<"transacoes"> | Date | string
  }, "id">

  export type transacoesOrderByWithAggregationInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    tipo?: SortOrder
    origem?: SortOrder
    descricao?: SortOrderInput | SortOrder
    valor?: SortOrder
    data_transacao?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: transacoesCountOrderByAggregateInput
    _avg?: transacoesAvgOrderByAggregateInput
    _max?: transacoesMaxOrderByAggregateInput
    _min?: transacoesMinOrderByAggregateInput
    _sum?: transacoesSumOrderByAggregateInput
  }

  export type transacoesScalarWhereWithAggregatesInput = {
    AND?: transacoesScalarWhereWithAggregatesInput | transacoesScalarWhereWithAggregatesInput[]
    OR?: transacoesScalarWhereWithAggregatesInput[]
    NOT?: transacoesScalarWhereWithAggregatesInput | transacoesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"transacoes"> | number
    usuario_id?: IntWithAggregatesFilter<"transacoes"> | number
    tipo?: Enumenum_transacoes_tipoWithAggregatesFilter<"transacoes"> | $Enums.enum_transacoes_tipo
    origem?: Enumenum_transacoes_origemWithAggregatesFilter<"transacoes"> | $Enums.enum_transacoes_origem
    descricao?: StringNullableWithAggregatesFilter<"transacoes"> | string | null
    valor?: FloatWithAggregatesFilter<"transacoes"> | number
    data_transacao?: DateTimeNullableWithAggregatesFilter<"transacoes"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"transacoes"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"transacoes"> | Date | string
  }

  export type usuariosWhereInput = {
    AND?: usuariosWhereInput | usuariosWhereInput[]
    OR?: usuariosWhereInput[]
    NOT?: usuariosWhereInput | usuariosWhereInput[]
    id?: IntFilter<"usuarios"> | number
    nome?: StringFilter<"usuarios"> | string
    tipo?: Enumenum_usuarios_tipoFilter<"usuarios"> | $Enums.enum_usuarios_tipo
    email?: StringNullableFilter<"usuarios"> | string | null
    senha?: StringFilter<"usuarios"> | string
    createdAt?: DateTimeFilter<"usuarios"> | Date | string
    updatedAt?: DateTimeFilter<"usuarios"> | Date | string
  }

  export type usuariosOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    tipo?: SortOrder
    email?: SortOrderInput | SortOrder
    senha?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type usuariosWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: usuariosWhereInput | usuariosWhereInput[]
    OR?: usuariosWhereInput[]
    NOT?: usuariosWhereInput | usuariosWhereInput[]
    nome?: StringFilter<"usuarios"> | string
    tipo?: Enumenum_usuarios_tipoFilter<"usuarios"> | $Enums.enum_usuarios_tipo
    senha?: StringFilter<"usuarios"> | string
    createdAt?: DateTimeFilter<"usuarios"> | Date | string
    updatedAt?: DateTimeFilter<"usuarios"> | Date | string
  }, "id" | "email">

  export type usuariosOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    tipo?: SortOrder
    email?: SortOrderInput | SortOrder
    senha?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: usuariosCountOrderByAggregateInput
    _avg?: usuariosAvgOrderByAggregateInput
    _max?: usuariosMaxOrderByAggregateInput
    _min?: usuariosMinOrderByAggregateInput
    _sum?: usuariosSumOrderByAggregateInput
  }

  export type usuariosScalarWhereWithAggregatesInput = {
    AND?: usuariosScalarWhereWithAggregatesInput | usuariosScalarWhereWithAggregatesInput[]
    OR?: usuariosScalarWhereWithAggregatesInput[]
    NOT?: usuariosScalarWhereWithAggregatesInput | usuariosScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"usuarios"> | number
    nome?: StringWithAggregatesFilter<"usuarios"> | string
    tipo?: Enumenum_usuarios_tipoWithAggregatesFilter<"usuarios"> | $Enums.enum_usuarios_tipo
    email?: StringNullableWithAggregatesFilter<"usuarios"> | string | null
    senha?: StringWithAggregatesFilter<"usuarios"> | string
    createdAt?: DateTimeWithAggregatesFilter<"usuarios"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"usuarios"> | Date | string
  }

  export type veiculosWhereInput = {
    AND?: veiculosWhereInput | veiculosWhereInput[]
    OR?: veiculosWhereInput[]
    NOT?: veiculosWhereInput | veiculosWhereInput[]
    id?: IntFilter<"veiculos"> | number
    motorista_id?: IntFilter<"veiculos"> | number
    modelo?: StringFilter<"veiculos"> | string
    placa?: StringFilter<"veiculos"> | string
    ano?: IntFilter<"veiculos"> | number
    categoria?: Enumenum_veiculos_categoriaFilter<"veiculos"> | $Enums.enum_veiculos_categoria
    status?: Enumenum_veiculos_statusNullableFilter<"veiculos"> | $Enums.enum_veiculos_status | null
    observacoes?: StringNullableFilter<"veiculos"> | string | null
    createdAt?: DateTimeFilter<"veiculos"> | Date | string
    updatedAt?: DateTimeFilter<"veiculos"> | Date | string
  }

  export type veiculosOrderByWithRelationInput = {
    id?: SortOrder
    motorista_id?: SortOrder
    modelo?: SortOrder
    placa?: SortOrder
    ano?: SortOrder
    categoria?: SortOrder
    status?: SortOrderInput | SortOrder
    observacoes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type veiculosWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    placa?: string
    AND?: veiculosWhereInput | veiculosWhereInput[]
    OR?: veiculosWhereInput[]
    NOT?: veiculosWhereInput | veiculosWhereInput[]
    motorista_id?: IntFilter<"veiculos"> | number
    modelo?: StringFilter<"veiculos"> | string
    ano?: IntFilter<"veiculos"> | number
    categoria?: Enumenum_veiculos_categoriaFilter<"veiculos"> | $Enums.enum_veiculos_categoria
    status?: Enumenum_veiculos_statusNullableFilter<"veiculos"> | $Enums.enum_veiculos_status | null
    observacoes?: StringNullableFilter<"veiculos"> | string | null
    createdAt?: DateTimeFilter<"veiculos"> | Date | string
    updatedAt?: DateTimeFilter<"veiculos"> | Date | string
  }, "id" | "placa">

  export type veiculosOrderByWithAggregationInput = {
    id?: SortOrder
    motorista_id?: SortOrder
    modelo?: SortOrder
    placa?: SortOrder
    ano?: SortOrder
    categoria?: SortOrder
    status?: SortOrderInput | SortOrder
    observacoes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: veiculosCountOrderByAggregateInput
    _avg?: veiculosAvgOrderByAggregateInput
    _max?: veiculosMaxOrderByAggregateInput
    _min?: veiculosMinOrderByAggregateInput
    _sum?: veiculosSumOrderByAggregateInput
  }

  export type veiculosScalarWhereWithAggregatesInput = {
    AND?: veiculosScalarWhereWithAggregatesInput | veiculosScalarWhereWithAggregatesInput[]
    OR?: veiculosScalarWhereWithAggregatesInput[]
    NOT?: veiculosScalarWhereWithAggregatesInput | veiculosScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"veiculos"> | number
    motorista_id?: IntWithAggregatesFilter<"veiculos"> | number
    modelo?: StringWithAggregatesFilter<"veiculos"> | string
    placa?: StringWithAggregatesFilter<"veiculos"> | string
    ano?: IntWithAggregatesFilter<"veiculos"> | number
    categoria?: Enumenum_veiculos_categoriaWithAggregatesFilter<"veiculos"> | $Enums.enum_veiculos_categoria
    status?: Enumenum_veiculos_statusNullableWithAggregatesFilter<"veiculos"> | $Enums.enum_veiculos_status | null
    observacoes?: StringNullableWithAggregatesFilter<"veiculos"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"veiculos"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"veiculos"> | Date | string
  }

  export type BairroPrioridadesCreateInput = {
    nome: string
    cidade: string
    estado: string
    ativo?: boolean | null
    tipo_prioridade?: $Enums.enum_BairroPrioridades_tipo_prioridade | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type BairroPrioridadesUncheckedCreateInput = {
    id?: number
    nome: string
    cidade: string
    estado: string
    ativo?: boolean | null
    tipo_prioridade?: $Enums.enum_BairroPrioridades_tipo_prioridade | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type BairroPrioridadesUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tipo_prioridade?: NullableEnumenum_BairroPrioridades_tipo_prioridadeFieldUpdateOperationsInput | $Enums.enum_BairroPrioridades_tipo_prioridade | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BairroPrioridadesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tipo_prioridade?: NullableEnumenum_BairroPrioridades_tipo_prioridadeFieldUpdateOperationsInput | $Enums.enum_BairroPrioridades_tipo_prioridade | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BairroPrioridadesCreateManyInput = {
    id?: number
    nome: string
    cidade: string
    estado: string
    ativo?: boolean | null
    tipo_prioridade?: $Enums.enum_BairroPrioridades_tipo_prioridade | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type BairroPrioridadesUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tipo_prioridade?: NullableEnumenum_BairroPrioridades_tipo_prioridadeFieldUpdateOperationsInput | $Enums.enum_BairroPrioridades_tipo_prioridade | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BairroPrioridadesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tipo_prioridade?: NullableEnumenum_BairroPrioridades_tipo_prioridadeFieldUpdateOperationsInput | $Enums.enum_BairroPrioridades_tipo_prioridade | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CarteirasCreateInput = {
    usuarioId: number
    saldo?: Decimal | DecimalJsLike | number | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type CarteirasUncheckedCreateInput = {
    id?: number
    usuarioId: number
    saldo?: Decimal | DecimalJsLike | number | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type CarteirasUpdateInput = {
    usuarioId?: IntFieldUpdateOperationsInput | number
    saldo?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CarteirasUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    saldo?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CarteirasCreateManyInput = {
    id?: number
    usuarioId: number
    saldo?: Decimal | DecimalJsLike | number | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type CarteirasUpdateManyMutationInput = {
    usuarioId?: IntFieldUpdateOperationsInput | number
    saldo?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CarteirasUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    saldo?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CodigoIndicacaosCreateInput = {
    codigo: string
    usuarioId: number
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type CodigoIndicacaosUncheckedCreateInput = {
    id?: number
    codigo: string
    usuarioId: number
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type CodigoIndicacaosUpdateInput = {
    codigo?: StringFieldUpdateOperationsInput | string
    usuarioId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CodigoIndicacaosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    usuarioId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CodigoIndicacaosCreateManyInput = {
    id?: number
    codigo: string
    usuarioId: number
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type CodigoIndicacaosUpdateManyMutationInput = {
    codigo?: StringFieldUpdateOperationsInput | string
    usuarioId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CodigoIndicacaosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    usuarioId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CorridaAgendadasCreateInput = {
    passageiroCpf: string
    motoristaCpf?: string | null
    origem: string
    destino: string
    dataHoraAgendada: Date | string
    status?: string | null
    tipo: string
    valor?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type CorridaAgendadasUncheckedCreateInput = {
    id?: number
    passageiroCpf: string
    motoristaCpf?: string | null
    origem: string
    destino: string
    dataHoraAgendada: Date | string
    status?: string | null
    tipo: string
    valor?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type CorridaAgendadasUpdateInput = {
    passageiroCpf?: StringFieldUpdateOperationsInput | string
    motoristaCpf?: NullableStringFieldUpdateOperationsInput | string | null
    origem?: StringFieldUpdateOperationsInput | string
    destino?: StringFieldUpdateOperationsInput | string
    dataHoraAgendada?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: StringFieldUpdateOperationsInput | string
    valor?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CorridaAgendadasUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    passageiroCpf?: StringFieldUpdateOperationsInput | string
    motoristaCpf?: NullableStringFieldUpdateOperationsInput | string | null
    origem?: StringFieldUpdateOperationsInput | string
    destino?: StringFieldUpdateOperationsInput | string
    dataHoraAgendada?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: StringFieldUpdateOperationsInput | string
    valor?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CorridaAgendadasCreateManyInput = {
    id?: number
    passageiroCpf: string
    motoristaCpf?: string | null
    origem: string
    destino: string
    dataHoraAgendada: Date | string
    status?: string | null
    tipo: string
    valor?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type CorridaAgendadasUpdateManyMutationInput = {
    passageiroCpf?: StringFieldUpdateOperationsInput | string
    motoristaCpf?: NullableStringFieldUpdateOperationsInput | string | null
    origem?: StringFieldUpdateOperationsInput | string
    destino?: StringFieldUpdateOperationsInput | string
    dataHoraAgendada?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: StringFieldUpdateOperationsInput | string
    valor?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CorridaAgendadasUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    passageiroCpf?: StringFieldUpdateOperationsInput | string
    motoristaCpf?: NullableStringFieldUpdateOperationsInput | string | null
    origem?: StringFieldUpdateOperationsInput | string
    destino?: StringFieldUpdateOperationsInput | string
    dataHoraAgendada?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: StringFieldUpdateOperationsInput | string
    valor?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CorridasCreateInput = {
    origem?: string | null
    destino?: string | null
    status?: string | null
    valor?: Decimal | DecimalJsLike | number | string | null
    tipo?: $Enums.enum_Corridas_tipo | null
    horarioAgendado?: Date | string | null
    usuarioId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type CorridasUncheckedCreateInput = {
    id?: number
    origem?: string | null
    destino?: string | null
    status?: string | null
    valor?: Decimal | DecimalJsLike | number | string | null
    tipo?: $Enums.enum_Corridas_tipo | null
    horarioAgendado?: Date | string | null
    usuarioId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type CorridasUpdateInput = {
    origem?: NullableStringFieldUpdateOperationsInput | string | null
    destino?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    valor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tipo?: NullableEnumenum_Corridas_tipoFieldUpdateOperationsInput | $Enums.enum_Corridas_tipo | null
    horarioAgendado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usuarioId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CorridasUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    origem?: NullableStringFieldUpdateOperationsInput | string | null
    destino?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    valor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tipo?: NullableEnumenum_Corridas_tipoFieldUpdateOperationsInput | $Enums.enum_Corridas_tipo | null
    horarioAgendado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usuarioId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CorridasCreateManyInput = {
    id?: number
    origem?: string | null
    destino?: string | null
    status?: string | null
    valor?: Decimal | DecimalJsLike | number | string | null
    tipo?: $Enums.enum_Corridas_tipo | null
    horarioAgendado?: Date | string | null
    usuarioId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type CorridasUpdateManyMutationInput = {
    origem?: NullableStringFieldUpdateOperationsInput | string | null
    destino?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    valor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tipo?: NullableEnumenum_Corridas_tipoFieldUpdateOperationsInput | $Enums.enum_Corridas_tipo | null
    horarioAgendado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usuarioId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CorridasUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    origem?: NullableStringFieldUpdateOperationsInput | string | null
    destino?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    valor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tipo?: NullableEnumenum_Corridas_tipoFieldUpdateOperationsInput | $Enums.enum_Corridas_tipo | null
    horarioAgendado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usuarioId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DenunciaCreateInput = {
    autor_id: number
    alvo_id: number
    tipo_alvo: $Enums.enum_Denuncia_tipo_alvo
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type DenunciaUncheckedCreateInput = {
    id?: number
    autor_id: number
    alvo_id: number
    tipo_alvo: $Enums.enum_Denuncia_tipo_alvo
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type DenunciaUpdateInput = {
    autor_id?: IntFieldUpdateOperationsInput | number
    alvo_id?: IntFieldUpdateOperationsInput | number
    tipo_alvo?: Enumenum_Denuncia_tipo_alvoFieldUpdateOperationsInput | $Enums.enum_Denuncia_tipo_alvo
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DenunciaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    autor_id?: IntFieldUpdateOperationsInput | number
    alvo_id?: IntFieldUpdateOperationsInput | number
    tipo_alvo?: Enumenum_Denuncia_tipo_alvoFieldUpdateOperationsInput | $Enums.enum_Denuncia_tipo_alvo
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DenunciaCreateManyInput = {
    id?: number
    autor_id: number
    alvo_id: number
    tipo_alvo: $Enums.enum_Denuncia_tipo_alvo
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type DenunciaUpdateManyMutationInput = {
    autor_id?: IntFieldUpdateOperationsInput | number
    alvo_id?: IntFieldUpdateOperationsInput | number
    tipo_alvo?: Enumenum_Denuncia_tipo_alvoFieldUpdateOperationsInput | $Enums.enum_Denuncia_tipo_alvo
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DenunciaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    autor_id?: IntFieldUpdateOperationsInput | number
    alvo_id?: IntFieldUpdateOperationsInput | number
    tipo_alvo?: Enumenum_Denuncia_tipo_alvoFieldUpdateOperationsInput | $Enums.enum_Denuncia_tipo_alvo
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentosCreateInput = {
    usuario_id: number
    tipo_documento: $Enums.enum_Documentos_tipo_documento
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type DocumentosUncheckedCreateInput = {
    id?: number
    usuario_id: number
    tipo_documento: $Enums.enum_Documentos_tipo_documento
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type DocumentosUpdateInput = {
    usuario_id?: IntFieldUpdateOperationsInput | number
    tipo_documento?: Enumenum_Documentos_tipo_documentoFieldUpdateOperationsInput | $Enums.enum_Documentos_tipo_documento
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
    tipo_documento?: Enumenum_Documentos_tipo_documentoFieldUpdateOperationsInput | $Enums.enum_Documentos_tipo_documento
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentosCreateManyInput = {
    id?: number
    usuario_id: number
    tipo_documento: $Enums.enum_Documentos_tipo_documento
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type DocumentosUpdateManyMutationInput = {
    usuario_id?: IntFieldUpdateOperationsInput | number
    tipo_documento?: Enumenum_Documentos_tipo_documentoFieldUpdateOperationsInput | $Enums.enum_Documentos_tipo_documento
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
    tipo_documento?: Enumenum_Documentos_tipo_documentoFieldUpdateOperationsInput | $Enums.enum_Documentos_tipo_documento
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailEnviadosCreateInput = {
    usuario_id: number
    email: string
    tipo?: $Enums.enum_EmailEnviados_tipo | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type EmailEnviadosUncheckedCreateInput = {
    id?: number
    usuario_id: number
    email: string
    tipo?: $Enums.enum_EmailEnviados_tipo | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type EmailEnviadosUpdateInput = {
    usuario_id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    tipo?: NullableEnumenum_EmailEnviados_tipoFieldUpdateOperationsInput | $Enums.enum_EmailEnviados_tipo | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailEnviadosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    tipo?: NullableEnumenum_EmailEnviados_tipoFieldUpdateOperationsInput | $Enums.enum_EmailEnviados_tipo | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailEnviadosCreateManyInput = {
    id?: number
    usuario_id: number
    email: string
    tipo?: $Enums.enum_EmailEnviados_tipo | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type EmailEnviadosUpdateManyMutationInput = {
    usuario_id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    tipo?: NullableEnumenum_EmailEnviados_tipoFieldUpdateOperationsInput | $Enums.enum_EmailEnviados_tipo | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailEnviadosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    tipo?: NullableEnumenum_EmailEnviados_tipoFieldUpdateOperationsInput | $Enums.enum_EmailEnviados_tipo | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HistoricoIndicacaosCreateInput = {
    indicador_id: number
    indicado_id: number
    tipo?: $Enums.enum_HistoricoIndicacaos_tipo | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type HistoricoIndicacaosUncheckedCreateInput = {
    id?: number
    indicador_id: number
    indicado_id: number
    tipo?: $Enums.enum_HistoricoIndicacaos_tipo | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type HistoricoIndicacaosUpdateInput = {
    indicador_id?: IntFieldUpdateOperationsInput | number
    indicado_id?: IntFieldUpdateOperationsInput | number
    tipo?: NullableEnumenum_HistoricoIndicacaos_tipoFieldUpdateOperationsInput | $Enums.enum_HistoricoIndicacaos_tipo | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HistoricoIndicacaosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    indicador_id?: IntFieldUpdateOperationsInput | number
    indicado_id?: IntFieldUpdateOperationsInput | number
    tipo?: NullableEnumenum_HistoricoIndicacaos_tipoFieldUpdateOperationsInput | $Enums.enum_HistoricoIndicacaos_tipo | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HistoricoIndicacaosCreateManyInput = {
    id?: number
    indicador_id: number
    indicado_id: number
    tipo?: $Enums.enum_HistoricoIndicacaos_tipo | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type HistoricoIndicacaosUpdateManyMutationInput = {
    indicador_id?: IntFieldUpdateOperationsInput | number
    indicado_id?: IntFieldUpdateOperationsInput | number
    tipo?: NullableEnumenum_HistoricoIndicacaos_tipoFieldUpdateOperationsInput | $Enums.enum_HistoricoIndicacaos_tipo | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HistoricoIndicacaosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    indicador_id?: IntFieldUpdateOperationsInput | number
    indicado_id?: IntFieldUpdateOperationsInput | number
    tipo?: NullableEnumenum_HistoricoIndicacaos_tipoFieldUpdateOperationsInput | $Enums.enum_HistoricoIndicacaos_tipo | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HistoricoSelfiesCreateInput = {
    usuario_id: number
    tipo?: $Enums.enum_HistoricoSelfies_tipo | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type HistoricoSelfiesUncheckedCreateInput = {
    id?: number
    usuario_id: number
    tipo?: $Enums.enum_HistoricoSelfies_tipo | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type HistoricoSelfiesUpdateInput = {
    usuario_id?: IntFieldUpdateOperationsInput | number
    tipo?: NullableEnumenum_HistoricoSelfies_tipoFieldUpdateOperationsInput | $Enums.enum_HistoricoSelfies_tipo | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HistoricoSelfiesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
    tipo?: NullableEnumenum_HistoricoSelfies_tipoFieldUpdateOperationsInput | $Enums.enum_HistoricoSelfies_tipo | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HistoricoSelfiesCreateManyInput = {
    id?: number
    usuario_id: number
    tipo?: $Enums.enum_HistoricoSelfies_tipo | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type HistoricoSelfiesUpdateManyMutationInput = {
    usuario_id?: IntFieldUpdateOperationsInput | number
    tipo?: NullableEnumenum_HistoricoSelfies_tipoFieldUpdateOperationsInput | $Enums.enum_HistoricoSelfies_tipo | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HistoricoSelfiesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
    tipo?: NullableEnumenum_HistoricoSelfies_tipoFieldUpdateOperationsInput | $Enums.enum_HistoricoSelfies_tipo | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IdentidadesCreateInput = {
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type IdentidadesUncheckedCreateInput = {
    id?: number
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type IdentidadesUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IdentidadesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IdentidadesCreateManyInput = {
    id?: number
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type IdentidadesUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IdentidadesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndicacaosCreateInput = {
    createdAt: Date | string
    updatedAt: Date | string
    Usuarios_Indicacaos_indicadoIdToUsuarios: UsuariosCreateNestedOneWithoutIndicacaos_Indicacaos_indicadoIdToUsuariosInput
    Usuarios_Indicacaos_indicanteIdToUsuarios: UsuariosCreateNestedOneWithoutIndicacaos_Indicacaos_indicanteIdToUsuariosInput
  }

  export type IndicacaosUncheckedCreateInput = {
    id?: number
    indicanteId: number
    indicadoId: number
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type IndicacaosUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Usuarios_Indicacaos_indicadoIdToUsuarios?: UsuariosUpdateOneRequiredWithoutIndicacaos_Indicacaos_indicadoIdToUsuariosNestedInput
    Usuarios_Indicacaos_indicanteIdToUsuarios?: UsuariosUpdateOneRequiredWithoutIndicacaos_Indicacaos_indicanteIdToUsuariosNestedInput
  }

  export type IndicacaosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    indicanteId?: IntFieldUpdateOperationsInput | number
    indicadoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndicacaosCreateManyInput = {
    id?: number
    indicanteId: number
    indicadoId: number
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type IndicacaosUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndicacaosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    indicanteId?: IntFieldUpdateOperationsInput | number
    indicadoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogAcessosCreateInput = {
    usuario_id: number
    tipo_usuario?: $Enums.enum_LogAcessos_tipo_usuario | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type LogAcessosUncheckedCreateInput = {
    id?: number
    usuario_id: number
    tipo_usuario?: $Enums.enum_LogAcessos_tipo_usuario | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type LogAcessosUpdateInput = {
    usuario_id?: IntFieldUpdateOperationsInput | number
    tipo_usuario?: NullableEnumenum_LogAcessos_tipo_usuarioFieldUpdateOperationsInput | $Enums.enum_LogAcessos_tipo_usuario | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogAcessosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
    tipo_usuario?: NullableEnumenum_LogAcessos_tipo_usuarioFieldUpdateOperationsInput | $Enums.enum_LogAcessos_tipo_usuario | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogAcessosCreateManyInput = {
    id?: number
    usuario_id: number
    tipo_usuario?: $Enums.enum_LogAcessos_tipo_usuario | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type LogAcessosUpdateManyMutationInput = {
    usuario_id?: IntFieldUpdateOperationsInput | number
    tipo_usuario?: NullableEnumenum_LogAcessos_tipo_usuarioFieldUpdateOperationsInput | $Enums.enum_LogAcessos_tipo_usuario | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogAcessosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
    tipo_usuario?: NullableEnumenum_LogAcessos_tipo_usuarioFieldUpdateOperationsInput | $Enums.enum_LogAcessos_tipo_usuario | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MensagemSuportesCreateInput = {
    usuario_id: number
    tipo_usuario?: $Enums.enum_MensagemSuportes_tipo_usuario | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type MensagemSuportesUncheckedCreateInput = {
    id?: number
    usuario_id: number
    tipo_usuario?: $Enums.enum_MensagemSuportes_tipo_usuario | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type MensagemSuportesUpdateInput = {
    usuario_id?: IntFieldUpdateOperationsInput | number
    tipo_usuario?: NullableEnumenum_MensagemSuportes_tipo_usuarioFieldUpdateOperationsInput | $Enums.enum_MensagemSuportes_tipo_usuario | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MensagemSuportesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
    tipo_usuario?: NullableEnumenum_MensagemSuportes_tipo_usuarioFieldUpdateOperationsInput | $Enums.enum_MensagemSuportes_tipo_usuario | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MensagemSuportesCreateManyInput = {
    id?: number
    usuario_id: number
    tipo_usuario?: $Enums.enum_MensagemSuportes_tipo_usuario | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type MensagemSuportesUpdateManyMutationInput = {
    usuario_id?: IntFieldUpdateOperationsInput | number
    tipo_usuario?: NullableEnumenum_MensagemSuportes_tipo_usuarioFieldUpdateOperationsInput | $Enums.enum_MensagemSuportes_tipo_usuario | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MensagemSuportesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
    tipo_usuario?: NullableEnumenum_MensagemSuportes_tipo_usuarioFieldUpdateOperationsInput | $Enums.enum_MensagemSuportes_tipo_usuario | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecompensasCreateInput = {
    descricao: string
    valor: number
    status?: $Enums.enum_Recompensas_status | null
    createdAt: Date | string
    updatedAt: Date | string
    Usuarios: UsuariosCreateNestedOneWithoutRecompensasInput
  }

  export type RecompensasUncheckedCreateInput = {
    id?: number
    usuarioId: number
    descricao: string
    valor: number
    status?: $Enums.enum_Recompensas_status | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type RecompensasUpdateInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    status?: NullableEnumenum_Recompensas_statusFieldUpdateOperationsInput | $Enums.enum_Recompensas_status | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Usuarios?: UsuariosUpdateOneRequiredWithoutRecompensasNestedInput
  }

  export type RecompensasUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    status?: NullableEnumenum_Recompensas_statusFieldUpdateOperationsInput | $Enums.enum_Recompensas_status | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecompensasCreateManyInput = {
    id?: number
    usuarioId: number
    descricao: string
    valor: number
    status?: $Enums.enum_Recompensas_status | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type RecompensasUpdateManyMutationInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    status?: NullableEnumenum_Recompensas_statusFieldUpdateOperationsInput | $Enums.enum_Recompensas_status | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecompensasUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    status?: NullableEnumenum_Recompensas_statusFieldUpdateOperationsInput | $Enums.enum_Recompensas_status | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaquesCreateInput = {
    valor: Decimal | DecimalJsLike | number | string
    status?: $Enums.enum_Saques_status | null
    tipo: $Enums.enum_Saques_tipo
    createdAt: Date | string
    updatedAt: Date | string
    Usuarios: UsuariosCreateNestedOneWithoutSaquesInput
  }

  export type SaquesUncheckedCreateInput = {
    id?: number
    usuarioId: number
    valor: Decimal | DecimalJsLike | number | string
    status?: $Enums.enum_Saques_status | null
    tipo: $Enums.enum_Saques_tipo
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type SaquesUpdateInput = {
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: NullableEnumenum_Saques_statusFieldUpdateOperationsInput | $Enums.enum_Saques_status | null
    tipo?: Enumenum_Saques_tipoFieldUpdateOperationsInput | $Enums.enum_Saques_tipo
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Usuarios?: UsuariosUpdateOneRequiredWithoutSaquesNestedInput
  }

  export type SaquesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: NullableEnumenum_Saques_statusFieldUpdateOperationsInput | $Enums.enum_Saques_status | null
    tipo?: Enumenum_Saques_tipoFieldUpdateOperationsInput | $Enums.enum_Saques_tipo
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaquesCreateManyInput = {
    id?: number
    usuarioId: number
    valor: Decimal | DecimalJsLike | number | string
    status?: $Enums.enum_Saques_status | null
    tipo: $Enums.enum_Saques_tipo
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type SaquesUpdateManyMutationInput = {
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: NullableEnumenum_Saques_statusFieldUpdateOperationsInput | $Enums.enum_Saques_status | null
    tipo?: Enumenum_Saques_tipoFieldUpdateOperationsInput | $Enums.enum_Saques_tipo
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaquesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: NullableEnumenum_Saques_statusFieldUpdateOperationsInput | $Enums.enum_Saques_status | null
    tipo?: Enumenum_Saques_tipoFieldUpdateOperationsInput | $Enums.enum_Saques_tipo
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransacaosCreateInput = {
    tipo: $Enums.enum_Transacaos_tipo
    valor: number
    data: Date | string
    createdAt: Date | string
    updatedAt: Date | string
    Usuarios: UsuariosCreateNestedOneWithoutTransacaosInput
  }

  export type TransacaosUncheckedCreateInput = {
    id?: number
    usuario_id: number
    tipo: $Enums.enum_Transacaos_tipo
    valor: number
    data: Date | string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TransacaosUpdateInput = {
    tipo?: Enumenum_Transacaos_tipoFieldUpdateOperationsInput | $Enums.enum_Transacaos_tipo
    valor?: FloatFieldUpdateOperationsInput | number
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Usuarios?: UsuariosUpdateOneRequiredWithoutTransacaosNestedInput
  }

  export type TransacaosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
    tipo?: Enumenum_Transacaos_tipoFieldUpdateOperationsInput | $Enums.enum_Transacaos_tipo
    valor?: FloatFieldUpdateOperationsInput | number
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransacaosCreateManyInput = {
    id?: number
    usuario_id: number
    tipo: $Enums.enum_Transacaos_tipo
    valor: number
    data: Date | string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TransacaosUpdateManyMutationInput = {
    tipo?: Enumenum_Transacaos_tipoFieldUpdateOperationsInput | $Enums.enum_Transacaos_tipo
    valor?: FloatFieldUpdateOperationsInput | number
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransacaosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
    tipo?: Enumenum_Transacaos_tipoFieldUpdateOperationsInput | $Enums.enum_Transacaos_tipo
    valor?: FloatFieldUpdateOperationsInput | number
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuariosCreateInput = {
    nome: string
    email: string
    cpf?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    Indicacaos_Indicacaos_indicadoIdToUsuarios?: IndicacaosCreateNestedManyWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput
    Indicacaos_Indicacaos_indicanteIdToUsuarios?: IndicacaosCreateNestedManyWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput
    Recompensas?: RecompensasCreateNestedManyWithoutUsuariosInput
    Saques?: SaquesCreateNestedManyWithoutUsuariosInput
    Transacaos?: TransacaosCreateNestedManyWithoutUsuariosInput
  }

  export type UsuariosUncheckedCreateInput = {
    id?: number
    nome: string
    email: string
    cpf?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    Indicacaos_Indicacaos_indicadoIdToUsuarios?: IndicacaosUncheckedCreateNestedManyWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput
    Indicacaos_Indicacaos_indicanteIdToUsuarios?: IndicacaosUncheckedCreateNestedManyWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput
    Recompensas?: RecompensasUncheckedCreateNestedManyWithoutUsuariosInput
    Saques?: SaquesUncheckedCreateNestedManyWithoutUsuariosInput
    Transacaos?: TransacaosUncheckedCreateNestedManyWithoutUsuariosInput
  }

  export type UsuariosUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Indicacaos_Indicacaos_indicadoIdToUsuarios?: IndicacaosUpdateManyWithoutUsuarios_Indicacaos_indicadoIdToUsuariosNestedInput
    Indicacaos_Indicacaos_indicanteIdToUsuarios?: IndicacaosUpdateManyWithoutUsuarios_Indicacaos_indicanteIdToUsuariosNestedInput
    Recompensas?: RecompensasUpdateManyWithoutUsuariosNestedInput
    Saques?: SaquesUpdateManyWithoutUsuariosNestedInput
    Transacaos?: TransacaosUpdateManyWithoutUsuariosNestedInput
  }

  export type UsuariosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Indicacaos_Indicacaos_indicadoIdToUsuarios?: IndicacaosUncheckedUpdateManyWithoutUsuarios_Indicacaos_indicadoIdToUsuariosNestedInput
    Indicacaos_Indicacaos_indicanteIdToUsuarios?: IndicacaosUncheckedUpdateManyWithoutUsuarios_Indicacaos_indicanteIdToUsuariosNestedInput
    Recompensas?: RecompensasUncheckedUpdateManyWithoutUsuariosNestedInput
    Saques?: SaquesUncheckedUpdateManyWithoutUsuariosNestedInput
    Transacaos?: TransacaosUncheckedUpdateManyWithoutUsuariosNestedInput
  }

  export type UsuariosCreateManyInput = {
    id?: number
    nome: string
    email: string
    cpf?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type UsuariosUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuariosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VeiculosCreateInput = {
    motorista_id: number
    modelo: string
    placa: string
    ano: number
    categoria?: $Enums.enum_Veiculos_categoria | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type VeiculosUncheckedCreateInput = {
    id?: number
    motorista_id: number
    modelo: string
    placa: string
    ano: number
    categoria?: $Enums.enum_Veiculos_categoria | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type VeiculosUpdateInput = {
    motorista_id?: IntFieldUpdateOperationsInput | number
    modelo?: StringFieldUpdateOperationsInput | string
    placa?: StringFieldUpdateOperationsInput | string
    ano?: IntFieldUpdateOperationsInput | number
    categoria?: NullableEnumenum_Veiculos_categoriaFieldUpdateOperationsInput | $Enums.enum_Veiculos_categoria | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VeiculosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    motorista_id?: IntFieldUpdateOperationsInput | number
    modelo?: StringFieldUpdateOperationsInput | string
    placa?: StringFieldUpdateOperationsInput | string
    ano?: IntFieldUpdateOperationsInput | number
    categoria?: NullableEnumenum_Veiculos_categoriaFieldUpdateOperationsInput | $Enums.enum_Veiculos_categoria | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VeiculosCreateManyInput = {
    id?: number
    motorista_id: number
    modelo: string
    placa: string
    ano: number
    categoria?: $Enums.enum_Veiculos_categoria | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type VeiculosUpdateManyMutationInput = {
    motorista_id?: IntFieldUpdateOperationsInput | number
    modelo?: StringFieldUpdateOperationsInput | string
    placa?: StringFieldUpdateOperationsInput | string
    ano?: IntFieldUpdateOperationsInput | number
    categoria?: NullableEnumenum_Veiculos_categoriaFieldUpdateOperationsInput | $Enums.enum_Veiculos_categoria | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VeiculosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    motorista_id?: IntFieldUpdateOperationsInput | number
    modelo?: StringFieldUpdateOperationsInput | string
    placa?: StringFieldUpdateOperationsInput | string
    ano?: IntFieldUpdateOperationsInput | number
    categoria?: NullableEnumenum_Veiculos_categoriaFieldUpdateOperationsInput | $Enums.enum_Veiculos_categoria | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type agenda_corridasCreateInput = {
    passageiro_id: number
    categoria: $Enums.enum_agenda_corridas_categoria
    endereco_origem: string
    endereco_destino: string
    data_hora: Date | string
    status?: $Enums.enum_agenda_corridas_status | null
    motorista_id?: number | null
    valor_previsto?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type agenda_corridasUncheckedCreateInput = {
    id?: number
    passageiro_id: number
    categoria: $Enums.enum_agenda_corridas_categoria
    endereco_origem: string
    endereco_destino: string
    data_hora: Date | string
    status?: $Enums.enum_agenda_corridas_status | null
    motorista_id?: number | null
    valor_previsto?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type agenda_corridasUpdateInput = {
    passageiro_id?: IntFieldUpdateOperationsInput | number
    categoria?: Enumenum_agenda_corridas_categoriaFieldUpdateOperationsInput | $Enums.enum_agenda_corridas_categoria
    endereco_origem?: StringFieldUpdateOperationsInput | string
    endereco_destino?: StringFieldUpdateOperationsInput | string
    data_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumenum_agenda_corridas_statusFieldUpdateOperationsInput | $Enums.enum_agenda_corridas_status | null
    motorista_id?: NullableIntFieldUpdateOperationsInput | number | null
    valor_previsto?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type agenda_corridasUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    passageiro_id?: IntFieldUpdateOperationsInput | number
    categoria?: Enumenum_agenda_corridas_categoriaFieldUpdateOperationsInput | $Enums.enum_agenda_corridas_categoria
    endereco_origem?: StringFieldUpdateOperationsInput | string
    endereco_destino?: StringFieldUpdateOperationsInput | string
    data_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumenum_agenda_corridas_statusFieldUpdateOperationsInput | $Enums.enum_agenda_corridas_status | null
    motorista_id?: NullableIntFieldUpdateOperationsInput | number | null
    valor_previsto?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type agenda_corridasCreateManyInput = {
    id?: number
    passageiro_id: number
    categoria: $Enums.enum_agenda_corridas_categoria
    endereco_origem: string
    endereco_destino: string
    data_hora: Date | string
    status?: $Enums.enum_agenda_corridas_status | null
    motorista_id?: number | null
    valor_previsto?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type agenda_corridasUpdateManyMutationInput = {
    passageiro_id?: IntFieldUpdateOperationsInput | number
    categoria?: Enumenum_agenda_corridas_categoriaFieldUpdateOperationsInput | $Enums.enum_agenda_corridas_categoria
    endereco_origem?: StringFieldUpdateOperationsInput | string
    endereco_destino?: StringFieldUpdateOperationsInput | string
    data_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumenum_agenda_corridas_statusFieldUpdateOperationsInput | $Enums.enum_agenda_corridas_status | null
    motorista_id?: NullableIntFieldUpdateOperationsInput | number | null
    valor_previsto?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type agenda_corridasUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    passageiro_id?: IntFieldUpdateOperationsInput | number
    categoria?: Enumenum_agenda_corridas_categoriaFieldUpdateOperationsInput | $Enums.enum_agenda_corridas_categoria
    endereco_origem?: StringFieldUpdateOperationsInput | string
    endereco_destino?: StringFieldUpdateOperationsInput | string
    data_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumenum_agenda_corridas_statusFieldUpdateOperationsInput | $Enums.enum_agenda_corridas_status | null
    motorista_id?: NullableIntFieldUpdateOperationsInput | number | null
    valor_previsto?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type avaliacoesCreateInput = {
    avaliador_id: number
    avaliado_id: number
    tipo: $Enums.enum_avaliacoes_tipo
    nota: number
    comentario?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type avaliacoesUncheckedCreateInput = {
    id?: number
    avaliador_id: number
    avaliado_id: number
    tipo: $Enums.enum_avaliacoes_tipo
    nota: number
    comentario?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type avaliacoesUpdateInput = {
    avaliador_id?: IntFieldUpdateOperationsInput | number
    avaliado_id?: IntFieldUpdateOperationsInput | number
    tipo?: Enumenum_avaliacoes_tipoFieldUpdateOperationsInput | $Enums.enum_avaliacoes_tipo
    nota?: FloatFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type avaliacoesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    avaliador_id?: IntFieldUpdateOperationsInput | number
    avaliado_id?: IntFieldUpdateOperationsInput | number
    tipo?: Enumenum_avaliacoes_tipoFieldUpdateOperationsInput | $Enums.enum_avaliacoes_tipo
    nota?: FloatFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type avaliacoesCreateManyInput = {
    id?: number
    avaliador_id: number
    avaliado_id: number
    tipo: $Enums.enum_avaliacoes_tipo
    nota: number
    comentario?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type avaliacoesUpdateManyMutationInput = {
    avaliador_id?: IntFieldUpdateOperationsInput | number
    avaliado_id?: IntFieldUpdateOperationsInput | number
    tipo?: Enumenum_avaliacoes_tipoFieldUpdateOperationsInput | $Enums.enum_avaliacoes_tipo
    nota?: FloatFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type avaliacoesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    avaliador_id?: IntFieldUpdateOperationsInput | number
    avaliado_id?: IntFieldUpdateOperationsInput | number
    tipo?: Enumenum_avaliacoes_tipoFieldUpdateOperationsInput | $Enums.enum_avaliacoes_tipo
    nota?: FloatFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bairros_prioridadeCreateInput = {
    nome: string
    cidade: string
    estado: string
    ativo?: boolean | null
    tipo_prioridade: $Enums.enum_bairros_prioridade_tipo_prioridade
    observacoes?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type bairros_prioridadeUncheckedCreateInput = {
    id?: number
    nome: string
    cidade: string
    estado: string
    ativo?: boolean | null
    tipo_prioridade: $Enums.enum_bairros_prioridade_tipo_prioridade
    observacoes?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type bairros_prioridadeUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tipo_prioridade?: Enumenum_bairros_prioridade_tipo_prioridadeFieldUpdateOperationsInput | $Enums.enum_bairros_prioridade_tipo_prioridade
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bairros_prioridadeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tipo_prioridade?: Enumenum_bairros_prioridade_tipo_prioridadeFieldUpdateOperationsInput | $Enums.enum_bairros_prioridade_tipo_prioridade
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bairros_prioridadeCreateManyInput = {
    id?: number
    nome: string
    cidade: string
    estado: string
    ativo?: boolean | null
    tipo_prioridade: $Enums.enum_bairros_prioridade_tipo_prioridade
    observacoes?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type bairros_prioridadeUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tipo_prioridade?: Enumenum_bairros_prioridade_tipo_prioridadeFieldUpdateOperationsInput | $Enums.enum_bairros_prioridade_tipo_prioridade
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bairros_prioridadeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tipo_prioridade?: Enumenum_bairros_prioridade_tipo_prioridadeFieldUpdateOperationsInput | $Enums.enum_bairros_prioridade_tipo_prioridade
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type carteirasCreateInput = {
    usuario_id: number
    tipo: $Enums.enum_carteiras_tipo
    saldo?: number
    ultima_atualizacao?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type carteirasUncheckedCreateInput = {
    id?: number
    usuario_id: number
    tipo: $Enums.enum_carteiras_tipo
    saldo?: number
    ultima_atualizacao?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type carteirasUpdateInput = {
    usuario_id?: IntFieldUpdateOperationsInput | number
    tipo?: Enumenum_carteiras_tipoFieldUpdateOperationsInput | $Enums.enum_carteiras_tipo
    saldo?: FloatFieldUpdateOperationsInput | number
    ultima_atualizacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type carteirasUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
    tipo?: Enumenum_carteiras_tipoFieldUpdateOperationsInput | $Enums.enum_carteiras_tipo
    saldo?: FloatFieldUpdateOperationsInput | number
    ultima_atualizacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type carteirasCreateManyInput = {
    id?: number
    usuario_id: number
    tipo: $Enums.enum_carteiras_tipo
    saldo?: number
    ultima_atualizacao?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type carteirasUpdateManyMutationInput = {
    usuario_id?: IntFieldUpdateOperationsInput | number
    tipo?: Enumenum_carteiras_tipoFieldUpdateOperationsInput | $Enums.enum_carteiras_tipo
    saldo?: FloatFieldUpdateOperationsInput | number
    ultima_atualizacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type carteirasUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
    tipo?: Enumenum_carteiras_tipoFieldUpdateOperationsInput | $Enums.enum_carteiras_tipo
    saldo?: FloatFieldUpdateOperationsInput | number
    ultima_atualizacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type corridasCreateInput = {
    id_motorista: number
    id_passageiro: number
    origem: string
    destino: string
    status?: $Enums.enum_corridas_status | null
    distancia_km: number
    valor_total: number
    forma_pagamento: $Enums.enum_corridas_forma_pagamento
    data_hora?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type corridasUncheckedCreateInput = {
    id?: number
    id_motorista: number
    id_passageiro: number
    origem: string
    destino: string
    status?: $Enums.enum_corridas_status | null
    distancia_km: number
    valor_total: number
    forma_pagamento: $Enums.enum_corridas_forma_pagamento
    data_hora?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type corridasUpdateInput = {
    id_motorista?: IntFieldUpdateOperationsInput | number
    id_passageiro?: IntFieldUpdateOperationsInput | number
    origem?: StringFieldUpdateOperationsInput | string
    destino?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumenum_corridas_statusFieldUpdateOperationsInput | $Enums.enum_corridas_status | null
    distancia_km?: FloatFieldUpdateOperationsInput | number
    valor_total?: FloatFieldUpdateOperationsInput | number
    forma_pagamento?: Enumenum_corridas_forma_pagamentoFieldUpdateOperationsInput | $Enums.enum_corridas_forma_pagamento
    data_hora?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type corridasUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_motorista?: IntFieldUpdateOperationsInput | number
    id_passageiro?: IntFieldUpdateOperationsInput | number
    origem?: StringFieldUpdateOperationsInput | string
    destino?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumenum_corridas_statusFieldUpdateOperationsInput | $Enums.enum_corridas_status | null
    distancia_km?: FloatFieldUpdateOperationsInput | number
    valor_total?: FloatFieldUpdateOperationsInput | number
    forma_pagamento?: Enumenum_corridas_forma_pagamentoFieldUpdateOperationsInput | $Enums.enum_corridas_forma_pagamento
    data_hora?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type corridasCreateManyInput = {
    id?: number
    id_motorista: number
    id_passageiro: number
    origem: string
    destino: string
    status?: $Enums.enum_corridas_status | null
    distancia_km: number
    valor_total: number
    forma_pagamento: $Enums.enum_corridas_forma_pagamento
    data_hora?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type corridasUpdateManyMutationInput = {
    id_motorista?: IntFieldUpdateOperationsInput | number
    id_passageiro?: IntFieldUpdateOperationsInput | number
    origem?: StringFieldUpdateOperationsInput | string
    destino?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumenum_corridas_statusFieldUpdateOperationsInput | $Enums.enum_corridas_status | null
    distancia_km?: FloatFieldUpdateOperationsInput | number
    valor_total?: FloatFieldUpdateOperationsInput | number
    forma_pagamento?: Enumenum_corridas_forma_pagamentoFieldUpdateOperationsInput | $Enums.enum_corridas_forma_pagamento
    data_hora?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type corridasUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_motorista?: IntFieldUpdateOperationsInput | number
    id_passageiro?: IntFieldUpdateOperationsInput | number
    origem?: StringFieldUpdateOperationsInput | string
    destino?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumenum_corridas_statusFieldUpdateOperationsInput | $Enums.enum_corridas_status | null
    distancia_km?: FloatFieldUpdateOperationsInput | number
    valor_total?: FloatFieldUpdateOperationsInput | number
    forma_pagamento?: Enumenum_corridas_forma_pagamentoFieldUpdateOperationsInput | $Enums.enum_corridas_forma_pagamento
    data_hora?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type denunciasCreateInput = {
    autor_id: number
    alvo_id: number
    tipo_alvo: $Enums.enum_denuncias_tipo_alvo
    corrida_id?: number | null
    motivo: string
    descricao?: string | null
    status?: $Enums.enum_denuncias_status | null
    data_denuncia?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type denunciasUncheckedCreateInput = {
    id?: number
    autor_id: number
    alvo_id: number
    tipo_alvo: $Enums.enum_denuncias_tipo_alvo
    corrida_id?: number | null
    motivo: string
    descricao?: string | null
    status?: $Enums.enum_denuncias_status | null
    data_denuncia?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type denunciasUpdateInput = {
    autor_id?: IntFieldUpdateOperationsInput | number
    alvo_id?: IntFieldUpdateOperationsInput | number
    tipo_alvo?: Enumenum_denuncias_tipo_alvoFieldUpdateOperationsInput | $Enums.enum_denuncias_tipo_alvo
    corrida_id?: NullableIntFieldUpdateOperationsInput | number | null
    motivo?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumenum_denuncias_statusFieldUpdateOperationsInput | $Enums.enum_denuncias_status | null
    data_denuncia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type denunciasUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    autor_id?: IntFieldUpdateOperationsInput | number
    alvo_id?: IntFieldUpdateOperationsInput | number
    tipo_alvo?: Enumenum_denuncias_tipo_alvoFieldUpdateOperationsInput | $Enums.enum_denuncias_tipo_alvo
    corrida_id?: NullableIntFieldUpdateOperationsInput | number | null
    motivo?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumenum_denuncias_statusFieldUpdateOperationsInput | $Enums.enum_denuncias_status | null
    data_denuncia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type denunciasCreateManyInput = {
    id?: number
    autor_id: number
    alvo_id: number
    tipo_alvo: $Enums.enum_denuncias_tipo_alvo
    corrida_id?: number | null
    motivo: string
    descricao?: string | null
    status?: $Enums.enum_denuncias_status | null
    data_denuncia?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type denunciasUpdateManyMutationInput = {
    autor_id?: IntFieldUpdateOperationsInput | number
    alvo_id?: IntFieldUpdateOperationsInput | number
    tipo_alvo?: Enumenum_denuncias_tipo_alvoFieldUpdateOperationsInput | $Enums.enum_denuncias_tipo_alvo
    corrida_id?: NullableIntFieldUpdateOperationsInput | number | null
    motivo?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumenum_denuncias_statusFieldUpdateOperationsInput | $Enums.enum_denuncias_status | null
    data_denuncia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type denunciasUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    autor_id?: IntFieldUpdateOperationsInput | number
    alvo_id?: IntFieldUpdateOperationsInput | number
    tipo_alvo?: Enumenum_denuncias_tipo_alvoFieldUpdateOperationsInput | $Enums.enum_denuncias_tipo_alvo
    corrida_id?: NullableIntFieldUpdateOperationsInput | number | null
    motivo?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumenum_denuncias_statusFieldUpdateOperationsInput | $Enums.enum_denuncias_status | null
    data_denuncia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type documentosCreateInput = {
    usuario_id: number
    tipo_documento: $Enums.enum_documentos_tipo_documento
    arquivo_url: string
    status?: $Enums.enum_documentos_status | null
    motivo_rejeicao?: string | null
    data_envio?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type documentosUncheckedCreateInput = {
    id?: number
    usuario_id: number
    tipo_documento: $Enums.enum_documentos_tipo_documento
    arquivo_url: string
    status?: $Enums.enum_documentos_status | null
    motivo_rejeicao?: string | null
    data_envio?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type documentosUpdateInput = {
    usuario_id?: IntFieldUpdateOperationsInput | number
    tipo_documento?: Enumenum_documentos_tipo_documentoFieldUpdateOperationsInput | $Enums.enum_documentos_tipo_documento
    arquivo_url?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumenum_documentos_statusFieldUpdateOperationsInput | $Enums.enum_documentos_status | null
    motivo_rejeicao?: NullableStringFieldUpdateOperationsInput | string | null
    data_envio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type documentosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
    tipo_documento?: Enumenum_documentos_tipo_documentoFieldUpdateOperationsInput | $Enums.enum_documentos_tipo_documento
    arquivo_url?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumenum_documentos_statusFieldUpdateOperationsInput | $Enums.enum_documentos_status | null
    motivo_rejeicao?: NullableStringFieldUpdateOperationsInput | string | null
    data_envio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type documentosCreateManyInput = {
    id?: number
    usuario_id: number
    tipo_documento: $Enums.enum_documentos_tipo_documento
    arquivo_url: string
    status?: $Enums.enum_documentos_status | null
    motivo_rejeicao?: string | null
    data_envio?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type documentosUpdateManyMutationInput = {
    usuario_id?: IntFieldUpdateOperationsInput | number
    tipo_documento?: Enumenum_documentos_tipo_documentoFieldUpdateOperationsInput | $Enums.enum_documentos_tipo_documento
    arquivo_url?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumenum_documentos_statusFieldUpdateOperationsInput | $Enums.enum_documentos_status | null
    motivo_rejeicao?: NullableStringFieldUpdateOperationsInput | string | null
    data_envio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type documentosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
    tipo_documento?: Enumenum_documentos_tipo_documentoFieldUpdateOperationsInput | $Enums.enum_documentos_tipo_documento
    arquivo_url?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumenum_documentos_statusFieldUpdateOperationsInput | $Enums.enum_documentos_status | null
    motivo_rejeicao?: NullableStringFieldUpdateOperationsInput | string | null
    data_envio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type emails_enviadosCreateInput = {
    usuario_id: number
    email: string
    tipo: $Enums.enum_emails_enviados_tipo
    titulo: string
    conteudo?: string | null
    status_envio?: $Enums.enum_emails_enviados_status_envio | null
    data_envio?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type emails_enviadosUncheckedCreateInput = {
    id?: number
    usuario_id: number
    email: string
    tipo: $Enums.enum_emails_enviados_tipo
    titulo: string
    conteudo?: string | null
    status_envio?: $Enums.enum_emails_enviados_status_envio | null
    data_envio?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type emails_enviadosUpdateInput = {
    usuario_id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    tipo?: Enumenum_emails_enviados_tipoFieldUpdateOperationsInput | $Enums.enum_emails_enviados_tipo
    titulo?: StringFieldUpdateOperationsInput | string
    conteudo?: NullableStringFieldUpdateOperationsInput | string | null
    status_envio?: NullableEnumenum_emails_enviados_status_envioFieldUpdateOperationsInput | $Enums.enum_emails_enviados_status_envio | null
    data_envio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type emails_enviadosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    tipo?: Enumenum_emails_enviados_tipoFieldUpdateOperationsInput | $Enums.enum_emails_enviados_tipo
    titulo?: StringFieldUpdateOperationsInput | string
    conteudo?: NullableStringFieldUpdateOperationsInput | string | null
    status_envio?: NullableEnumenum_emails_enviados_status_envioFieldUpdateOperationsInput | $Enums.enum_emails_enviados_status_envio | null
    data_envio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type emails_enviadosCreateManyInput = {
    id?: number
    usuario_id: number
    email: string
    tipo: $Enums.enum_emails_enviados_tipo
    titulo: string
    conteudo?: string | null
    status_envio?: $Enums.enum_emails_enviados_status_envio | null
    data_envio?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type emails_enviadosUpdateManyMutationInput = {
    usuario_id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    tipo?: Enumenum_emails_enviados_tipoFieldUpdateOperationsInput | $Enums.enum_emails_enviados_tipo
    titulo?: StringFieldUpdateOperationsInput | string
    conteudo?: NullableStringFieldUpdateOperationsInput | string | null
    status_envio?: NullableEnumenum_emails_enviados_status_envioFieldUpdateOperationsInput | $Enums.enum_emails_enviados_status_envio | null
    data_envio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type emails_enviadosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    tipo?: Enumenum_emails_enviados_tipoFieldUpdateOperationsInput | $Enums.enum_emails_enviados_tipo
    titulo?: StringFieldUpdateOperationsInput | string
    conteudo?: NullableStringFieldUpdateOperationsInput | string | null
    status_envio?: NullableEnumenum_emails_enviados_status_envioFieldUpdateOperationsInput | $Enums.enum_emails_enviados_status_envio | null
    data_envio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type historico_indicacoesCreateInput = {
    indicador_id: number
    indicado_id: number
    tipo: $Enums.enum_historico_indicacoes_tipo
    data_vinculo?: Date | string | null
    codigo_utilizado?: string | null
    ativo?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type historico_indicacoesUncheckedCreateInput = {
    id?: number
    indicador_id: number
    indicado_id: number
    tipo: $Enums.enum_historico_indicacoes_tipo
    data_vinculo?: Date | string | null
    codigo_utilizado?: string | null
    ativo?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type historico_indicacoesUpdateInput = {
    indicador_id?: IntFieldUpdateOperationsInput | number
    indicado_id?: IntFieldUpdateOperationsInput | number
    tipo?: Enumenum_historico_indicacoes_tipoFieldUpdateOperationsInput | $Enums.enum_historico_indicacoes_tipo
    data_vinculo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    codigo_utilizado?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type historico_indicacoesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    indicador_id?: IntFieldUpdateOperationsInput | number
    indicado_id?: IntFieldUpdateOperationsInput | number
    tipo?: Enumenum_historico_indicacoes_tipoFieldUpdateOperationsInput | $Enums.enum_historico_indicacoes_tipo
    data_vinculo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    codigo_utilizado?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type historico_indicacoesCreateManyInput = {
    id?: number
    indicador_id: number
    indicado_id: number
    tipo: $Enums.enum_historico_indicacoes_tipo
    data_vinculo?: Date | string | null
    codigo_utilizado?: string | null
    ativo?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type historico_indicacoesUpdateManyMutationInput = {
    indicador_id?: IntFieldUpdateOperationsInput | number
    indicado_id?: IntFieldUpdateOperationsInput | number
    tipo?: Enumenum_historico_indicacoes_tipoFieldUpdateOperationsInput | $Enums.enum_historico_indicacoes_tipo
    data_vinculo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    codigo_utilizado?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type historico_indicacoesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    indicador_id?: IntFieldUpdateOperationsInput | number
    indicado_id?: IntFieldUpdateOperationsInput | number
    tipo?: Enumenum_historico_indicacoes_tipoFieldUpdateOperationsInput | $Enums.enum_historico_indicacoes_tipo
    data_vinculo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    codigo_utilizado?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type historico_selfiesCreateInput = {
    usuario_id: number
    tipo: $Enums.enum_historico_selfies_tipo
    imagem_url: string
    resultado?: $Enums.enum_historico_selfies_resultado | null
    motivo_falha?: string | null
    data_envio?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type historico_selfiesUncheckedCreateInput = {
    id?: number
    usuario_id: number
    tipo: $Enums.enum_historico_selfies_tipo
    imagem_url: string
    resultado?: $Enums.enum_historico_selfies_resultado | null
    motivo_falha?: string | null
    data_envio?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type historico_selfiesUpdateInput = {
    usuario_id?: IntFieldUpdateOperationsInput | number
    tipo?: Enumenum_historico_selfies_tipoFieldUpdateOperationsInput | $Enums.enum_historico_selfies_tipo
    imagem_url?: StringFieldUpdateOperationsInput | string
    resultado?: NullableEnumenum_historico_selfies_resultadoFieldUpdateOperationsInput | $Enums.enum_historico_selfies_resultado | null
    motivo_falha?: NullableStringFieldUpdateOperationsInput | string | null
    data_envio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type historico_selfiesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
    tipo?: Enumenum_historico_selfies_tipoFieldUpdateOperationsInput | $Enums.enum_historico_selfies_tipo
    imagem_url?: StringFieldUpdateOperationsInput | string
    resultado?: NullableEnumenum_historico_selfies_resultadoFieldUpdateOperationsInput | $Enums.enum_historico_selfies_resultado | null
    motivo_falha?: NullableStringFieldUpdateOperationsInput | string | null
    data_envio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type historico_selfiesCreateManyInput = {
    id?: number
    usuario_id: number
    tipo: $Enums.enum_historico_selfies_tipo
    imagem_url: string
    resultado?: $Enums.enum_historico_selfies_resultado | null
    motivo_falha?: string | null
    data_envio?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type historico_selfiesUpdateManyMutationInput = {
    usuario_id?: IntFieldUpdateOperationsInput | number
    tipo?: Enumenum_historico_selfies_tipoFieldUpdateOperationsInput | $Enums.enum_historico_selfies_tipo
    imagem_url?: StringFieldUpdateOperationsInput | string
    resultado?: NullableEnumenum_historico_selfies_resultadoFieldUpdateOperationsInput | $Enums.enum_historico_selfies_resultado | null
    motivo_falha?: NullableStringFieldUpdateOperationsInput | string | null
    data_envio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type historico_selfiesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
    tipo?: Enumenum_historico_selfies_tipoFieldUpdateOperationsInput | $Enums.enum_historico_selfies_tipo
    imagem_url?: StringFieldUpdateOperationsInput | string
    resultado?: NullableEnumenum_historico_selfies_resultadoFieldUpdateOperationsInput | $Enums.enum_historico_selfies_resultado | null
    motivo_falha?: NullableStringFieldUpdateOperationsInput | string | null
    data_envio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type logs_acessoCreateInput = {
    usuario_id: number
    tipo_usuario: $Enums.enum_logs_acesso_tipo_usuario
    acao: string
    descricao?: string | null
    ip?: string | null
    dispositivo?: string | null
    data?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type logs_acessoUncheckedCreateInput = {
    id?: number
    usuario_id: number
    tipo_usuario: $Enums.enum_logs_acesso_tipo_usuario
    acao: string
    descricao?: string | null
    ip?: string | null
    dispositivo?: string | null
    data?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type logs_acessoUpdateInput = {
    usuario_id?: IntFieldUpdateOperationsInput | number
    tipo_usuario?: Enumenum_logs_acesso_tipo_usuarioFieldUpdateOperationsInput | $Enums.enum_logs_acesso_tipo_usuario
    acao?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    dispositivo?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type logs_acessoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
    tipo_usuario?: Enumenum_logs_acesso_tipo_usuarioFieldUpdateOperationsInput | $Enums.enum_logs_acesso_tipo_usuario
    acao?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    dispositivo?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type logs_acessoCreateManyInput = {
    id?: number
    usuario_id: number
    tipo_usuario: $Enums.enum_logs_acesso_tipo_usuario
    acao: string
    descricao?: string | null
    ip?: string | null
    dispositivo?: string | null
    data?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type logs_acessoUpdateManyMutationInput = {
    usuario_id?: IntFieldUpdateOperationsInput | number
    tipo_usuario?: Enumenum_logs_acesso_tipo_usuarioFieldUpdateOperationsInput | $Enums.enum_logs_acesso_tipo_usuario
    acao?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    dispositivo?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type logs_acessoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
    tipo_usuario?: Enumenum_logs_acesso_tipo_usuarioFieldUpdateOperationsInput | $Enums.enum_logs_acesso_tipo_usuario
    acao?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    dispositivo?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type mensagens_suporteCreateInput = {
    usuario_id: number
    tipo_usuario: $Enums.enum_mensagens_suporte_tipo_usuario
    mensagem: string
    resposta_sistema?: boolean | null
    status?: $Enums.enum_mensagens_suporte_status | null
    data_envio?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type mensagens_suporteUncheckedCreateInput = {
    id?: number
    usuario_id: number
    tipo_usuario: $Enums.enum_mensagens_suporte_tipo_usuario
    mensagem: string
    resposta_sistema?: boolean | null
    status?: $Enums.enum_mensagens_suporte_status | null
    data_envio?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type mensagens_suporteUpdateInput = {
    usuario_id?: IntFieldUpdateOperationsInput | number
    tipo_usuario?: Enumenum_mensagens_suporte_tipo_usuarioFieldUpdateOperationsInput | $Enums.enum_mensagens_suporte_tipo_usuario
    mensagem?: StringFieldUpdateOperationsInput | string
    resposta_sistema?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableEnumenum_mensagens_suporte_statusFieldUpdateOperationsInput | $Enums.enum_mensagens_suporte_status | null
    data_envio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type mensagens_suporteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
    tipo_usuario?: Enumenum_mensagens_suporte_tipo_usuarioFieldUpdateOperationsInput | $Enums.enum_mensagens_suporte_tipo_usuario
    mensagem?: StringFieldUpdateOperationsInput | string
    resposta_sistema?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableEnumenum_mensagens_suporte_statusFieldUpdateOperationsInput | $Enums.enum_mensagens_suporte_status | null
    data_envio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type mensagens_suporteCreateManyInput = {
    id?: number
    usuario_id: number
    tipo_usuario: $Enums.enum_mensagens_suporte_tipo_usuario
    mensagem: string
    resposta_sistema?: boolean | null
    status?: $Enums.enum_mensagens_suporte_status | null
    data_envio?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type mensagens_suporteUpdateManyMutationInput = {
    usuario_id?: IntFieldUpdateOperationsInput | number
    tipo_usuario?: Enumenum_mensagens_suporte_tipo_usuarioFieldUpdateOperationsInput | $Enums.enum_mensagens_suporte_tipo_usuario
    mensagem?: StringFieldUpdateOperationsInput | string
    resposta_sistema?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableEnumenum_mensagens_suporte_statusFieldUpdateOperationsInput | $Enums.enum_mensagens_suporte_status | null
    data_envio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type mensagens_suporteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
    tipo_usuario?: Enumenum_mensagens_suporte_tipo_usuarioFieldUpdateOperationsInput | $Enums.enum_mensagens_suporte_tipo_usuario
    mensagem?: StringFieldUpdateOperationsInput | string
    resposta_sistema?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableEnumenum_mensagens_suporte_statusFieldUpdateOperationsInput | $Enums.enum_mensagens_suporte_status | null
    data_envio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pagamentos_pessoaisCreateInput = {
    motorista_id: number
    passageiro_id: number
    valor: number
    valor_maximo: number
    aceito_pelo_app?: boolean | null
    data_corrida?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type pagamentos_pessoaisUncheckedCreateInput = {
    id?: number
    motorista_id: number
    passageiro_id: number
    valor: number
    valor_maximo: number
    aceito_pelo_app?: boolean | null
    data_corrida?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type pagamentos_pessoaisUpdateInput = {
    motorista_id?: IntFieldUpdateOperationsInput | number
    passageiro_id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    valor_maximo?: FloatFieldUpdateOperationsInput | number
    aceito_pelo_app?: NullableBoolFieldUpdateOperationsInput | boolean | null
    data_corrida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pagamentos_pessoaisUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    motorista_id?: IntFieldUpdateOperationsInput | number
    passageiro_id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    valor_maximo?: FloatFieldUpdateOperationsInput | number
    aceito_pelo_app?: NullableBoolFieldUpdateOperationsInput | boolean | null
    data_corrida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pagamentos_pessoaisCreateManyInput = {
    id?: number
    motorista_id: number
    passageiro_id: number
    valor: number
    valor_maximo: number
    aceito_pelo_app?: boolean | null
    data_corrida?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type pagamentos_pessoaisUpdateManyMutationInput = {
    motorista_id?: IntFieldUpdateOperationsInput | number
    passageiro_id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    valor_maximo?: FloatFieldUpdateOperationsInput | number
    aceito_pelo_app?: NullableBoolFieldUpdateOperationsInput | boolean | null
    data_corrida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pagamentos_pessoaisUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    motorista_id?: IntFieldUpdateOperationsInput | number
    passageiro_id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    valor_maximo?: FloatFieldUpdateOperationsInput | number
    aceito_pelo_app?: NullableBoolFieldUpdateOperationsInput | boolean | null
    data_corrida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type paradasCreateInput = {
    corrida_id: number
    ordem: number
    endereco: string
    latitude?: number | null
    longitude?: number | null
    tempo_espera?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type paradasUncheckedCreateInput = {
    id?: number
    corrida_id: number
    ordem: number
    endereco: string
    latitude?: number | null
    longitude?: number | null
    tempo_espera?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type paradasUpdateInput = {
    corrida_id?: IntFieldUpdateOperationsInput | number
    ordem?: IntFieldUpdateOperationsInput | number
    endereco?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    tempo_espera?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type paradasUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    corrida_id?: IntFieldUpdateOperationsInput | number
    ordem?: IntFieldUpdateOperationsInput | number
    endereco?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    tempo_espera?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type paradasCreateManyInput = {
    id?: number
    corrida_id: number
    ordem: number
    endereco: string
    latitude?: number | null
    longitude?: number | null
    tempo_espera?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type paradasUpdateManyMutationInput = {
    corrida_id?: IntFieldUpdateOperationsInput | number
    ordem?: IntFieldUpdateOperationsInput | number
    endereco?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    tempo_espera?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type paradasUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    corrida_id?: IntFieldUpdateOperationsInput | number
    ordem?: IntFieldUpdateOperationsInput | number
    endereco?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    tempo_espera?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type recompensasCreateInput = {
    indicador_id: number
    indicado_id: number
    tipo: $Enums.enum_recompensas_tipo
    valor: number
    status?: $Enums.enum_recompensas_status | null
    data_gerada?: Date | string | null
    referencia_corrida?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type recompensasUncheckedCreateInput = {
    id?: number
    indicador_id: number
    indicado_id: number
    tipo: $Enums.enum_recompensas_tipo
    valor: number
    status?: $Enums.enum_recompensas_status | null
    data_gerada?: Date | string | null
    referencia_corrida?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type recompensasUpdateInput = {
    indicador_id?: IntFieldUpdateOperationsInput | number
    indicado_id?: IntFieldUpdateOperationsInput | number
    tipo?: Enumenum_recompensas_tipoFieldUpdateOperationsInput | $Enums.enum_recompensas_tipo
    valor?: FloatFieldUpdateOperationsInput | number
    status?: NullableEnumenum_recompensas_statusFieldUpdateOperationsInput | $Enums.enum_recompensas_status | null
    data_gerada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referencia_corrida?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type recompensasUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    indicador_id?: IntFieldUpdateOperationsInput | number
    indicado_id?: IntFieldUpdateOperationsInput | number
    tipo?: Enumenum_recompensas_tipoFieldUpdateOperationsInput | $Enums.enum_recompensas_tipo
    valor?: FloatFieldUpdateOperationsInput | number
    status?: NullableEnumenum_recompensas_statusFieldUpdateOperationsInput | $Enums.enum_recompensas_status | null
    data_gerada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referencia_corrida?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type recompensasCreateManyInput = {
    id?: number
    indicador_id: number
    indicado_id: number
    tipo: $Enums.enum_recompensas_tipo
    valor: number
    status?: $Enums.enum_recompensas_status | null
    data_gerada?: Date | string | null
    referencia_corrida?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type recompensasUpdateManyMutationInput = {
    indicador_id?: IntFieldUpdateOperationsInput | number
    indicado_id?: IntFieldUpdateOperationsInput | number
    tipo?: Enumenum_recompensas_tipoFieldUpdateOperationsInput | $Enums.enum_recompensas_tipo
    valor?: FloatFieldUpdateOperationsInput | number
    status?: NullableEnumenum_recompensas_statusFieldUpdateOperationsInput | $Enums.enum_recompensas_status | null
    data_gerada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referencia_corrida?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type recompensasUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    indicador_id?: IntFieldUpdateOperationsInput | number
    indicado_id?: IntFieldUpdateOperationsInput | number
    tipo?: Enumenum_recompensas_tipoFieldUpdateOperationsInput | $Enums.enum_recompensas_tipo
    valor?: FloatFieldUpdateOperationsInput | number
    status?: NullableEnumenum_recompensas_statusFieldUpdateOperationsInput | $Enums.enum_recompensas_status | null
    data_gerada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referencia_corrida?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type saquesCreateInput = {
    usuario_id: number
    valor: number
    status?: $Enums.enum_saques_status | null
    tipo: $Enums.enum_saques_tipo
    pix: string
    data_pedido?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type saquesUncheckedCreateInput = {
    id?: number
    usuario_id: number
    valor: number
    status?: $Enums.enum_saques_status | null
    tipo: $Enums.enum_saques_tipo
    pix: string
    data_pedido?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type saquesUpdateInput = {
    usuario_id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    status?: NullableEnumenum_saques_statusFieldUpdateOperationsInput | $Enums.enum_saques_status | null
    tipo?: Enumenum_saques_tipoFieldUpdateOperationsInput | $Enums.enum_saques_tipo
    pix?: StringFieldUpdateOperationsInput | string
    data_pedido?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type saquesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    status?: NullableEnumenum_saques_statusFieldUpdateOperationsInput | $Enums.enum_saques_status | null
    tipo?: Enumenum_saques_tipoFieldUpdateOperationsInput | $Enums.enum_saques_tipo
    pix?: StringFieldUpdateOperationsInput | string
    data_pedido?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type saquesCreateManyInput = {
    id?: number
    usuario_id: number
    valor: number
    status?: $Enums.enum_saques_status | null
    tipo: $Enums.enum_saques_tipo
    pix: string
    data_pedido?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type saquesUpdateManyMutationInput = {
    usuario_id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    status?: NullableEnumenum_saques_statusFieldUpdateOperationsInput | $Enums.enum_saques_status | null
    tipo?: Enumenum_saques_tipoFieldUpdateOperationsInput | $Enums.enum_saques_tipo
    pix?: StringFieldUpdateOperationsInput | string
    data_pedido?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type saquesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    status?: NullableEnumenum_saques_statusFieldUpdateOperationsInput | $Enums.enum_saques_status | null
    tipo?: Enumenum_saques_tipoFieldUpdateOperationsInput | $Enums.enum_saques_tipo
    pix?: StringFieldUpdateOperationsInput | string
    data_pedido?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transacoesCreateInput = {
    usuario_id: number
    tipo: $Enums.enum_transacoes_tipo
    origem: $Enums.enum_transacoes_origem
    descricao?: string | null
    valor: number
    data_transacao?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type transacoesUncheckedCreateInput = {
    id?: number
    usuario_id: number
    tipo: $Enums.enum_transacoes_tipo
    origem: $Enums.enum_transacoes_origem
    descricao?: string | null
    valor: number
    data_transacao?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type transacoesUpdateInput = {
    usuario_id?: IntFieldUpdateOperationsInput | number
    tipo?: Enumenum_transacoes_tipoFieldUpdateOperationsInput | $Enums.enum_transacoes_tipo
    origem?: Enumenum_transacoes_origemFieldUpdateOperationsInput | $Enums.enum_transacoes_origem
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    valor?: FloatFieldUpdateOperationsInput | number
    data_transacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transacoesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
    tipo?: Enumenum_transacoes_tipoFieldUpdateOperationsInput | $Enums.enum_transacoes_tipo
    origem?: Enumenum_transacoes_origemFieldUpdateOperationsInput | $Enums.enum_transacoes_origem
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    valor?: FloatFieldUpdateOperationsInput | number
    data_transacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transacoesCreateManyInput = {
    id?: number
    usuario_id: number
    tipo: $Enums.enum_transacoes_tipo
    origem: $Enums.enum_transacoes_origem
    descricao?: string | null
    valor: number
    data_transacao?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type transacoesUpdateManyMutationInput = {
    usuario_id?: IntFieldUpdateOperationsInput | number
    tipo?: Enumenum_transacoes_tipoFieldUpdateOperationsInput | $Enums.enum_transacoes_tipo
    origem?: Enumenum_transacoes_origemFieldUpdateOperationsInput | $Enums.enum_transacoes_origem
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    valor?: FloatFieldUpdateOperationsInput | number
    data_transacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transacoesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
    tipo?: Enumenum_transacoes_tipoFieldUpdateOperationsInput | $Enums.enum_transacoes_tipo
    origem?: Enumenum_transacoes_origemFieldUpdateOperationsInput | $Enums.enum_transacoes_origem
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    valor?: FloatFieldUpdateOperationsInput | number
    data_transacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usuariosCreateInput = {
    nome: string
    tipo: $Enums.enum_usuarios_tipo
    email?: string | null
    senha: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type usuariosUncheckedCreateInput = {
    id?: number
    nome: string
    tipo: $Enums.enum_usuarios_tipo
    email?: string | null
    senha: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type usuariosUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    tipo?: Enumenum_usuarios_tipoFieldUpdateOperationsInput | $Enums.enum_usuarios_tipo
    email?: NullableStringFieldUpdateOperationsInput | string | null
    senha?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usuariosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    tipo?: Enumenum_usuarios_tipoFieldUpdateOperationsInput | $Enums.enum_usuarios_tipo
    email?: NullableStringFieldUpdateOperationsInput | string | null
    senha?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usuariosCreateManyInput = {
    id?: number
    nome: string
    tipo: $Enums.enum_usuarios_tipo
    email?: string | null
    senha: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type usuariosUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    tipo?: Enumenum_usuarios_tipoFieldUpdateOperationsInput | $Enums.enum_usuarios_tipo
    email?: NullableStringFieldUpdateOperationsInput | string | null
    senha?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usuariosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    tipo?: Enumenum_usuarios_tipoFieldUpdateOperationsInput | $Enums.enum_usuarios_tipo
    email?: NullableStringFieldUpdateOperationsInput | string | null
    senha?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type veiculosCreateInput = {
    motorista_id: number
    modelo: string
    placa: string
    ano: number
    categoria: $Enums.enum_veiculos_categoria
    status?: $Enums.enum_veiculos_status | null
    observacoes?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type veiculosUncheckedCreateInput = {
    id?: number
    motorista_id: number
    modelo: string
    placa: string
    ano: number
    categoria: $Enums.enum_veiculos_categoria
    status?: $Enums.enum_veiculos_status | null
    observacoes?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type veiculosUpdateInput = {
    motorista_id?: IntFieldUpdateOperationsInput | number
    modelo?: StringFieldUpdateOperationsInput | string
    placa?: StringFieldUpdateOperationsInput | string
    ano?: IntFieldUpdateOperationsInput | number
    categoria?: Enumenum_veiculos_categoriaFieldUpdateOperationsInput | $Enums.enum_veiculos_categoria
    status?: NullableEnumenum_veiculos_statusFieldUpdateOperationsInput | $Enums.enum_veiculos_status | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type veiculosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    motorista_id?: IntFieldUpdateOperationsInput | number
    modelo?: StringFieldUpdateOperationsInput | string
    placa?: StringFieldUpdateOperationsInput | string
    ano?: IntFieldUpdateOperationsInput | number
    categoria?: Enumenum_veiculos_categoriaFieldUpdateOperationsInput | $Enums.enum_veiculos_categoria
    status?: NullableEnumenum_veiculos_statusFieldUpdateOperationsInput | $Enums.enum_veiculos_status | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type veiculosCreateManyInput = {
    id?: number
    motorista_id: number
    modelo: string
    placa: string
    ano: number
    categoria: $Enums.enum_veiculos_categoria
    status?: $Enums.enum_veiculos_status | null
    observacoes?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type veiculosUpdateManyMutationInput = {
    motorista_id?: IntFieldUpdateOperationsInput | number
    modelo?: StringFieldUpdateOperationsInput | string
    placa?: StringFieldUpdateOperationsInput | string
    ano?: IntFieldUpdateOperationsInput | number
    categoria?: Enumenum_veiculos_categoriaFieldUpdateOperationsInput | $Enums.enum_veiculos_categoria
    status?: NullableEnumenum_veiculos_statusFieldUpdateOperationsInput | $Enums.enum_veiculos_status | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type veiculosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    motorista_id?: IntFieldUpdateOperationsInput | number
    modelo?: StringFieldUpdateOperationsInput | string
    placa?: StringFieldUpdateOperationsInput | string
    ano?: IntFieldUpdateOperationsInput | number
    categoria?: Enumenum_veiculos_categoriaFieldUpdateOperationsInput | $Enums.enum_veiculos_categoria
    status?: NullableEnumenum_veiculos_statusFieldUpdateOperationsInput | $Enums.enum_veiculos_status | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type Enumenum_BairroPrioridades_tipo_prioridadeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_BairroPrioridades_tipo_prioridade | Enumenum_BairroPrioridades_tipo_prioridadeFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_BairroPrioridades_tipo_prioridade[] | ListEnumenum_BairroPrioridades_tipo_prioridadeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_BairroPrioridades_tipo_prioridade[] | ListEnumenum_BairroPrioridades_tipo_prioridadeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_BairroPrioridades_tipo_prioridadeNullableFilter<$PrismaModel> | $Enums.enum_BairroPrioridades_tipo_prioridade | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type BairroPrioridadesCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    cidade?: SortOrder
    estado?: SortOrder
    ativo?: SortOrder
    tipo_prioridade?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BairroPrioridadesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BairroPrioridadesMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    cidade?: SortOrder
    estado?: SortOrder
    ativo?: SortOrder
    tipo_prioridade?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BairroPrioridadesMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    cidade?: SortOrder
    estado?: SortOrder
    ativo?: SortOrder
    tipo_prioridade?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BairroPrioridadesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type Enumenum_BairroPrioridades_tipo_prioridadeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_BairroPrioridades_tipo_prioridade | Enumenum_BairroPrioridades_tipo_prioridadeFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_BairroPrioridades_tipo_prioridade[] | ListEnumenum_BairroPrioridades_tipo_prioridadeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_BairroPrioridades_tipo_prioridade[] | ListEnumenum_BairroPrioridades_tipo_prioridadeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_BairroPrioridades_tipo_prioridadeNullableWithAggregatesFilter<$PrismaModel> | $Enums.enum_BairroPrioridades_tipo_prioridade | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumenum_BairroPrioridades_tipo_prioridadeNullableFilter<$PrismaModel>
    _max?: NestedEnumenum_BairroPrioridades_tipo_prioridadeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type CarteirasCountOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    saldo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CarteirasAvgOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    saldo?: SortOrder
  }

  export type CarteirasMaxOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    saldo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CarteirasMinOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    saldo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CarteirasSumOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    saldo?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type CodigoIndicacaosCountOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CodigoIndicacaosAvgOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
  }

  export type CodigoIndicacaosMaxOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CodigoIndicacaosMinOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CodigoIndicacaosSumOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type CorridaAgendadasCountOrderByAggregateInput = {
    id?: SortOrder
    passageiroCpf?: SortOrder
    motoristaCpf?: SortOrder
    origem?: SortOrder
    destino?: SortOrder
    dataHoraAgendada?: SortOrder
    status?: SortOrder
    tipo?: SortOrder
    valor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CorridaAgendadasAvgOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
  }

  export type CorridaAgendadasMaxOrderByAggregateInput = {
    id?: SortOrder
    passageiroCpf?: SortOrder
    motoristaCpf?: SortOrder
    origem?: SortOrder
    destino?: SortOrder
    dataHoraAgendada?: SortOrder
    status?: SortOrder
    tipo?: SortOrder
    valor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CorridaAgendadasMinOrderByAggregateInput = {
    id?: SortOrder
    passageiroCpf?: SortOrder
    motoristaCpf?: SortOrder
    origem?: SortOrder
    destino?: SortOrder
    dataHoraAgendada?: SortOrder
    status?: SortOrder
    tipo?: SortOrder
    valor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CorridaAgendadasSumOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type Enumenum_Corridas_tipoNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_Corridas_tipo | Enumenum_Corridas_tipoFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_Corridas_tipo[] | ListEnumenum_Corridas_tipoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_Corridas_tipo[] | ListEnumenum_Corridas_tipoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_Corridas_tipoNullableFilter<$PrismaModel> | $Enums.enum_Corridas_tipo | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type CorridasCountOrderByAggregateInput = {
    id?: SortOrder
    origem?: SortOrder
    destino?: SortOrder
    status?: SortOrder
    valor?: SortOrder
    tipo?: SortOrder
    horarioAgendado?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CorridasAvgOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    usuarioId?: SortOrder
  }

  export type CorridasMaxOrderByAggregateInput = {
    id?: SortOrder
    origem?: SortOrder
    destino?: SortOrder
    status?: SortOrder
    valor?: SortOrder
    tipo?: SortOrder
    horarioAgendado?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CorridasMinOrderByAggregateInput = {
    id?: SortOrder
    origem?: SortOrder
    destino?: SortOrder
    status?: SortOrder
    valor?: SortOrder
    tipo?: SortOrder
    horarioAgendado?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CorridasSumOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    usuarioId?: SortOrder
  }

  export type Enumenum_Corridas_tipoNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_Corridas_tipo | Enumenum_Corridas_tipoFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_Corridas_tipo[] | ListEnumenum_Corridas_tipoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_Corridas_tipo[] | ListEnumenum_Corridas_tipoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_Corridas_tipoNullableWithAggregatesFilter<$PrismaModel> | $Enums.enum_Corridas_tipo | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumenum_Corridas_tipoNullableFilter<$PrismaModel>
    _max?: NestedEnumenum_Corridas_tipoNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type Enumenum_Denuncia_tipo_alvoFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_Denuncia_tipo_alvo | Enumenum_Denuncia_tipo_alvoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_Denuncia_tipo_alvo[] | ListEnumenum_Denuncia_tipo_alvoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_Denuncia_tipo_alvo[] | ListEnumenum_Denuncia_tipo_alvoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_Denuncia_tipo_alvoFilter<$PrismaModel> | $Enums.enum_Denuncia_tipo_alvo
  }

  export type DenunciaCountOrderByAggregateInput = {
    id?: SortOrder
    autor_id?: SortOrder
    alvo_id?: SortOrder
    tipo_alvo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DenunciaAvgOrderByAggregateInput = {
    id?: SortOrder
    autor_id?: SortOrder
    alvo_id?: SortOrder
  }

  export type DenunciaMaxOrderByAggregateInput = {
    id?: SortOrder
    autor_id?: SortOrder
    alvo_id?: SortOrder
    tipo_alvo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DenunciaMinOrderByAggregateInput = {
    id?: SortOrder
    autor_id?: SortOrder
    alvo_id?: SortOrder
    tipo_alvo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DenunciaSumOrderByAggregateInput = {
    id?: SortOrder
    autor_id?: SortOrder
    alvo_id?: SortOrder
  }

  export type Enumenum_Denuncia_tipo_alvoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_Denuncia_tipo_alvo | Enumenum_Denuncia_tipo_alvoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_Denuncia_tipo_alvo[] | ListEnumenum_Denuncia_tipo_alvoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_Denuncia_tipo_alvo[] | ListEnumenum_Denuncia_tipo_alvoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_Denuncia_tipo_alvoWithAggregatesFilter<$PrismaModel> | $Enums.enum_Denuncia_tipo_alvo
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumenum_Denuncia_tipo_alvoFilter<$PrismaModel>
    _max?: NestedEnumenum_Denuncia_tipo_alvoFilter<$PrismaModel>
  }

  export type Enumenum_Documentos_tipo_documentoFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_Documentos_tipo_documento | Enumenum_Documentos_tipo_documentoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_Documentos_tipo_documento[] | ListEnumenum_Documentos_tipo_documentoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_Documentos_tipo_documento[] | ListEnumenum_Documentos_tipo_documentoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_Documentos_tipo_documentoFilter<$PrismaModel> | $Enums.enum_Documentos_tipo_documento
  }

  export type DocumentosCountOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    tipo_documento?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentosAvgOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
  }

  export type DocumentosMaxOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    tipo_documento?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentosMinOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    tipo_documento?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentosSumOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
  }

  export type Enumenum_Documentos_tipo_documentoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_Documentos_tipo_documento | Enumenum_Documentos_tipo_documentoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_Documentos_tipo_documento[] | ListEnumenum_Documentos_tipo_documentoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_Documentos_tipo_documento[] | ListEnumenum_Documentos_tipo_documentoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_Documentos_tipo_documentoWithAggregatesFilter<$PrismaModel> | $Enums.enum_Documentos_tipo_documento
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumenum_Documentos_tipo_documentoFilter<$PrismaModel>
    _max?: NestedEnumenum_Documentos_tipo_documentoFilter<$PrismaModel>
  }

  export type Enumenum_EmailEnviados_tipoNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_EmailEnviados_tipo | Enumenum_EmailEnviados_tipoFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_EmailEnviados_tipo[] | ListEnumenum_EmailEnviados_tipoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_EmailEnviados_tipo[] | ListEnumenum_EmailEnviados_tipoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_EmailEnviados_tipoNullableFilter<$PrismaModel> | $Enums.enum_EmailEnviados_tipo | null
  }

  export type EmailEnviadosCountOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    email?: SortOrder
    tipo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailEnviadosAvgOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
  }

  export type EmailEnviadosMaxOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    email?: SortOrder
    tipo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailEnviadosMinOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    email?: SortOrder
    tipo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailEnviadosSumOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
  }

  export type Enumenum_EmailEnviados_tipoNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_EmailEnviados_tipo | Enumenum_EmailEnviados_tipoFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_EmailEnviados_tipo[] | ListEnumenum_EmailEnviados_tipoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_EmailEnviados_tipo[] | ListEnumenum_EmailEnviados_tipoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_EmailEnviados_tipoNullableWithAggregatesFilter<$PrismaModel> | $Enums.enum_EmailEnviados_tipo | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumenum_EmailEnviados_tipoNullableFilter<$PrismaModel>
    _max?: NestedEnumenum_EmailEnviados_tipoNullableFilter<$PrismaModel>
  }

  export type Enumenum_HistoricoIndicacaos_tipoNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_HistoricoIndicacaos_tipo | Enumenum_HistoricoIndicacaos_tipoFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_HistoricoIndicacaos_tipo[] | ListEnumenum_HistoricoIndicacaos_tipoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_HistoricoIndicacaos_tipo[] | ListEnumenum_HistoricoIndicacaos_tipoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_HistoricoIndicacaos_tipoNullableFilter<$PrismaModel> | $Enums.enum_HistoricoIndicacaos_tipo | null
  }

  export type HistoricoIndicacaosCountOrderByAggregateInput = {
    id?: SortOrder
    indicador_id?: SortOrder
    indicado_id?: SortOrder
    tipo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HistoricoIndicacaosAvgOrderByAggregateInput = {
    id?: SortOrder
    indicador_id?: SortOrder
    indicado_id?: SortOrder
  }

  export type HistoricoIndicacaosMaxOrderByAggregateInput = {
    id?: SortOrder
    indicador_id?: SortOrder
    indicado_id?: SortOrder
    tipo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HistoricoIndicacaosMinOrderByAggregateInput = {
    id?: SortOrder
    indicador_id?: SortOrder
    indicado_id?: SortOrder
    tipo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HistoricoIndicacaosSumOrderByAggregateInput = {
    id?: SortOrder
    indicador_id?: SortOrder
    indicado_id?: SortOrder
  }

  export type Enumenum_HistoricoIndicacaos_tipoNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_HistoricoIndicacaos_tipo | Enumenum_HistoricoIndicacaos_tipoFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_HistoricoIndicacaos_tipo[] | ListEnumenum_HistoricoIndicacaos_tipoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_HistoricoIndicacaos_tipo[] | ListEnumenum_HistoricoIndicacaos_tipoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_HistoricoIndicacaos_tipoNullableWithAggregatesFilter<$PrismaModel> | $Enums.enum_HistoricoIndicacaos_tipo | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumenum_HistoricoIndicacaos_tipoNullableFilter<$PrismaModel>
    _max?: NestedEnumenum_HistoricoIndicacaos_tipoNullableFilter<$PrismaModel>
  }

  export type Enumenum_HistoricoSelfies_tipoNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_HistoricoSelfies_tipo | Enumenum_HistoricoSelfies_tipoFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_HistoricoSelfies_tipo[] | ListEnumenum_HistoricoSelfies_tipoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_HistoricoSelfies_tipo[] | ListEnumenum_HistoricoSelfies_tipoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_HistoricoSelfies_tipoNullableFilter<$PrismaModel> | $Enums.enum_HistoricoSelfies_tipo | null
  }

  export type HistoricoSelfiesCountOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    tipo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HistoricoSelfiesAvgOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
  }

  export type HistoricoSelfiesMaxOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    tipo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HistoricoSelfiesMinOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    tipo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HistoricoSelfiesSumOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
  }

  export type Enumenum_HistoricoSelfies_tipoNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_HistoricoSelfies_tipo | Enumenum_HistoricoSelfies_tipoFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_HistoricoSelfies_tipo[] | ListEnumenum_HistoricoSelfies_tipoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_HistoricoSelfies_tipo[] | ListEnumenum_HistoricoSelfies_tipoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_HistoricoSelfies_tipoNullableWithAggregatesFilter<$PrismaModel> | $Enums.enum_HistoricoSelfies_tipo | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumenum_HistoricoSelfies_tipoNullableFilter<$PrismaModel>
    _max?: NestedEnumenum_HistoricoSelfies_tipoNullableFilter<$PrismaModel>
  }

  export type IdentidadesCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IdentidadesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IdentidadesMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IdentidadesMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IdentidadesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UsuariosScalarRelationFilter = {
    is?: UsuariosWhereInput
    isNot?: UsuariosWhereInput
  }

  export type IndicacaosCountOrderByAggregateInput = {
    id?: SortOrder
    indicanteId?: SortOrder
    indicadoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IndicacaosAvgOrderByAggregateInput = {
    id?: SortOrder
    indicanteId?: SortOrder
    indicadoId?: SortOrder
  }

  export type IndicacaosMaxOrderByAggregateInput = {
    id?: SortOrder
    indicanteId?: SortOrder
    indicadoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IndicacaosMinOrderByAggregateInput = {
    id?: SortOrder
    indicanteId?: SortOrder
    indicadoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IndicacaosSumOrderByAggregateInput = {
    id?: SortOrder
    indicanteId?: SortOrder
    indicadoId?: SortOrder
  }

  export type Enumenum_LogAcessos_tipo_usuarioNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_LogAcessos_tipo_usuario | Enumenum_LogAcessos_tipo_usuarioFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_LogAcessos_tipo_usuario[] | ListEnumenum_LogAcessos_tipo_usuarioFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_LogAcessos_tipo_usuario[] | ListEnumenum_LogAcessos_tipo_usuarioFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_LogAcessos_tipo_usuarioNullableFilter<$PrismaModel> | $Enums.enum_LogAcessos_tipo_usuario | null
  }

  export type LogAcessosCountOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    tipo_usuario?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LogAcessosAvgOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
  }

  export type LogAcessosMaxOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    tipo_usuario?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LogAcessosMinOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    tipo_usuario?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LogAcessosSumOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
  }

  export type Enumenum_LogAcessos_tipo_usuarioNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_LogAcessos_tipo_usuario | Enumenum_LogAcessos_tipo_usuarioFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_LogAcessos_tipo_usuario[] | ListEnumenum_LogAcessos_tipo_usuarioFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_LogAcessos_tipo_usuario[] | ListEnumenum_LogAcessos_tipo_usuarioFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_LogAcessos_tipo_usuarioNullableWithAggregatesFilter<$PrismaModel> | $Enums.enum_LogAcessos_tipo_usuario | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumenum_LogAcessos_tipo_usuarioNullableFilter<$PrismaModel>
    _max?: NestedEnumenum_LogAcessos_tipo_usuarioNullableFilter<$PrismaModel>
  }

  export type Enumenum_MensagemSuportes_tipo_usuarioNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_MensagemSuportes_tipo_usuario | Enumenum_MensagemSuportes_tipo_usuarioFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_MensagemSuportes_tipo_usuario[] | ListEnumenum_MensagemSuportes_tipo_usuarioFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_MensagemSuportes_tipo_usuario[] | ListEnumenum_MensagemSuportes_tipo_usuarioFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_MensagemSuportes_tipo_usuarioNullableFilter<$PrismaModel> | $Enums.enum_MensagemSuportes_tipo_usuario | null
  }

  export type MensagemSuportesCountOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    tipo_usuario?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MensagemSuportesAvgOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
  }

  export type MensagemSuportesMaxOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    tipo_usuario?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MensagemSuportesMinOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    tipo_usuario?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MensagemSuportesSumOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
  }

  export type Enumenum_MensagemSuportes_tipo_usuarioNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_MensagemSuportes_tipo_usuario | Enumenum_MensagemSuportes_tipo_usuarioFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_MensagemSuportes_tipo_usuario[] | ListEnumenum_MensagemSuportes_tipo_usuarioFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_MensagemSuportes_tipo_usuario[] | ListEnumenum_MensagemSuportes_tipo_usuarioFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_MensagemSuportes_tipo_usuarioNullableWithAggregatesFilter<$PrismaModel> | $Enums.enum_MensagemSuportes_tipo_usuario | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumenum_MensagemSuportes_tipo_usuarioNullableFilter<$PrismaModel>
    _max?: NestedEnumenum_MensagemSuportes_tipo_usuarioNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type Enumenum_Recompensas_statusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_Recompensas_status | Enumenum_Recompensas_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_Recompensas_status[] | ListEnumenum_Recompensas_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_Recompensas_status[] | ListEnumenum_Recompensas_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_Recompensas_statusNullableFilter<$PrismaModel> | $Enums.enum_Recompensas_status | null
  }

  export type RecompensasCountOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    descricao?: SortOrder
    valor?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecompensasAvgOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    valor?: SortOrder
  }

  export type RecompensasMaxOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    descricao?: SortOrder
    valor?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecompensasMinOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    descricao?: SortOrder
    valor?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecompensasSumOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    valor?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type Enumenum_Recompensas_statusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_Recompensas_status | Enumenum_Recompensas_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_Recompensas_status[] | ListEnumenum_Recompensas_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_Recompensas_status[] | ListEnumenum_Recompensas_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_Recompensas_statusNullableWithAggregatesFilter<$PrismaModel> | $Enums.enum_Recompensas_status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumenum_Recompensas_statusNullableFilter<$PrismaModel>
    _max?: NestedEnumenum_Recompensas_statusNullableFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type Enumenum_Saques_statusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_Saques_status | Enumenum_Saques_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_Saques_status[] | ListEnumenum_Saques_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_Saques_status[] | ListEnumenum_Saques_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_Saques_statusNullableFilter<$PrismaModel> | $Enums.enum_Saques_status | null
  }

  export type Enumenum_Saques_tipoFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_Saques_tipo | Enumenum_Saques_tipoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_Saques_tipo[] | ListEnumenum_Saques_tipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_Saques_tipo[] | ListEnumenum_Saques_tipoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_Saques_tipoFilter<$PrismaModel> | $Enums.enum_Saques_tipo
  }

  export type SaquesCountOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    valor?: SortOrder
    status?: SortOrder
    tipo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SaquesAvgOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    valor?: SortOrder
  }

  export type SaquesMaxOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    valor?: SortOrder
    status?: SortOrder
    tipo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SaquesMinOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    valor?: SortOrder
    status?: SortOrder
    tipo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SaquesSumOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    valor?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type Enumenum_Saques_statusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_Saques_status | Enumenum_Saques_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_Saques_status[] | ListEnumenum_Saques_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_Saques_status[] | ListEnumenum_Saques_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_Saques_statusNullableWithAggregatesFilter<$PrismaModel> | $Enums.enum_Saques_status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumenum_Saques_statusNullableFilter<$PrismaModel>
    _max?: NestedEnumenum_Saques_statusNullableFilter<$PrismaModel>
  }

  export type Enumenum_Saques_tipoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_Saques_tipo | Enumenum_Saques_tipoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_Saques_tipo[] | ListEnumenum_Saques_tipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_Saques_tipo[] | ListEnumenum_Saques_tipoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_Saques_tipoWithAggregatesFilter<$PrismaModel> | $Enums.enum_Saques_tipo
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumenum_Saques_tipoFilter<$PrismaModel>
    _max?: NestedEnumenum_Saques_tipoFilter<$PrismaModel>
  }

  export type Enumenum_Transacaos_tipoFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_Transacaos_tipo | Enumenum_Transacaos_tipoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_Transacaos_tipo[] | ListEnumenum_Transacaos_tipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_Transacaos_tipo[] | ListEnumenum_Transacaos_tipoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_Transacaos_tipoFilter<$PrismaModel> | $Enums.enum_Transacaos_tipo
  }

  export type TransacaosCountOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    tipo?: SortOrder
    valor?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransacaosAvgOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    valor?: SortOrder
  }

  export type TransacaosMaxOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    tipo?: SortOrder
    valor?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransacaosMinOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    tipo?: SortOrder
    valor?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransacaosSumOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    valor?: SortOrder
  }

  export type Enumenum_Transacaos_tipoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_Transacaos_tipo | Enumenum_Transacaos_tipoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_Transacaos_tipo[] | ListEnumenum_Transacaos_tipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_Transacaos_tipo[] | ListEnumenum_Transacaos_tipoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_Transacaos_tipoWithAggregatesFilter<$PrismaModel> | $Enums.enum_Transacaos_tipo
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumenum_Transacaos_tipoFilter<$PrismaModel>
    _max?: NestedEnumenum_Transacaos_tipoFilter<$PrismaModel>
  }

  export type IndicacaosListRelationFilter = {
    every?: IndicacaosWhereInput
    some?: IndicacaosWhereInput
    none?: IndicacaosWhereInput
  }

  export type RecompensasListRelationFilter = {
    every?: RecompensasWhereInput
    some?: RecompensasWhereInput
    none?: RecompensasWhereInput
  }

  export type SaquesListRelationFilter = {
    every?: SaquesWhereInput
    some?: SaquesWhereInput
    none?: SaquesWhereInput
  }

  export type TransacaosListRelationFilter = {
    every?: TransacaosWhereInput
    some?: TransacaosWhereInput
    none?: TransacaosWhereInput
  }

  export type IndicacaosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecompensasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SaquesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransacaosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsuariosCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    cpf?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsuariosAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UsuariosMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    cpf?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsuariosMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    cpf?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsuariosSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Enumenum_Veiculos_categoriaNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_Veiculos_categoria | Enumenum_Veiculos_categoriaFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_Veiculos_categoria[] | ListEnumenum_Veiculos_categoriaFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_Veiculos_categoria[] | ListEnumenum_Veiculos_categoriaFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_Veiculos_categoriaNullableFilter<$PrismaModel> | $Enums.enum_Veiculos_categoria | null
  }

  export type VeiculosCountOrderByAggregateInput = {
    id?: SortOrder
    motorista_id?: SortOrder
    modelo?: SortOrder
    placa?: SortOrder
    ano?: SortOrder
    categoria?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VeiculosAvgOrderByAggregateInput = {
    id?: SortOrder
    motorista_id?: SortOrder
    ano?: SortOrder
  }

  export type VeiculosMaxOrderByAggregateInput = {
    id?: SortOrder
    motorista_id?: SortOrder
    modelo?: SortOrder
    placa?: SortOrder
    ano?: SortOrder
    categoria?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VeiculosMinOrderByAggregateInput = {
    id?: SortOrder
    motorista_id?: SortOrder
    modelo?: SortOrder
    placa?: SortOrder
    ano?: SortOrder
    categoria?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VeiculosSumOrderByAggregateInput = {
    id?: SortOrder
    motorista_id?: SortOrder
    ano?: SortOrder
  }

  export type Enumenum_Veiculos_categoriaNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_Veiculos_categoria | Enumenum_Veiculos_categoriaFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_Veiculos_categoria[] | ListEnumenum_Veiculos_categoriaFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_Veiculos_categoria[] | ListEnumenum_Veiculos_categoriaFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_Veiculos_categoriaNullableWithAggregatesFilter<$PrismaModel> | $Enums.enum_Veiculos_categoria | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumenum_Veiculos_categoriaNullableFilter<$PrismaModel>
    _max?: NestedEnumenum_Veiculos_categoriaNullableFilter<$PrismaModel>
  }

  export type Enumenum_agenda_corridas_categoriaFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_agenda_corridas_categoria | Enumenum_agenda_corridas_categoriaFieldRefInput<$PrismaModel>
    in?: $Enums.enum_agenda_corridas_categoria[] | ListEnumenum_agenda_corridas_categoriaFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_agenda_corridas_categoria[] | ListEnumenum_agenda_corridas_categoriaFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_agenda_corridas_categoriaFilter<$PrismaModel> | $Enums.enum_agenda_corridas_categoria
  }

  export type Enumenum_agenda_corridas_statusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_agenda_corridas_status | Enumenum_agenda_corridas_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_agenda_corridas_status[] | ListEnumenum_agenda_corridas_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_agenda_corridas_status[] | ListEnumenum_agenda_corridas_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_agenda_corridas_statusNullableFilter<$PrismaModel> | $Enums.enum_agenda_corridas_status | null
  }

  export type agenda_corridasCountOrderByAggregateInput = {
    id?: SortOrder
    passageiro_id?: SortOrder
    categoria?: SortOrder
    endereco_origem?: SortOrder
    endereco_destino?: SortOrder
    data_hora?: SortOrder
    status?: SortOrder
    motorista_id?: SortOrder
    valor_previsto?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type agenda_corridasAvgOrderByAggregateInput = {
    id?: SortOrder
    passageiro_id?: SortOrder
    motorista_id?: SortOrder
    valor_previsto?: SortOrder
  }

  export type agenda_corridasMaxOrderByAggregateInput = {
    id?: SortOrder
    passageiro_id?: SortOrder
    categoria?: SortOrder
    endereco_origem?: SortOrder
    endereco_destino?: SortOrder
    data_hora?: SortOrder
    status?: SortOrder
    motorista_id?: SortOrder
    valor_previsto?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type agenda_corridasMinOrderByAggregateInput = {
    id?: SortOrder
    passageiro_id?: SortOrder
    categoria?: SortOrder
    endereco_origem?: SortOrder
    endereco_destino?: SortOrder
    data_hora?: SortOrder
    status?: SortOrder
    motorista_id?: SortOrder
    valor_previsto?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type agenda_corridasSumOrderByAggregateInput = {
    id?: SortOrder
    passageiro_id?: SortOrder
    motorista_id?: SortOrder
    valor_previsto?: SortOrder
  }

  export type Enumenum_agenda_corridas_categoriaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_agenda_corridas_categoria | Enumenum_agenda_corridas_categoriaFieldRefInput<$PrismaModel>
    in?: $Enums.enum_agenda_corridas_categoria[] | ListEnumenum_agenda_corridas_categoriaFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_agenda_corridas_categoria[] | ListEnumenum_agenda_corridas_categoriaFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_agenda_corridas_categoriaWithAggregatesFilter<$PrismaModel> | $Enums.enum_agenda_corridas_categoria
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumenum_agenda_corridas_categoriaFilter<$PrismaModel>
    _max?: NestedEnumenum_agenda_corridas_categoriaFilter<$PrismaModel>
  }

  export type Enumenum_agenda_corridas_statusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_agenda_corridas_status | Enumenum_agenda_corridas_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_agenda_corridas_status[] | ListEnumenum_agenda_corridas_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_agenda_corridas_status[] | ListEnumenum_agenda_corridas_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_agenda_corridas_statusNullableWithAggregatesFilter<$PrismaModel> | $Enums.enum_agenda_corridas_status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumenum_agenda_corridas_statusNullableFilter<$PrismaModel>
    _max?: NestedEnumenum_agenda_corridas_statusNullableFilter<$PrismaModel>
  }

  export type Enumenum_avaliacoes_tipoFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_avaliacoes_tipo | Enumenum_avaliacoes_tipoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_avaliacoes_tipo[] | ListEnumenum_avaliacoes_tipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_avaliacoes_tipo[] | ListEnumenum_avaliacoes_tipoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_avaliacoes_tipoFilter<$PrismaModel> | $Enums.enum_avaliacoes_tipo
  }

  export type avaliacoesCountOrderByAggregateInput = {
    id?: SortOrder
    avaliador_id?: SortOrder
    avaliado_id?: SortOrder
    tipo?: SortOrder
    nota?: SortOrder
    comentario?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type avaliacoesAvgOrderByAggregateInput = {
    id?: SortOrder
    avaliador_id?: SortOrder
    avaliado_id?: SortOrder
    nota?: SortOrder
  }

  export type avaliacoesMaxOrderByAggregateInput = {
    id?: SortOrder
    avaliador_id?: SortOrder
    avaliado_id?: SortOrder
    tipo?: SortOrder
    nota?: SortOrder
    comentario?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type avaliacoesMinOrderByAggregateInput = {
    id?: SortOrder
    avaliador_id?: SortOrder
    avaliado_id?: SortOrder
    tipo?: SortOrder
    nota?: SortOrder
    comentario?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type avaliacoesSumOrderByAggregateInput = {
    id?: SortOrder
    avaliador_id?: SortOrder
    avaliado_id?: SortOrder
    nota?: SortOrder
  }

  export type Enumenum_avaliacoes_tipoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_avaliacoes_tipo | Enumenum_avaliacoes_tipoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_avaliacoes_tipo[] | ListEnumenum_avaliacoes_tipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_avaliacoes_tipo[] | ListEnumenum_avaliacoes_tipoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_avaliacoes_tipoWithAggregatesFilter<$PrismaModel> | $Enums.enum_avaliacoes_tipo
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumenum_avaliacoes_tipoFilter<$PrismaModel>
    _max?: NestedEnumenum_avaliacoes_tipoFilter<$PrismaModel>
  }

  export type Enumenum_bairros_prioridade_tipo_prioridadeFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_bairros_prioridade_tipo_prioridade | Enumenum_bairros_prioridade_tipo_prioridadeFieldRefInput<$PrismaModel>
    in?: $Enums.enum_bairros_prioridade_tipo_prioridade[] | ListEnumenum_bairros_prioridade_tipo_prioridadeFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_bairros_prioridade_tipo_prioridade[] | ListEnumenum_bairros_prioridade_tipo_prioridadeFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_bairros_prioridade_tipo_prioridadeFilter<$PrismaModel> | $Enums.enum_bairros_prioridade_tipo_prioridade
  }

  export type bairros_prioridadeCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    cidade?: SortOrder
    estado?: SortOrder
    ativo?: SortOrder
    tipo_prioridade?: SortOrder
    observacoes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type bairros_prioridadeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type bairros_prioridadeMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    cidade?: SortOrder
    estado?: SortOrder
    ativo?: SortOrder
    tipo_prioridade?: SortOrder
    observacoes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type bairros_prioridadeMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    cidade?: SortOrder
    estado?: SortOrder
    ativo?: SortOrder
    tipo_prioridade?: SortOrder
    observacoes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type bairros_prioridadeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Enumenum_bairros_prioridade_tipo_prioridadeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_bairros_prioridade_tipo_prioridade | Enumenum_bairros_prioridade_tipo_prioridadeFieldRefInput<$PrismaModel>
    in?: $Enums.enum_bairros_prioridade_tipo_prioridade[] | ListEnumenum_bairros_prioridade_tipo_prioridadeFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_bairros_prioridade_tipo_prioridade[] | ListEnumenum_bairros_prioridade_tipo_prioridadeFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_bairros_prioridade_tipo_prioridadeWithAggregatesFilter<$PrismaModel> | $Enums.enum_bairros_prioridade_tipo_prioridade
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumenum_bairros_prioridade_tipo_prioridadeFilter<$PrismaModel>
    _max?: NestedEnumenum_bairros_prioridade_tipo_prioridadeFilter<$PrismaModel>
  }

  export type Enumenum_carteiras_tipoFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_carteiras_tipo | Enumenum_carteiras_tipoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_carteiras_tipo[] | ListEnumenum_carteiras_tipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_carteiras_tipo[] | ListEnumenum_carteiras_tipoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_carteiras_tipoFilter<$PrismaModel> | $Enums.enum_carteiras_tipo
  }

  export type carteirasCountOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    tipo?: SortOrder
    saldo?: SortOrder
    ultima_atualizacao?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type carteirasAvgOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    saldo?: SortOrder
  }

  export type carteirasMaxOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    tipo?: SortOrder
    saldo?: SortOrder
    ultima_atualizacao?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type carteirasMinOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    tipo?: SortOrder
    saldo?: SortOrder
    ultima_atualizacao?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type carteirasSumOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    saldo?: SortOrder
  }

  export type Enumenum_carteiras_tipoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_carteiras_tipo | Enumenum_carteiras_tipoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_carteiras_tipo[] | ListEnumenum_carteiras_tipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_carteiras_tipo[] | ListEnumenum_carteiras_tipoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_carteiras_tipoWithAggregatesFilter<$PrismaModel> | $Enums.enum_carteiras_tipo
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumenum_carteiras_tipoFilter<$PrismaModel>
    _max?: NestedEnumenum_carteiras_tipoFilter<$PrismaModel>
  }

  export type Enumenum_corridas_statusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_corridas_status | Enumenum_corridas_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_corridas_status[] | ListEnumenum_corridas_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_corridas_status[] | ListEnumenum_corridas_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_corridas_statusNullableFilter<$PrismaModel> | $Enums.enum_corridas_status | null
  }

  export type Enumenum_corridas_forma_pagamentoFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_corridas_forma_pagamento | Enumenum_corridas_forma_pagamentoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_corridas_forma_pagamento[] | ListEnumenum_corridas_forma_pagamentoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_corridas_forma_pagamento[] | ListEnumenum_corridas_forma_pagamentoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_corridas_forma_pagamentoFilter<$PrismaModel> | $Enums.enum_corridas_forma_pagamento
  }

  export type corridasCountOrderByAggregateInput = {
    id?: SortOrder
    id_motorista?: SortOrder
    id_passageiro?: SortOrder
    origem?: SortOrder
    destino?: SortOrder
    status?: SortOrder
    distancia_km?: SortOrder
    valor_total?: SortOrder
    forma_pagamento?: SortOrder
    data_hora?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type corridasAvgOrderByAggregateInput = {
    id?: SortOrder
    id_motorista?: SortOrder
    id_passageiro?: SortOrder
    distancia_km?: SortOrder
    valor_total?: SortOrder
  }

  export type corridasMaxOrderByAggregateInput = {
    id?: SortOrder
    id_motorista?: SortOrder
    id_passageiro?: SortOrder
    origem?: SortOrder
    destino?: SortOrder
    status?: SortOrder
    distancia_km?: SortOrder
    valor_total?: SortOrder
    forma_pagamento?: SortOrder
    data_hora?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type corridasMinOrderByAggregateInput = {
    id?: SortOrder
    id_motorista?: SortOrder
    id_passageiro?: SortOrder
    origem?: SortOrder
    destino?: SortOrder
    status?: SortOrder
    distancia_km?: SortOrder
    valor_total?: SortOrder
    forma_pagamento?: SortOrder
    data_hora?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type corridasSumOrderByAggregateInput = {
    id?: SortOrder
    id_motorista?: SortOrder
    id_passageiro?: SortOrder
    distancia_km?: SortOrder
    valor_total?: SortOrder
  }

  export type Enumenum_corridas_statusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_corridas_status | Enumenum_corridas_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_corridas_status[] | ListEnumenum_corridas_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_corridas_status[] | ListEnumenum_corridas_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_corridas_statusNullableWithAggregatesFilter<$PrismaModel> | $Enums.enum_corridas_status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumenum_corridas_statusNullableFilter<$PrismaModel>
    _max?: NestedEnumenum_corridas_statusNullableFilter<$PrismaModel>
  }

  export type Enumenum_corridas_forma_pagamentoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_corridas_forma_pagamento | Enumenum_corridas_forma_pagamentoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_corridas_forma_pagamento[] | ListEnumenum_corridas_forma_pagamentoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_corridas_forma_pagamento[] | ListEnumenum_corridas_forma_pagamentoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_corridas_forma_pagamentoWithAggregatesFilter<$PrismaModel> | $Enums.enum_corridas_forma_pagamento
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumenum_corridas_forma_pagamentoFilter<$PrismaModel>
    _max?: NestedEnumenum_corridas_forma_pagamentoFilter<$PrismaModel>
  }

  export type Enumenum_denuncias_tipo_alvoFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_denuncias_tipo_alvo | Enumenum_denuncias_tipo_alvoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_denuncias_tipo_alvo[] | ListEnumenum_denuncias_tipo_alvoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_denuncias_tipo_alvo[] | ListEnumenum_denuncias_tipo_alvoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_denuncias_tipo_alvoFilter<$PrismaModel> | $Enums.enum_denuncias_tipo_alvo
  }

  export type Enumenum_denuncias_statusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_denuncias_status | Enumenum_denuncias_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_denuncias_status[] | ListEnumenum_denuncias_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_denuncias_status[] | ListEnumenum_denuncias_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_denuncias_statusNullableFilter<$PrismaModel> | $Enums.enum_denuncias_status | null
  }

  export type denunciasCountOrderByAggregateInput = {
    id?: SortOrder
    autor_id?: SortOrder
    alvo_id?: SortOrder
    tipo_alvo?: SortOrder
    corrida_id?: SortOrder
    motivo?: SortOrder
    descricao?: SortOrder
    status?: SortOrder
    data_denuncia?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type denunciasAvgOrderByAggregateInput = {
    id?: SortOrder
    autor_id?: SortOrder
    alvo_id?: SortOrder
    corrida_id?: SortOrder
  }

  export type denunciasMaxOrderByAggregateInput = {
    id?: SortOrder
    autor_id?: SortOrder
    alvo_id?: SortOrder
    tipo_alvo?: SortOrder
    corrida_id?: SortOrder
    motivo?: SortOrder
    descricao?: SortOrder
    status?: SortOrder
    data_denuncia?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type denunciasMinOrderByAggregateInput = {
    id?: SortOrder
    autor_id?: SortOrder
    alvo_id?: SortOrder
    tipo_alvo?: SortOrder
    corrida_id?: SortOrder
    motivo?: SortOrder
    descricao?: SortOrder
    status?: SortOrder
    data_denuncia?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type denunciasSumOrderByAggregateInput = {
    id?: SortOrder
    autor_id?: SortOrder
    alvo_id?: SortOrder
    corrida_id?: SortOrder
  }

  export type Enumenum_denuncias_tipo_alvoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_denuncias_tipo_alvo | Enumenum_denuncias_tipo_alvoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_denuncias_tipo_alvo[] | ListEnumenum_denuncias_tipo_alvoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_denuncias_tipo_alvo[] | ListEnumenum_denuncias_tipo_alvoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_denuncias_tipo_alvoWithAggregatesFilter<$PrismaModel> | $Enums.enum_denuncias_tipo_alvo
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumenum_denuncias_tipo_alvoFilter<$PrismaModel>
    _max?: NestedEnumenum_denuncias_tipo_alvoFilter<$PrismaModel>
  }

  export type Enumenum_denuncias_statusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_denuncias_status | Enumenum_denuncias_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_denuncias_status[] | ListEnumenum_denuncias_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_denuncias_status[] | ListEnumenum_denuncias_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_denuncias_statusNullableWithAggregatesFilter<$PrismaModel> | $Enums.enum_denuncias_status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumenum_denuncias_statusNullableFilter<$PrismaModel>
    _max?: NestedEnumenum_denuncias_statusNullableFilter<$PrismaModel>
  }

  export type Enumenum_documentos_tipo_documentoFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_documentos_tipo_documento | Enumenum_documentos_tipo_documentoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_documentos_tipo_documento[] | ListEnumenum_documentos_tipo_documentoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_documentos_tipo_documento[] | ListEnumenum_documentos_tipo_documentoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_documentos_tipo_documentoFilter<$PrismaModel> | $Enums.enum_documentos_tipo_documento
  }

  export type Enumenum_documentos_statusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_documentos_status | Enumenum_documentos_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_documentos_status[] | ListEnumenum_documentos_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_documentos_status[] | ListEnumenum_documentos_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_documentos_statusNullableFilter<$PrismaModel> | $Enums.enum_documentos_status | null
  }

  export type documentosCountOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    tipo_documento?: SortOrder
    arquivo_url?: SortOrder
    status?: SortOrder
    motivo_rejeicao?: SortOrder
    data_envio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type documentosAvgOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
  }

  export type documentosMaxOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    tipo_documento?: SortOrder
    arquivo_url?: SortOrder
    status?: SortOrder
    motivo_rejeicao?: SortOrder
    data_envio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type documentosMinOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    tipo_documento?: SortOrder
    arquivo_url?: SortOrder
    status?: SortOrder
    motivo_rejeicao?: SortOrder
    data_envio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type documentosSumOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
  }

  export type Enumenum_documentos_tipo_documentoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_documentos_tipo_documento | Enumenum_documentos_tipo_documentoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_documentos_tipo_documento[] | ListEnumenum_documentos_tipo_documentoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_documentos_tipo_documento[] | ListEnumenum_documentos_tipo_documentoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_documentos_tipo_documentoWithAggregatesFilter<$PrismaModel> | $Enums.enum_documentos_tipo_documento
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumenum_documentos_tipo_documentoFilter<$PrismaModel>
    _max?: NestedEnumenum_documentos_tipo_documentoFilter<$PrismaModel>
  }

  export type Enumenum_documentos_statusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_documentos_status | Enumenum_documentos_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_documentos_status[] | ListEnumenum_documentos_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_documentos_status[] | ListEnumenum_documentos_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_documentos_statusNullableWithAggregatesFilter<$PrismaModel> | $Enums.enum_documentos_status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumenum_documentos_statusNullableFilter<$PrismaModel>
    _max?: NestedEnumenum_documentos_statusNullableFilter<$PrismaModel>
  }

  export type Enumenum_emails_enviados_tipoFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_emails_enviados_tipo | Enumenum_emails_enviados_tipoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_emails_enviados_tipo[] | ListEnumenum_emails_enviados_tipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_emails_enviados_tipo[] | ListEnumenum_emails_enviados_tipoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_emails_enviados_tipoFilter<$PrismaModel> | $Enums.enum_emails_enviados_tipo
  }

  export type Enumenum_emails_enviados_status_envioNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_emails_enviados_status_envio | Enumenum_emails_enviados_status_envioFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_emails_enviados_status_envio[] | ListEnumenum_emails_enviados_status_envioFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_emails_enviados_status_envio[] | ListEnumenum_emails_enviados_status_envioFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_emails_enviados_status_envioNullableFilter<$PrismaModel> | $Enums.enum_emails_enviados_status_envio | null
  }

  export type emails_enviadosCountOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    email?: SortOrder
    tipo?: SortOrder
    titulo?: SortOrder
    conteudo?: SortOrder
    status_envio?: SortOrder
    data_envio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type emails_enviadosAvgOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
  }

  export type emails_enviadosMaxOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    email?: SortOrder
    tipo?: SortOrder
    titulo?: SortOrder
    conteudo?: SortOrder
    status_envio?: SortOrder
    data_envio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type emails_enviadosMinOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    email?: SortOrder
    tipo?: SortOrder
    titulo?: SortOrder
    conteudo?: SortOrder
    status_envio?: SortOrder
    data_envio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type emails_enviadosSumOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
  }

  export type Enumenum_emails_enviados_tipoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_emails_enviados_tipo | Enumenum_emails_enviados_tipoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_emails_enviados_tipo[] | ListEnumenum_emails_enviados_tipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_emails_enviados_tipo[] | ListEnumenum_emails_enviados_tipoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_emails_enviados_tipoWithAggregatesFilter<$PrismaModel> | $Enums.enum_emails_enviados_tipo
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumenum_emails_enviados_tipoFilter<$PrismaModel>
    _max?: NestedEnumenum_emails_enviados_tipoFilter<$PrismaModel>
  }

  export type Enumenum_emails_enviados_status_envioNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_emails_enviados_status_envio | Enumenum_emails_enviados_status_envioFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_emails_enviados_status_envio[] | ListEnumenum_emails_enviados_status_envioFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_emails_enviados_status_envio[] | ListEnumenum_emails_enviados_status_envioFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_emails_enviados_status_envioNullableWithAggregatesFilter<$PrismaModel> | $Enums.enum_emails_enviados_status_envio | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumenum_emails_enviados_status_envioNullableFilter<$PrismaModel>
    _max?: NestedEnumenum_emails_enviados_status_envioNullableFilter<$PrismaModel>
  }

  export type Enumenum_historico_indicacoes_tipoFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_historico_indicacoes_tipo | Enumenum_historico_indicacoes_tipoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_historico_indicacoes_tipo[] | ListEnumenum_historico_indicacoes_tipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_historico_indicacoes_tipo[] | ListEnumenum_historico_indicacoes_tipoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_historico_indicacoes_tipoFilter<$PrismaModel> | $Enums.enum_historico_indicacoes_tipo
  }

  export type historico_indicacoesCountOrderByAggregateInput = {
    id?: SortOrder
    indicador_id?: SortOrder
    indicado_id?: SortOrder
    tipo?: SortOrder
    data_vinculo?: SortOrder
    codigo_utilizado?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type historico_indicacoesAvgOrderByAggregateInput = {
    id?: SortOrder
    indicador_id?: SortOrder
    indicado_id?: SortOrder
  }

  export type historico_indicacoesMaxOrderByAggregateInput = {
    id?: SortOrder
    indicador_id?: SortOrder
    indicado_id?: SortOrder
    tipo?: SortOrder
    data_vinculo?: SortOrder
    codigo_utilizado?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type historico_indicacoesMinOrderByAggregateInput = {
    id?: SortOrder
    indicador_id?: SortOrder
    indicado_id?: SortOrder
    tipo?: SortOrder
    data_vinculo?: SortOrder
    codigo_utilizado?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type historico_indicacoesSumOrderByAggregateInput = {
    id?: SortOrder
    indicador_id?: SortOrder
    indicado_id?: SortOrder
  }

  export type Enumenum_historico_indicacoes_tipoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_historico_indicacoes_tipo | Enumenum_historico_indicacoes_tipoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_historico_indicacoes_tipo[] | ListEnumenum_historico_indicacoes_tipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_historico_indicacoes_tipo[] | ListEnumenum_historico_indicacoes_tipoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_historico_indicacoes_tipoWithAggregatesFilter<$PrismaModel> | $Enums.enum_historico_indicacoes_tipo
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumenum_historico_indicacoes_tipoFilter<$PrismaModel>
    _max?: NestedEnumenum_historico_indicacoes_tipoFilter<$PrismaModel>
  }

  export type Enumenum_historico_selfies_tipoFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_historico_selfies_tipo | Enumenum_historico_selfies_tipoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_historico_selfies_tipo[] | ListEnumenum_historico_selfies_tipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_historico_selfies_tipo[] | ListEnumenum_historico_selfies_tipoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_historico_selfies_tipoFilter<$PrismaModel> | $Enums.enum_historico_selfies_tipo
  }

  export type Enumenum_historico_selfies_resultadoNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_historico_selfies_resultado | Enumenum_historico_selfies_resultadoFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_historico_selfies_resultado[] | ListEnumenum_historico_selfies_resultadoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_historico_selfies_resultado[] | ListEnumenum_historico_selfies_resultadoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_historico_selfies_resultadoNullableFilter<$PrismaModel> | $Enums.enum_historico_selfies_resultado | null
  }

  export type historico_selfiesCountOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    tipo?: SortOrder
    imagem_url?: SortOrder
    resultado?: SortOrder
    motivo_falha?: SortOrder
    data_envio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type historico_selfiesAvgOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
  }

  export type historico_selfiesMaxOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    tipo?: SortOrder
    imagem_url?: SortOrder
    resultado?: SortOrder
    motivo_falha?: SortOrder
    data_envio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type historico_selfiesMinOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    tipo?: SortOrder
    imagem_url?: SortOrder
    resultado?: SortOrder
    motivo_falha?: SortOrder
    data_envio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type historico_selfiesSumOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
  }

  export type Enumenum_historico_selfies_tipoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_historico_selfies_tipo | Enumenum_historico_selfies_tipoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_historico_selfies_tipo[] | ListEnumenum_historico_selfies_tipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_historico_selfies_tipo[] | ListEnumenum_historico_selfies_tipoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_historico_selfies_tipoWithAggregatesFilter<$PrismaModel> | $Enums.enum_historico_selfies_tipo
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumenum_historico_selfies_tipoFilter<$PrismaModel>
    _max?: NestedEnumenum_historico_selfies_tipoFilter<$PrismaModel>
  }

  export type Enumenum_historico_selfies_resultadoNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_historico_selfies_resultado | Enumenum_historico_selfies_resultadoFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_historico_selfies_resultado[] | ListEnumenum_historico_selfies_resultadoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_historico_selfies_resultado[] | ListEnumenum_historico_selfies_resultadoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_historico_selfies_resultadoNullableWithAggregatesFilter<$PrismaModel> | $Enums.enum_historico_selfies_resultado | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumenum_historico_selfies_resultadoNullableFilter<$PrismaModel>
    _max?: NestedEnumenum_historico_selfies_resultadoNullableFilter<$PrismaModel>
  }

  export type Enumenum_logs_acesso_tipo_usuarioFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_logs_acesso_tipo_usuario | Enumenum_logs_acesso_tipo_usuarioFieldRefInput<$PrismaModel>
    in?: $Enums.enum_logs_acesso_tipo_usuario[] | ListEnumenum_logs_acesso_tipo_usuarioFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_logs_acesso_tipo_usuario[] | ListEnumenum_logs_acesso_tipo_usuarioFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_logs_acesso_tipo_usuarioFilter<$PrismaModel> | $Enums.enum_logs_acesso_tipo_usuario
  }

  export type logs_acessoCountOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    tipo_usuario?: SortOrder
    acao?: SortOrder
    descricao?: SortOrder
    ip?: SortOrder
    dispositivo?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type logs_acessoAvgOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
  }

  export type logs_acessoMaxOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    tipo_usuario?: SortOrder
    acao?: SortOrder
    descricao?: SortOrder
    ip?: SortOrder
    dispositivo?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type logs_acessoMinOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    tipo_usuario?: SortOrder
    acao?: SortOrder
    descricao?: SortOrder
    ip?: SortOrder
    dispositivo?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type logs_acessoSumOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
  }

  export type Enumenum_logs_acesso_tipo_usuarioWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_logs_acesso_tipo_usuario | Enumenum_logs_acesso_tipo_usuarioFieldRefInput<$PrismaModel>
    in?: $Enums.enum_logs_acesso_tipo_usuario[] | ListEnumenum_logs_acesso_tipo_usuarioFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_logs_acesso_tipo_usuario[] | ListEnumenum_logs_acesso_tipo_usuarioFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_logs_acesso_tipo_usuarioWithAggregatesFilter<$PrismaModel> | $Enums.enum_logs_acesso_tipo_usuario
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumenum_logs_acesso_tipo_usuarioFilter<$PrismaModel>
    _max?: NestedEnumenum_logs_acesso_tipo_usuarioFilter<$PrismaModel>
  }

  export type Enumenum_mensagens_suporte_tipo_usuarioFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_mensagens_suporte_tipo_usuario | Enumenum_mensagens_suporte_tipo_usuarioFieldRefInput<$PrismaModel>
    in?: $Enums.enum_mensagens_suporte_tipo_usuario[] | ListEnumenum_mensagens_suporte_tipo_usuarioFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_mensagens_suporte_tipo_usuario[] | ListEnumenum_mensagens_suporte_tipo_usuarioFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_mensagens_suporte_tipo_usuarioFilter<$PrismaModel> | $Enums.enum_mensagens_suporte_tipo_usuario
  }

  export type Enumenum_mensagens_suporte_statusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_mensagens_suporte_status | Enumenum_mensagens_suporte_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_mensagens_suporte_status[] | ListEnumenum_mensagens_suporte_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_mensagens_suporte_status[] | ListEnumenum_mensagens_suporte_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_mensagens_suporte_statusNullableFilter<$PrismaModel> | $Enums.enum_mensagens_suporte_status | null
  }

  export type mensagens_suporteCountOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    tipo_usuario?: SortOrder
    mensagem?: SortOrder
    resposta_sistema?: SortOrder
    status?: SortOrder
    data_envio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type mensagens_suporteAvgOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
  }

  export type mensagens_suporteMaxOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    tipo_usuario?: SortOrder
    mensagem?: SortOrder
    resposta_sistema?: SortOrder
    status?: SortOrder
    data_envio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type mensagens_suporteMinOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    tipo_usuario?: SortOrder
    mensagem?: SortOrder
    resposta_sistema?: SortOrder
    status?: SortOrder
    data_envio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type mensagens_suporteSumOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
  }

  export type Enumenum_mensagens_suporte_tipo_usuarioWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_mensagens_suporte_tipo_usuario | Enumenum_mensagens_suporte_tipo_usuarioFieldRefInput<$PrismaModel>
    in?: $Enums.enum_mensagens_suporte_tipo_usuario[] | ListEnumenum_mensagens_suporte_tipo_usuarioFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_mensagens_suporte_tipo_usuario[] | ListEnumenum_mensagens_suporte_tipo_usuarioFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_mensagens_suporte_tipo_usuarioWithAggregatesFilter<$PrismaModel> | $Enums.enum_mensagens_suporte_tipo_usuario
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumenum_mensagens_suporte_tipo_usuarioFilter<$PrismaModel>
    _max?: NestedEnumenum_mensagens_suporte_tipo_usuarioFilter<$PrismaModel>
  }

  export type Enumenum_mensagens_suporte_statusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_mensagens_suporte_status | Enumenum_mensagens_suporte_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_mensagens_suporte_status[] | ListEnumenum_mensagens_suporte_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_mensagens_suporte_status[] | ListEnumenum_mensagens_suporte_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_mensagens_suporte_statusNullableWithAggregatesFilter<$PrismaModel> | $Enums.enum_mensagens_suporte_status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumenum_mensagens_suporte_statusNullableFilter<$PrismaModel>
    _max?: NestedEnumenum_mensagens_suporte_statusNullableFilter<$PrismaModel>
  }

  export type pagamentos_pessoaisCountOrderByAggregateInput = {
    id?: SortOrder
    motorista_id?: SortOrder
    passageiro_id?: SortOrder
    valor?: SortOrder
    valor_maximo?: SortOrder
    aceito_pelo_app?: SortOrder
    data_corrida?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type pagamentos_pessoaisAvgOrderByAggregateInput = {
    id?: SortOrder
    motorista_id?: SortOrder
    passageiro_id?: SortOrder
    valor?: SortOrder
    valor_maximo?: SortOrder
  }

  export type pagamentos_pessoaisMaxOrderByAggregateInput = {
    id?: SortOrder
    motorista_id?: SortOrder
    passageiro_id?: SortOrder
    valor?: SortOrder
    valor_maximo?: SortOrder
    aceito_pelo_app?: SortOrder
    data_corrida?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type pagamentos_pessoaisMinOrderByAggregateInput = {
    id?: SortOrder
    motorista_id?: SortOrder
    passageiro_id?: SortOrder
    valor?: SortOrder
    valor_maximo?: SortOrder
    aceito_pelo_app?: SortOrder
    data_corrida?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type pagamentos_pessoaisSumOrderByAggregateInput = {
    id?: SortOrder
    motorista_id?: SortOrder
    passageiro_id?: SortOrder
    valor?: SortOrder
    valor_maximo?: SortOrder
  }

  export type paradasCountOrderByAggregateInput = {
    id?: SortOrder
    corrida_id?: SortOrder
    ordem?: SortOrder
    endereco?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    tempo_espera?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type paradasAvgOrderByAggregateInput = {
    id?: SortOrder
    corrida_id?: SortOrder
    ordem?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    tempo_espera?: SortOrder
  }

  export type paradasMaxOrderByAggregateInput = {
    id?: SortOrder
    corrida_id?: SortOrder
    ordem?: SortOrder
    endereco?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    tempo_espera?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type paradasMinOrderByAggregateInput = {
    id?: SortOrder
    corrida_id?: SortOrder
    ordem?: SortOrder
    endereco?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    tempo_espera?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type paradasSumOrderByAggregateInput = {
    id?: SortOrder
    corrida_id?: SortOrder
    ordem?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    tempo_espera?: SortOrder
  }

  export type Enumenum_recompensas_tipoFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_recompensas_tipo | Enumenum_recompensas_tipoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_recompensas_tipo[] | ListEnumenum_recompensas_tipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_recompensas_tipo[] | ListEnumenum_recompensas_tipoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_recompensas_tipoFilter<$PrismaModel> | $Enums.enum_recompensas_tipo
  }

  export type Enumenum_recompensas_statusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_recompensas_status | Enumenum_recompensas_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_recompensas_status[] | ListEnumenum_recompensas_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_recompensas_status[] | ListEnumenum_recompensas_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_recompensas_statusNullableFilter<$PrismaModel> | $Enums.enum_recompensas_status | null
  }

  export type recompensasCountOrderByAggregateInput = {
    id?: SortOrder
    indicador_id?: SortOrder
    indicado_id?: SortOrder
    tipo?: SortOrder
    valor?: SortOrder
    status?: SortOrder
    data_gerada?: SortOrder
    referencia_corrida?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type recompensasAvgOrderByAggregateInput = {
    id?: SortOrder
    indicador_id?: SortOrder
    indicado_id?: SortOrder
    valor?: SortOrder
    referencia_corrida?: SortOrder
  }

  export type recompensasMaxOrderByAggregateInput = {
    id?: SortOrder
    indicador_id?: SortOrder
    indicado_id?: SortOrder
    tipo?: SortOrder
    valor?: SortOrder
    status?: SortOrder
    data_gerada?: SortOrder
    referencia_corrida?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type recompensasMinOrderByAggregateInput = {
    id?: SortOrder
    indicador_id?: SortOrder
    indicado_id?: SortOrder
    tipo?: SortOrder
    valor?: SortOrder
    status?: SortOrder
    data_gerada?: SortOrder
    referencia_corrida?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type recompensasSumOrderByAggregateInput = {
    id?: SortOrder
    indicador_id?: SortOrder
    indicado_id?: SortOrder
    valor?: SortOrder
    referencia_corrida?: SortOrder
  }

  export type Enumenum_recompensas_tipoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_recompensas_tipo | Enumenum_recompensas_tipoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_recompensas_tipo[] | ListEnumenum_recompensas_tipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_recompensas_tipo[] | ListEnumenum_recompensas_tipoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_recompensas_tipoWithAggregatesFilter<$PrismaModel> | $Enums.enum_recompensas_tipo
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumenum_recompensas_tipoFilter<$PrismaModel>
    _max?: NestedEnumenum_recompensas_tipoFilter<$PrismaModel>
  }

  export type Enumenum_recompensas_statusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_recompensas_status | Enumenum_recompensas_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_recompensas_status[] | ListEnumenum_recompensas_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_recompensas_status[] | ListEnumenum_recompensas_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_recompensas_statusNullableWithAggregatesFilter<$PrismaModel> | $Enums.enum_recompensas_status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumenum_recompensas_statusNullableFilter<$PrismaModel>
    _max?: NestedEnumenum_recompensas_statusNullableFilter<$PrismaModel>
  }

  export type Enumenum_saques_statusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_saques_status | Enumenum_saques_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_saques_status[] | ListEnumenum_saques_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_saques_status[] | ListEnumenum_saques_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_saques_statusNullableFilter<$PrismaModel> | $Enums.enum_saques_status | null
  }

  export type Enumenum_saques_tipoFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_saques_tipo | Enumenum_saques_tipoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_saques_tipo[] | ListEnumenum_saques_tipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_saques_tipo[] | ListEnumenum_saques_tipoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_saques_tipoFilter<$PrismaModel> | $Enums.enum_saques_tipo
  }

  export type saquesCountOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    valor?: SortOrder
    status?: SortOrder
    tipo?: SortOrder
    pix?: SortOrder
    data_pedido?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type saquesAvgOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    valor?: SortOrder
  }

  export type saquesMaxOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    valor?: SortOrder
    status?: SortOrder
    tipo?: SortOrder
    pix?: SortOrder
    data_pedido?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type saquesMinOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    valor?: SortOrder
    status?: SortOrder
    tipo?: SortOrder
    pix?: SortOrder
    data_pedido?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type saquesSumOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    valor?: SortOrder
  }

  export type Enumenum_saques_statusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_saques_status | Enumenum_saques_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_saques_status[] | ListEnumenum_saques_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_saques_status[] | ListEnumenum_saques_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_saques_statusNullableWithAggregatesFilter<$PrismaModel> | $Enums.enum_saques_status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumenum_saques_statusNullableFilter<$PrismaModel>
    _max?: NestedEnumenum_saques_statusNullableFilter<$PrismaModel>
  }

  export type Enumenum_saques_tipoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_saques_tipo | Enumenum_saques_tipoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_saques_tipo[] | ListEnumenum_saques_tipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_saques_tipo[] | ListEnumenum_saques_tipoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_saques_tipoWithAggregatesFilter<$PrismaModel> | $Enums.enum_saques_tipo
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumenum_saques_tipoFilter<$PrismaModel>
    _max?: NestedEnumenum_saques_tipoFilter<$PrismaModel>
  }

  export type Enumenum_transacoes_tipoFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_transacoes_tipo | Enumenum_transacoes_tipoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_transacoes_tipo[] | ListEnumenum_transacoes_tipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_transacoes_tipo[] | ListEnumenum_transacoes_tipoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_transacoes_tipoFilter<$PrismaModel> | $Enums.enum_transacoes_tipo
  }

  export type Enumenum_transacoes_origemFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_transacoes_origem | Enumenum_transacoes_origemFieldRefInput<$PrismaModel>
    in?: $Enums.enum_transacoes_origem[] | ListEnumenum_transacoes_origemFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_transacoes_origem[] | ListEnumenum_transacoes_origemFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_transacoes_origemFilter<$PrismaModel> | $Enums.enum_transacoes_origem
  }

  export type transacoesCountOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    tipo?: SortOrder
    origem?: SortOrder
    descricao?: SortOrder
    valor?: SortOrder
    data_transacao?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type transacoesAvgOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    valor?: SortOrder
  }

  export type transacoesMaxOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    tipo?: SortOrder
    origem?: SortOrder
    descricao?: SortOrder
    valor?: SortOrder
    data_transacao?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type transacoesMinOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    tipo?: SortOrder
    origem?: SortOrder
    descricao?: SortOrder
    valor?: SortOrder
    data_transacao?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type transacoesSumOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    valor?: SortOrder
  }

  export type Enumenum_transacoes_tipoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_transacoes_tipo | Enumenum_transacoes_tipoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_transacoes_tipo[] | ListEnumenum_transacoes_tipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_transacoes_tipo[] | ListEnumenum_transacoes_tipoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_transacoes_tipoWithAggregatesFilter<$PrismaModel> | $Enums.enum_transacoes_tipo
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumenum_transacoes_tipoFilter<$PrismaModel>
    _max?: NestedEnumenum_transacoes_tipoFilter<$PrismaModel>
  }

  export type Enumenum_transacoes_origemWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_transacoes_origem | Enumenum_transacoes_origemFieldRefInput<$PrismaModel>
    in?: $Enums.enum_transacoes_origem[] | ListEnumenum_transacoes_origemFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_transacoes_origem[] | ListEnumenum_transacoes_origemFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_transacoes_origemWithAggregatesFilter<$PrismaModel> | $Enums.enum_transacoes_origem
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumenum_transacoes_origemFilter<$PrismaModel>
    _max?: NestedEnumenum_transacoes_origemFilter<$PrismaModel>
  }

  export type Enumenum_usuarios_tipoFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_usuarios_tipo | Enumenum_usuarios_tipoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_usuarios_tipo[] | ListEnumenum_usuarios_tipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_usuarios_tipo[] | ListEnumenum_usuarios_tipoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_usuarios_tipoFilter<$PrismaModel> | $Enums.enum_usuarios_tipo
  }

  export type usuariosCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    tipo?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type usuariosAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type usuariosMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    tipo?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type usuariosMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    tipo?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type usuariosSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Enumenum_usuarios_tipoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_usuarios_tipo | Enumenum_usuarios_tipoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_usuarios_tipo[] | ListEnumenum_usuarios_tipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_usuarios_tipo[] | ListEnumenum_usuarios_tipoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_usuarios_tipoWithAggregatesFilter<$PrismaModel> | $Enums.enum_usuarios_tipo
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumenum_usuarios_tipoFilter<$PrismaModel>
    _max?: NestedEnumenum_usuarios_tipoFilter<$PrismaModel>
  }

  export type Enumenum_veiculos_categoriaFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_veiculos_categoria | Enumenum_veiculos_categoriaFieldRefInput<$PrismaModel>
    in?: $Enums.enum_veiculos_categoria[] | ListEnumenum_veiculos_categoriaFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_veiculos_categoria[] | ListEnumenum_veiculos_categoriaFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_veiculos_categoriaFilter<$PrismaModel> | $Enums.enum_veiculos_categoria
  }

  export type Enumenum_veiculos_statusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_veiculos_status | Enumenum_veiculos_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_veiculos_status[] | ListEnumenum_veiculos_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_veiculos_status[] | ListEnumenum_veiculos_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_veiculos_statusNullableFilter<$PrismaModel> | $Enums.enum_veiculos_status | null
  }

  export type veiculosCountOrderByAggregateInput = {
    id?: SortOrder
    motorista_id?: SortOrder
    modelo?: SortOrder
    placa?: SortOrder
    ano?: SortOrder
    categoria?: SortOrder
    status?: SortOrder
    observacoes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type veiculosAvgOrderByAggregateInput = {
    id?: SortOrder
    motorista_id?: SortOrder
    ano?: SortOrder
  }

  export type veiculosMaxOrderByAggregateInput = {
    id?: SortOrder
    motorista_id?: SortOrder
    modelo?: SortOrder
    placa?: SortOrder
    ano?: SortOrder
    categoria?: SortOrder
    status?: SortOrder
    observacoes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type veiculosMinOrderByAggregateInput = {
    id?: SortOrder
    motorista_id?: SortOrder
    modelo?: SortOrder
    placa?: SortOrder
    ano?: SortOrder
    categoria?: SortOrder
    status?: SortOrder
    observacoes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type veiculosSumOrderByAggregateInput = {
    id?: SortOrder
    motorista_id?: SortOrder
    ano?: SortOrder
  }

  export type Enumenum_veiculos_categoriaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_veiculos_categoria | Enumenum_veiculos_categoriaFieldRefInput<$PrismaModel>
    in?: $Enums.enum_veiculos_categoria[] | ListEnumenum_veiculos_categoriaFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_veiculos_categoria[] | ListEnumenum_veiculos_categoriaFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_veiculos_categoriaWithAggregatesFilter<$PrismaModel> | $Enums.enum_veiculos_categoria
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumenum_veiculos_categoriaFilter<$PrismaModel>
    _max?: NestedEnumenum_veiculos_categoriaFilter<$PrismaModel>
  }

  export type Enumenum_veiculos_statusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_veiculos_status | Enumenum_veiculos_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_veiculos_status[] | ListEnumenum_veiculos_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_veiculos_status[] | ListEnumenum_veiculos_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_veiculos_statusNullableWithAggregatesFilter<$PrismaModel> | $Enums.enum_veiculos_status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumenum_veiculos_statusNullableFilter<$PrismaModel>
    _max?: NestedEnumenum_veiculos_statusNullableFilter<$PrismaModel>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableEnumenum_BairroPrioridades_tipo_prioridadeFieldUpdateOperationsInput = {
    set?: $Enums.enum_BairroPrioridades_tipo_prioridade | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumenum_Corridas_tipoFieldUpdateOperationsInput = {
    set?: $Enums.enum_Corridas_tipo | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type Enumenum_Denuncia_tipo_alvoFieldUpdateOperationsInput = {
    set?: $Enums.enum_Denuncia_tipo_alvo
  }

  export type Enumenum_Documentos_tipo_documentoFieldUpdateOperationsInput = {
    set?: $Enums.enum_Documentos_tipo_documento
  }

  export type NullableEnumenum_EmailEnviados_tipoFieldUpdateOperationsInput = {
    set?: $Enums.enum_EmailEnviados_tipo | null
  }

  export type NullableEnumenum_HistoricoIndicacaos_tipoFieldUpdateOperationsInput = {
    set?: $Enums.enum_HistoricoIndicacaos_tipo | null
  }

  export type NullableEnumenum_HistoricoSelfies_tipoFieldUpdateOperationsInput = {
    set?: $Enums.enum_HistoricoSelfies_tipo | null
  }

  export type UsuariosCreateNestedOneWithoutIndicacaos_Indicacaos_indicadoIdToUsuariosInput = {
    create?: XOR<UsuariosCreateWithoutIndicacaos_Indicacaos_indicadoIdToUsuariosInput, UsuariosUncheckedCreateWithoutIndicacaos_Indicacaos_indicadoIdToUsuariosInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutIndicacaos_Indicacaos_indicadoIdToUsuariosInput
    connect?: UsuariosWhereUniqueInput
  }

  export type UsuariosCreateNestedOneWithoutIndicacaos_Indicacaos_indicanteIdToUsuariosInput = {
    create?: XOR<UsuariosCreateWithoutIndicacaos_Indicacaos_indicanteIdToUsuariosInput, UsuariosUncheckedCreateWithoutIndicacaos_Indicacaos_indicanteIdToUsuariosInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutIndicacaos_Indicacaos_indicanteIdToUsuariosInput
    connect?: UsuariosWhereUniqueInput
  }

  export type UsuariosUpdateOneRequiredWithoutIndicacaos_Indicacaos_indicadoIdToUsuariosNestedInput = {
    create?: XOR<UsuariosCreateWithoutIndicacaos_Indicacaos_indicadoIdToUsuariosInput, UsuariosUncheckedCreateWithoutIndicacaos_Indicacaos_indicadoIdToUsuariosInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutIndicacaos_Indicacaos_indicadoIdToUsuariosInput
    upsert?: UsuariosUpsertWithoutIndicacaos_Indicacaos_indicadoIdToUsuariosInput
    connect?: UsuariosWhereUniqueInput
    update?: XOR<XOR<UsuariosUpdateToOneWithWhereWithoutIndicacaos_Indicacaos_indicadoIdToUsuariosInput, UsuariosUpdateWithoutIndicacaos_Indicacaos_indicadoIdToUsuariosInput>, UsuariosUncheckedUpdateWithoutIndicacaos_Indicacaos_indicadoIdToUsuariosInput>
  }

  export type UsuariosUpdateOneRequiredWithoutIndicacaos_Indicacaos_indicanteIdToUsuariosNestedInput = {
    create?: XOR<UsuariosCreateWithoutIndicacaos_Indicacaos_indicanteIdToUsuariosInput, UsuariosUncheckedCreateWithoutIndicacaos_Indicacaos_indicanteIdToUsuariosInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutIndicacaos_Indicacaos_indicanteIdToUsuariosInput
    upsert?: UsuariosUpsertWithoutIndicacaos_Indicacaos_indicanteIdToUsuariosInput
    connect?: UsuariosWhereUniqueInput
    update?: XOR<XOR<UsuariosUpdateToOneWithWhereWithoutIndicacaos_Indicacaos_indicanteIdToUsuariosInput, UsuariosUpdateWithoutIndicacaos_Indicacaos_indicanteIdToUsuariosInput>, UsuariosUncheckedUpdateWithoutIndicacaos_Indicacaos_indicanteIdToUsuariosInput>
  }

  export type NullableEnumenum_LogAcessos_tipo_usuarioFieldUpdateOperationsInput = {
    set?: $Enums.enum_LogAcessos_tipo_usuario | null
  }

  export type NullableEnumenum_MensagemSuportes_tipo_usuarioFieldUpdateOperationsInput = {
    set?: $Enums.enum_MensagemSuportes_tipo_usuario | null
  }

  export type UsuariosCreateNestedOneWithoutRecompensasInput = {
    create?: XOR<UsuariosCreateWithoutRecompensasInput, UsuariosUncheckedCreateWithoutRecompensasInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutRecompensasInput
    connect?: UsuariosWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumenum_Recompensas_statusFieldUpdateOperationsInput = {
    set?: $Enums.enum_Recompensas_status | null
  }

  export type UsuariosUpdateOneRequiredWithoutRecompensasNestedInput = {
    create?: XOR<UsuariosCreateWithoutRecompensasInput, UsuariosUncheckedCreateWithoutRecompensasInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutRecompensasInput
    upsert?: UsuariosUpsertWithoutRecompensasInput
    connect?: UsuariosWhereUniqueInput
    update?: XOR<XOR<UsuariosUpdateToOneWithWhereWithoutRecompensasInput, UsuariosUpdateWithoutRecompensasInput>, UsuariosUncheckedUpdateWithoutRecompensasInput>
  }

  export type UsuariosCreateNestedOneWithoutSaquesInput = {
    create?: XOR<UsuariosCreateWithoutSaquesInput, UsuariosUncheckedCreateWithoutSaquesInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutSaquesInput
    connect?: UsuariosWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableEnumenum_Saques_statusFieldUpdateOperationsInput = {
    set?: $Enums.enum_Saques_status | null
  }

  export type Enumenum_Saques_tipoFieldUpdateOperationsInput = {
    set?: $Enums.enum_Saques_tipo
  }

  export type UsuariosUpdateOneRequiredWithoutSaquesNestedInput = {
    create?: XOR<UsuariosCreateWithoutSaquesInput, UsuariosUncheckedCreateWithoutSaquesInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutSaquesInput
    upsert?: UsuariosUpsertWithoutSaquesInput
    connect?: UsuariosWhereUniqueInput
    update?: XOR<XOR<UsuariosUpdateToOneWithWhereWithoutSaquesInput, UsuariosUpdateWithoutSaquesInput>, UsuariosUncheckedUpdateWithoutSaquesInput>
  }

  export type UsuariosCreateNestedOneWithoutTransacaosInput = {
    create?: XOR<UsuariosCreateWithoutTransacaosInput, UsuariosUncheckedCreateWithoutTransacaosInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutTransacaosInput
    connect?: UsuariosWhereUniqueInput
  }

  export type Enumenum_Transacaos_tipoFieldUpdateOperationsInput = {
    set?: $Enums.enum_Transacaos_tipo
  }

  export type UsuariosUpdateOneRequiredWithoutTransacaosNestedInput = {
    create?: XOR<UsuariosCreateWithoutTransacaosInput, UsuariosUncheckedCreateWithoutTransacaosInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutTransacaosInput
    upsert?: UsuariosUpsertWithoutTransacaosInput
    connect?: UsuariosWhereUniqueInput
    update?: XOR<XOR<UsuariosUpdateToOneWithWhereWithoutTransacaosInput, UsuariosUpdateWithoutTransacaosInput>, UsuariosUncheckedUpdateWithoutTransacaosInput>
  }

  export type IndicacaosCreateNestedManyWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput = {
    create?: XOR<IndicacaosCreateWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput, IndicacaosUncheckedCreateWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput> | IndicacaosCreateWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput[] | IndicacaosUncheckedCreateWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput[]
    connectOrCreate?: IndicacaosCreateOrConnectWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput | IndicacaosCreateOrConnectWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput[]
    createMany?: IndicacaosCreateManyUsuarios_Indicacaos_indicadoIdToUsuariosInputEnvelope
    connect?: IndicacaosWhereUniqueInput | IndicacaosWhereUniqueInput[]
  }

  export type IndicacaosCreateNestedManyWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput = {
    create?: XOR<IndicacaosCreateWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput, IndicacaosUncheckedCreateWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput> | IndicacaosCreateWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput[] | IndicacaosUncheckedCreateWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput[]
    connectOrCreate?: IndicacaosCreateOrConnectWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput | IndicacaosCreateOrConnectWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput[]
    createMany?: IndicacaosCreateManyUsuarios_Indicacaos_indicanteIdToUsuariosInputEnvelope
    connect?: IndicacaosWhereUniqueInput | IndicacaosWhereUniqueInput[]
  }

  export type RecompensasCreateNestedManyWithoutUsuariosInput = {
    create?: XOR<RecompensasCreateWithoutUsuariosInput, RecompensasUncheckedCreateWithoutUsuariosInput> | RecompensasCreateWithoutUsuariosInput[] | RecompensasUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: RecompensasCreateOrConnectWithoutUsuariosInput | RecompensasCreateOrConnectWithoutUsuariosInput[]
    createMany?: RecompensasCreateManyUsuariosInputEnvelope
    connect?: RecompensasWhereUniqueInput | RecompensasWhereUniqueInput[]
  }

  export type SaquesCreateNestedManyWithoutUsuariosInput = {
    create?: XOR<SaquesCreateWithoutUsuariosInput, SaquesUncheckedCreateWithoutUsuariosInput> | SaquesCreateWithoutUsuariosInput[] | SaquesUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: SaquesCreateOrConnectWithoutUsuariosInput | SaquesCreateOrConnectWithoutUsuariosInput[]
    createMany?: SaquesCreateManyUsuariosInputEnvelope
    connect?: SaquesWhereUniqueInput | SaquesWhereUniqueInput[]
  }

  export type TransacaosCreateNestedManyWithoutUsuariosInput = {
    create?: XOR<TransacaosCreateWithoutUsuariosInput, TransacaosUncheckedCreateWithoutUsuariosInput> | TransacaosCreateWithoutUsuariosInput[] | TransacaosUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: TransacaosCreateOrConnectWithoutUsuariosInput | TransacaosCreateOrConnectWithoutUsuariosInput[]
    createMany?: TransacaosCreateManyUsuariosInputEnvelope
    connect?: TransacaosWhereUniqueInput | TransacaosWhereUniqueInput[]
  }

  export type IndicacaosUncheckedCreateNestedManyWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput = {
    create?: XOR<IndicacaosCreateWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput, IndicacaosUncheckedCreateWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput> | IndicacaosCreateWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput[] | IndicacaosUncheckedCreateWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput[]
    connectOrCreate?: IndicacaosCreateOrConnectWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput | IndicacaosCreateOrConnectWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput[]
    createMany?: IndicacaosCreateManyUsuarios_Indicacaos_indicadoIdToUsuariosInputEnvelope
    connect?: IndicacaosWhereUniqueInput | IndicacaosWhereUniqueInput[]
  }

  export type IndicacaosUncheckedCreateNestedManyWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput = {
    create?: XOR<IndicacaosCreateWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput, IndicacaosUncheckedCreateWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput> | IndicacaosCreateWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput[] | IndicacaosUncheckedCreateWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput[]
    connectOrCreate?: IndicacaosCreateOrConnectWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput | IndicacaosCreateOrConnectWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput[]
    createMany?: IndicacaosCreateManyUsuarios_Indicacaos_indicanteIdToUsuariosInputEnvelope
    connect?: IndicacaosWhereUniqueInput | IndicacaosWhereUniqueInput[]
  }

  export type RecompensasUncheckedCreateNestedManyWithoutUsuariosInput = {
    create?: XOR<RecompensasCreateWithoutUsuariosInput, RecompensasUncheckedCreateWithoutUsuariosInput> | RecompensasCreateWithoutUsuariosInput[] | RecompensasUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: RecompensasCreateOrConnectWithoutUsuariosInput | RecompensasCreateOrConnectWithoutUsuariosInput[]
    createMany?: RecompensasCreateManyUsuariosInputEnvelope
    connect?: RecompensasWhereUniqueInput | RecompensasWhereUniqueInput[]
  }

  export type SaquesUncheckedCreateNestedManyWithoutUsuariosInput = {
    create?: XOR<SaquesCreateWithoutUsuariosInput, SaquesUncheckedCreateWithoutUsuariosInput> | SaquesCreateWithoutUsuariosInput[] | SaquesUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: SaquesCreateOrConnectWithoutUsuariosInput | SaquesCreateOrConnectWithoutUsuariosInput[]
    createMany?: SaquesCreateManyUsuariosInputEnvelope
    connect?: SaquesWhereUniqueInput | SaquesWhereUniqueInput[]
  }

  export type TransacaosUncheckedCreateNestedManyWithoutUsuariosInput = {
    create?: XOR<TransacaosCreateWithoutUsuariosInput, TransacaosUncheckedCreateWithoutUsuariosInput> | TransacaosCreateWithoutUsuariosInput[] | TransacaosUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: TransacaosCreateOrConnectWithoutUsuariosInput | TransacaosCreateOrConnectWithoutUsuariosInput[]
    createMany?: TransacaosCreateManyUsuariosInputEnvelope
    connect?: TransacaosWhereUniqueInput | TransacaosWhereUniqueInput[]
  }

  export type IndicacaosUpdateManyWithoutUsuarios_Indicacaos_indicadoIdToUsuariosNestedInput = {
    create?: XOR<IndicacaosCreateWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput, IndicacaosUncheckedCreateWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput> | IndicacaosCreateWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput[] | IndicacaosUncheckedCreateWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput[]
    connectOrCreate?: IndicacaosCreateOrConnectWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput | IndicacaosCreateOrConnectWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput[]
    upsert?: IndicacaosUpsertWithWhereUniqueWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput | IndicacaosUpsertWithWhereUniqueWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput[]
    createMany?: IndicacaosCreateManyUsuarios_Indicacaos_indicadoIdToUsuariosInputEnvelope
    set?: IndicacaosWhereUniqueInput | IndicacaosWhereUniqueInput[]
    disconnect?: IndicacaosWhereUniqueInput | IndicacaosWhereUniqueInput[]
    delete?: IndicacaosWhereUniqueInput | IndicacaosWhereUniqueInput[]
    connect?: IndicacaosWhereUniqueInput | IndicacaosWhereUniqueInput[]
    update?: IndicacaosUpdateWithWhereUniqueWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput | IndicacaosUpdateWithWhereUniqueWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput[]
    updateMany?: IndicacaosUpdateManyWithWhereWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput | IndicacaosUpdateManyWithWhereWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput[]
    deleteMany?: IndicacaosScalarWhereInput | IndicacaosScalarWhereInput[]
  }

  export type IndicacaosUpdateManyWithoutUsuarios_Indicacaos_indicanteIdToUsuariosNestedInput = {
    create?: XOR<IndicacaosCreateWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput, IndicacaosUncheckedCreateWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput> | IndicacaosCreateWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput[] | IndicacaosUncheckedCreateWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput[]
    connectOrCreate?: IndicacaosCreateOrConnectWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput | IndicacaosCreateOrConnectWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput[]
    upsert?: IndicacaosUpsertWithWhereUniqueWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput | IndicacaosUpsertWithWhereUniqueWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput[]
    createMany?: IndicacaosCreateManyUsuarios_Indicacaos_indicanteIdToUsuariosInputEnvelope
    set?: IndicacaosWhereUniqueInput | IndicacaosWhereUniqueInput[]
    disconnect?: IndicacaosWhereUniqueInput | IndicacaosWhereUniqueInput[]
    delete?: IndicacaosWhereUniqueInput | IndicacaosWhereUniqueInput[]
    connect?: IndicacaosWhereUniqueInput | IndicacaosWhereUniqueInput[]
    update?: IndicacaosUpdateWithWhereUniqueWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput | IndicacaosUpdateWithWhereUniqueWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput[]
    updateMany?: IndicacaosUpdateManyWithWhereWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput | IndicacaosUpdateManyWithWhereWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput[]
    deleteMany?: IndicacaosScalarWhereInput | IndicacaosScalarWhereInput[]
  }

  export type RecompensasUpdateManyWithoutUsuariosNestedInput = {
    create?: XOR<RecompensasCreateWithoutUsuariosInput, RecompensasUncheckedCreateWithoutUsuariosInput> | RecompensasCreateWithoutUsuariosInput[] | RecompensasUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: RecompensasCreateOrConnectWithoutUsuariosInput | RecompensasCreateOrConnectWithoutUsuariosInput[]
    upsert?: RecompensasUpsertWithWhereUniqueWithoutUsuariosInput | RecompensasUpsertWithWhereUniqueWithoutUsuariosInput[]
    createMany?: RecompensasCreateManyUsuariosInputEnvelope
    set?: RecompensasWhereUniqueInput | RecompensasWhereUniqueInput[]
    disconnect?: RecompensasWhereUniqueInput | RecompensasWhereUniqueInput[]
    delete?: RecompensasWhereUniqueInput | RecompensasWhereUniqueInput[]
    connect?: RecompensasWhereUniqueInput | RecompensasWhereUniqueInput[]
    update?: RecompensasUpdateWithWhereUniqueWithoutUsuariosInput | RecompensasUpdateWithWhereUniqueWithoutUsuariosInput[]
    updateMany?: RecompensasUpdateManyWithWhereWithoutUsuariosInput | RecompensasUpdateManyWithWhereWithoutUsuariosInput[]
    deleteMany?: RecompensasScalarWhereInput | RecompensasScalarWhereInput[]
  }

  export type SaquesUpdateManyWithoutUsuariosNestedInput = {
    create?: XOR<SaquesCreateWithoutUsuariosInput, SaquesUncheckedCreateWithoutUsuariosInput> | SaquesCreateWithoutUsuariosInput[] | SaquesUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: SaquesCreateOrConnectWithoutUsuariosInput | SaquesCreateOrConnectWithoutUsuariosInput[]
    upsert?: SaquesUpsertWithWhereUniqueWithoutUsuariosInput | SaquesUpsertWithWhereUniqueWithoutUsuariosInput[]
    createMany?: SaquesCreateManyUsuariosInputEnvelope
    set?: SaquesWhereUniqueInput | SaquesWhereUniqueInput[]
    disconnect?: SaquesWhereUniqueInput | SaquesWhereUniqueInput[]
    delete?: SaquesWhereUniqueInput | SaquesWhereUniqueInput[]
    connect?: SaquesWhereUniqueInput | SaquesWhereUniqueInput[]
    update?: SaquesUpdateWithWhereUniqueWithoutUsuariosInput | SaquesUpdateWithWhereUniqueWithoutUsuariosInput[]
    updateMany?: SaquesUpdateManyWithWhereWithoutUsuariosInput | SaquesUpdateManyWithWhereWithoutUsuariosInput[]
    deleteMany?: SaquesScalarWhereInput | SaquesScalarWhereInput[]
  }

  export type TransacaosUpdateManyWithoutUsuariosNestedInput = {
    create?: XOR<TransacaosCreateWithoutUsuariosInput, TransacaosUncheckedCreateWithoutUsuariosInput> | TransacaosCreateWithoutUsuariosInput[] | TransacaosUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: TransacaosCreateOrConnectWithoutUsuariosInput | TransacaosCreateOrConnectWithoutUsuariosInput[]
    upsert?: TransacaosUpsertWithWhereUniqueWithoutUsuariosInput | TransacaosUpsertWithWhereUniqueWithoutUsuariosInput[]
    createMany?: TransacaosCreateManyUsuariosInputEnvelope
    set?: TransacaosWhereUniqueInput | TransacaosWhereUniqueInput[]
    disconnect?: TransacaosWhereUniqueInput | TransacaosWhereUniqueInput[]
    delete?: TransacaosWhereUniqueInput | TransacaosWhereUniqueInput[]
    connect?: TransacaosWhereUniqueInput | TransacaosWhereUniqueInput[]
    update?: TransacaosUpdateWithWhereUniqueWithoutUsuariosInput | TransacaosUpdateWithWhereUniqueWithoutUsuariosInput[]
    updateMany?: TransacaosUpdateManyWithWhereWithoutUsuariosInput | TransacaosUpdateManyWithWhereWithoutUsuariosInput[]
    deleteMany?: TransacaosScalarWhereInput | TransacaosScalarWhereInput[]
  }

  export type IndicacaosUncheckedUpdateManyWithoutUsuarios_Indicacaos_indicadoIdToUsuariosNestedInput = {
    create?: XOR<IndicacaosCreateWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput, IndicacaosUncheckedCreateWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput> | IndicacaosCreateWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput[] | IndicacaosUncheckedCreateWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput[]
    connectOrCreate?: IndicacaosCreateOrConnectWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput | IndicacaosCreateOrConnectWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput[]
    upsert?: IndicacaosUpsertWithWhereUniqueWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput | IndicacaosUpsertWithWhereUniqueWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput[]
    createMany?: IndicacaosCreateManyUsuarios_Indicacaos_indicadoIdToUsuariosInputEnvelope
    set?: IndicacaosWhereUniqueInput | IndicacaosWhereUniqueInput[]
    disconnect?: IndicacaosWhereUniqueInput | IndicacaosWhereUniqueInput[]
    delete?: IndicacaosWhereUniqueInput | IndicacaosWhereUniqueInput[]
    connect?: IndicacaosWhereUniqueInput | IndicacaosWhereUniqueInput[]
    update?: IndicacaosUpdateWithWhereUniqueWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput | IndicacaosUpdateWithWhereUniqueWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput[]
    updateMany?: IndicacaosUpdateManyWithWhereWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput | IndicacaosUpdateManyWithWhereWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput[]
    deleteMany?: IndicacaosScalarWhereInput | IndicacaosScalarWhereInput[]
  }

  export type IndicacaosUncheckedUpdateManyWithoutUsuarios_Indicacaos_indicanteIdToUsuariosNestedInput = {
    create?: XOR<IndicacaosCreateWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput, IndicacaosUncheckedCreateWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput> | IndicacaosCreateWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput[] | IndicacaosUncheckedCreateWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput[]
    connectOrCreate?: IndicacaosCreateOrConnectWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput | IndicacaosCreateOrConnectWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput[]
    upsert?: IndicacaosUpsertWithWhereUniqueWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput | IndicacaosUpsertWithWhereUniqueWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput[]
    createMany?: IndicacaosCreateManyUsuarios_Indicacaos_indicanteIdToUsuariosInputEnvelope
    set?: IndicacaosWhereUniqueInput | IndicacaosWhereUniqueInput[]
    disconnect?: IndicacaosWhereUniqueInput | IndicacaosWhereUniqueInput[]
    delete?: IndicacaosWhereUniqueInput | IndicacaosWhereUniqueInput[]
    connect?: IndicacaosWhereUniqueInput | IndicacaosWhereUniqueInput[]
    update?: IndicacaosUpdateWithWhereUniqueWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput | IndicacaosUpdateWithWhereUniqueWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput[]
    updateMany?: IndicacaosUpdateManyWithWhereWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput | IndicacaosUpdateManyWithWhereWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput[]
    deleteMany?: IndicacaosScalarWhereInput | IndicacaosScalarWhereInput[]
  }

  export type RecompensasUncheckedUpdateManyWithoutUsuariosNestedInput = {
    create?: XOR<RecompensasCreateWithoutUsuariosInput, RecompensasUncheckedCreateWithoutUsuariosInput> | RecompensasCreateWithoutUsuariosInput[] | RecompensasUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: RecompensasCreateOrConnectWithoutUsuariosInput | RecompensasCreateOrConnectWithoutUsuariosInput[]
    upsert?: RecompensasUpsertWithWhereUniqueWithoutUsuariosInput | RecompensasUpsertWithWhereUniqueWithoutUsuariosInput[]
    createMany?: RecompensasCreateManyUsuariosInputEnvelope
    set?: RecompensasWhereUniqueInput | RecompensasWhereUniqueInput[]
    disconnect?: RecompensasWhereUniqueInput | RecompensasWhereUniqueInput[]
    delete?: RecompensasWhereUniqueInput | RecompensasWhereUniqueInput[]
    connect?: RecompensasWhereUniqueInput | RecompensasWhereUniqueInput[]
    update?: RecompensasUpdateWithWhereUniqueWithoutUsuariosInput | RecompensasUpdateWithWhereUniqueWithoutUsuariosInput[]
    updateMany?: RecompensasUpdateManyWithWhereWithoutUsuariosInput | RecompensasUpdateManyWithWhereWithoutUsuariosInput[]
    deleteMany?: RecompensasScalarWhereInput | RecompensasScalarWhereInput[]
  }

  export type SaquesUncheckedUpdateManyWithoutUsuariosNestedInput = {
    create?: XOR<SaquesCreateWithoutUsuariosInput, SaquesUncheckedCreateWithoutUsuariosInput> | SaquesCreateWithoutUsuariosInput[] | SaquesUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: SaquesCreateOrConnectWithoutUsuariosInput | SaquesCreateOrConnectWithoutUsuariosInput[]
    upsert?: SaquesUpsertWithWhereUniqueWithoutUsuariosInput | SaquesUpsertWithWhereUniqueWithoutUsuariosInput[]
    createMany?: SaquesCreateManyUsuariosInputEnvelope
    set?: SaquesWhereUniqueInput | SaquesWhereUniqueInput[]
    disconnect?: SaquesWhereUniqueInput | SaquesWhereUniqueInput[]
    delete?: SaquesWhereUniqueInput | SaquesWhereUniqueInput[]
    connect?: SaquesWhereUniqueInput | SaquesWhereUniqueInput[]
    update?: SaquesUpdateWithWhereUniqueWithoutUsuariosInput | SaquesUpdateWithWhereUniqueWithoutUsuariosInput[]
    updateMany?: SaquesUpdateManyWithWhereWithoutUsuariosInput | SaquesUpdateManyWithWhereWithoutUsuariosInput[]
    deleteMany?: SaquesScalarWhereInput | SaquesScalarWhereInput[]
  }

  export type TransacaosUncheckedUpdateManyWithoutUsuariosNestedInput = {
    create?: XOR<TransacaosCreateWithoutUsuariosInput, TransacaosUncheckedCreateWithoutUsuariosInput> | TransacaosCreateWithoutUsuariosInput[] | TransacaosUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: TransacaosCreateOrConnectWithoutUsuariosInput | TransacaosCreateOrConnectWithoutUsuariosInput[]
    upsert?: TransacaosUpsertWithWhereUniqueWithoutUsuariosInput | TransacaosUpsertWithWhereUniqueWithoutUsuariosInput[]
    createMany?: TransacaosCreateManyUsuariosInputEnvelope
    set?: TransacaosWhereUniqueInput | TransacaosWhereUniqueInput[]
    disconnect?: TransacaosWhereUniqueInput | TransacaosWhereUniqueInput[]
    delete?: TransacaosWhereUniqueInput | TransacaosWhereUniqueInput[]
    connect?: TransacaosWhereUniqueInput | TransacaosWhereUniqueInput[]
    update?: TransacaosUpdateWithWhereUniqueWithoutUsuariosInput | TransacaosUpdateWithWhereUniqueWithoutUsuariosInput[]
    updateMany?: TransacaosUpdateManyWithWhereWithoutUsuariosInput | TransacaosUpdateManyWithWhereWithoutUsuariosInput[]
    deleteMany?: TransacaosScalarWhereInput | TransacaosScalarWhereInput[]
  }

  export type NullableEnumenum_Veiculos_categoriaFieldUpdateOperationsInput = {
    set?: $Enums.enum_Veiculos_categoria | null
  }

  export type Enumenum_agenda_corridas_categoriaFieldUpdateOperationsInput = {
    set?: $Enums.enum_agenda_corridas_categoria
  }

  export type NullableEnumenum_agenda_corridas_statusFieldUpdateOperationsInput = {
    set?: $Enums.enum_agenda_corridas_status | null
  }

  export type Enumenum_avaliacoes_tipoFieldUpdateOperationsInput = {
    set?: $Enums.enum_avaliacoes_tipo
  }

  export type Enumenum_bairros_prioridade_tipo_prioridadeFieldUpdateOperationsInput = {
    set?: $Enums.enum_bairros_prioridade_tipo_prioridade
  }

  export type Enumenum_carteiras_tipoFieldUpdateOperationsInput = {
    set?: $Enums.enum_carteiras_tipo
  }

  export type NullableEnumenum_corridas_statusFieldUpdateOperationsInput = {
    set?: $Enums.enum_corridas_status | null
  }

  export type Enumenum_corridas_forma_pagamentoFieldUpdateOperationsInput = {
    set?: $Enums.enum_corridas_forma_pagamento
  }

  export type Enumenum_denuncias_tipo_alvoFieldUpdateOperationsInput = {
    set?: $Enums.enum_denuncias_tipo_alvo
  }

  export type NullableEnumenum_denuncias_statusFieldUpdateOperationsInput = {
    set?: $Enums.enum_denuncias_status | null
  }

  export type Enumenum_documentos_tipo_documentoFieldUpdateOperationsInput = {
    set?: $Enums.enum_documentos_tipo_documento
  }

  export type NullableEnumenum_documentos_statusFieldUpdateOperationsInput = {
    set?: $Enums.enum_documentos_status | null
  }

  export type Enumenum_emails_enviados_tipoFieldUpdateOperationsInput = {
    set?: $Enums.enum_emails_enviados_tipo
  }

  export type NullableEnumenum_emails_enviados_status_envioFieldUpdateOperationsInput = {
    set?: $Enums.enum_emails_enviados_status_envio | null
  }

  export type Enumenum_historico_indicacoes_tipoFieldUpdateOperationsInput = {
    set?: $Enums.enum_historico_indicacoes_tipo
  }

  export type Enumenum_historico_selfies_tipoFieldUpdateOperationsInput = {
    set?: $Enums.enum_historico_selfies_tipo
  }

  export type NullableEnumenum_historico_selfies_resultadoFieldUpdateOperationsInput = {
    set?: $Enums.enum_historico_selfies_resultado | null
  }

  export type Enumenum_logs_acesso_tipo_usuarioFieldUpdateOperationsInput = {
    set?: $Enums.enum_logs_acesso_tipo_usuario
  }

  export type Enumenum_mensagens_suporte_tipo_usuarioFieldUpdateOperationsInput = {
    set?: $Enums.enum_mensagens_suporte_tipo_usuario
  }

  export type NullableEnumenum_mensagens_suporte_statusFieldUpdateOperationsInput = {
    set?: $Enums.enum_mensagens_suporte_status | null
  }

  export type Enumenum_recompensas_tipoFieldUpdateOperationsInput = {
    set?: $Enums.enum_recompensas_tipo
  }

  export type NullableEnumenum_recompensas_statusFieldUpdateOperationsInput = {
    set?: $Enums.enum_recompensas_status | null
  }

  export type NullableEnumenum_saques_statusFieldUpdateOperationsInput = {
    set?: $Enums.enum_saques_status | null
  }

  export type Enumenum_saques_tipoFieldUpdateOperationsInput = {
    set?: $Enums.enum_saques_tipo
  }

  export type Enumenum_transacoes_tipoFieldUpdateOperationsInput = {
    set?: $Enums.enum_transacoes_tipo
  }

  export type Enumenum_transacoes_origemFieldUpdateOperationsInput = {
    set?: $Enums.enum_transacoes_origem
  }

  export type Enumenum_usuarios_tipoFieldUpdateOperationsInput = {
    set?: $Enums.enum_usuarios_tipo
  }

  export type Enumenum_veiculos_categoriaFieldUpdateOperationsInput = {
    set?: $Enums.enum_veiculos_categoria
  }

  export type NullableEnumenum_veiculos_statusFieldUpdateOperationsInput = {
    set?: $Enums.enum_veiculos_status | null
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedEnumenum_BairroPrioridades_tipo_prioridadeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_BairroPrioridades_tipo_prioridade | Enumenum_BairroPrioridades_tipo_prioridadeFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_BairroPrioridades_tipo_prioridade[] | ListEnumenum_BairroPrioridades_tipo_prioridadeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_BairroPrioridades_tipo_prioridade[] | ListEnumenum_BairroPrioridades_tipo_prioridadeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_BairroPrioridades_tipo_prioridadeNullableFilter<$PrismaModel> | $Enums.enum_BairroPrioridades_tipo_prioridade | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumenum_BairroPrioridades_tipo_prioridadeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_BairroPrioridades_tipo_prioridade | Enumenum_BairroPrioridades_tipo_prioridadeFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_BairroPrioridades_tipo_prioridade[] | ListEnumenum_BairroPrioridades_tipo_prioridadeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_BairroPrioridades_tipo_prioridade[] | ListEnumenum_BairroPrioridades_tipo_prioridadeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_BairroPrioridades_tipo_prioridadeNullableWithAggregatesFilter<$PrismaModel> | $Enums.enum_BairroPrioridades_tipo_prioridade | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumenum_BairroPrioridades_tipo_prioridadeNullableFilter<$PrismaModel>
    _max?: NestedEnumenum_BairroPrioridades_tipo_prioridadeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumenum_Corridas_tipoNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_Corridas_tipo | Enumenum_Corridas_tipoFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_Corridas_tipo[] | ListEnumenum_Corridas_tipoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_Corridas_tipo[] | ListEnumenum_Corridas_tipoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_Corridas_tipoNullableFilter<$PrismaModel> | $Enums.enum_Corridas_tipo | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumenum_Corridas_tipoNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_Corridas_tipo | Enumenum_Corridas_tipoFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_Corridas_tipo[] | ListEnumenum_Corridas_tipoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_Corridas_tipo[] | ListEnumenum_Corridas_tipoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_Corridas_tipoNullableWithAggregatesFilter<$PrismaModel> | $Enums.enum_Corridas_tipo | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumenum_Corridas_tipoNullableFilter<$PrismaModel>
    _max?: NestedEnumenum_Corridas_tipoNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumenum_Denuncia_tipo_alvoFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_Denuncia_tipo_alvo | Enumenum_Denuncia_tipo_alvoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_Denuncia_tipo_alvo[] | ListEnumenum_Denuncia_tipo_alvoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_Denuncia_tipo_alvo[] | ListEnumenum_Denuncia_tipo_alvoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_Denuncia_tipo_alvoFilter<$PrismaModel> | $Enums.enum_Denuncia_tipo_alvo
  }

  export type NestedEnumenum_Denuncia_tipo_alvoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_Denuncia_tipo_alvo | Enumenum_Denuncia_tipo_alvoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_Denuncia_tipo_alvo[] | ListEnumenum_Denuncia_tipo_alvoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_Denuncia_tipo_alvo[] | ListEnumenum_Denuncia_tipo_alvoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_Denuncia_tipo_alvoWithAggregatesFilter<$PrismaModel> | $Enums.enum_Denuncia_tipo_alvo
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumenum_Denuncia_tipo_alvoFilter<$PrismaModel>
    _max?: NestedEnumenum_Denuncia_tipo_alvoFilter<$PrismaModel>
  }

  export type NestedEnumenum_Documentos_tipo_documentoFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_Documentos_tipo_documento | Enumenum_Documentos_tipo_documentoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_Documentos_tipo_documento[] | ListEnumenum_Documentos_tipo_documentoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_Documentos_tipo_documento[] | ListEnumenum_Documentos_tipo_documentoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_Documentos_tipo_documentoFilter<$PrismaModel> | $Enums.enum_Documentos_tipo_documento
  }

  export type NestedEnumenum_Documentos_tipo_documentoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_Documentos_tipo_documento | Enumenum_Documentos_tipo_documentoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_Documentos_tipo_documento[] | ListEnumenum_Documentos_tipo_documentoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_Documentos_tipo_documento[] | ListEnumenum_Documentos_tipo_documentoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_Documentos_tipo_documentoWithAggregatesFilter<$PrismaModel> | $Enums.enum_Documentos_tipo_documento
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumenum_Documentos_tipo_documentoFilter<$PrismaModel>
    _max?: NestedEnumenum_Documentos_tipo_documentoFilter<$PrismaModel>
  }

  export type NestedEnumenum_EmailEnviados_tipoNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_EmailEnviados_tipo | Enumenum_EmailEnviados_tipoFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_EmailEnviados_tipo[] | ListEnumenum_EmailEnviados_tipoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_EmailEnviados_tipo[] | ListEnumenum_EmailEnviados_tipoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_EmailEnviados_tipoNullableFilter<$PrismaModel> | $Enums.enum_EmailEnviados_tipo | null
  }

  export type NestedEnumenum_EmailEnviados_tipoNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_EmailEnviados_tipo | Enumenum_EmailEnviados_tipoFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_EmailEnviados_tipo[] | ListEnumenum_EmailEnviados_tipoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_EmailEnviados_tipo[] | ListEnumenum_EmailEnviados_tipoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_EmailEnviados_tipoNullableWithAggregatesFilter<$PrismaModel> | $Enums.enum_EmailEnviados_tipo | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumenum_EmailEnviados_tipoNullableFilter<$PrismaModel>
    _max?: NestedEnumenum_EmailEnviados_tipoNullableFilter<$PrismaModel>
  }

  export type NestedEnumenum_HistoricoIndicacaos_tipoNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_HistoricoIndicacaos_tipo | Enumenum_HistoricoIndicacaos_tipoFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_HistoricoIndicacaos_tipo[] | ListEnumenum_HistoricoIndicacaos_tipoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_HistoricoIndicacaos_tipo[] | ListEnumenum_HistoricoIndicacaos_tipoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_HistoricoIndicacaos_tipoNullableFilter<$PrismaModel> | $Enums.enum_HistoricoIndicacaos_tipo | null
  }

  export type NestedEnumenum_HistoricoIndicacaos_tipoNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_HistoricoIndicacaos_tipo | Enumenum_HistoricoIndicacaos_tipoFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_HistoricoIndicacaos_tipo[] | ListEnumenum_HistoricoIndicacaos_tipoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_HistoricoIndicacaos_tipo[] | ListEnumenum_HistoricoIndicacaos_tipoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_HistoricoIndicacaos_tipoNullableWithAggregatesFilter<$PrismaModel> | $Enums.enum_HistoricoIndicacaos_tipo | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumenum_HistoricoIndicacaos_tipoNullableFilter<$PrismaModel>
    _max?: NestedEnumenum_HistoricoIndicacaos_tipoNullableFilter<$PrismaModel>
  }

  export type NestedEnumenum_HistoricoSelfies_tipoNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_HistoricoSelfies_tipo | Enumenum_HistoricoSelfies_tipoFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_HistoricoSelfies_tipo[] | ListEnumenum_HistoricoSelfies_tipoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_HistoricoSelfies_tipo[] | ListEnumenum_HistoricoSelfies_tipoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_HistoricoSelfies_tipoNullableFilter<$PrismaModel> | $Enums.enum_HistoricoSelfies_tipo | null
  }

  export type NestedEnumenum_HistoricoSelfies_tipoNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_HistoricoSelfies_tipo | Enumenum_HistoricoSelfies_tipoFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_HistoricoSelfies_tipo[] | ListEnumenum_HistoricoSelfies_tipoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_HistoricoSelfies_tipo[] | ListEnumenum_HistoricoSelfies_tipoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_HistoricoSelfies_tipoNullableWithAggregatesFilter<$PrismaModel> | $Enums.enum_HistoricoSelfies_tipo | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumenum_HistoricoSelfies_tipoNullableFilter<$PrismaModel>
    _max?: NestedEnumenum_HistoricoSelfies_tipoNullableFilter<$PrismaModel>
  }

  export type NestedEnumenum_LogAcessos_tipo_usuarioNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_LogAcessos_tipo_usuario | Enumenum_LogAcessos_tipo_usuarioFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_LogAcessos_tipo_usuario[] | ListEnumenum_LogAcessos_tipo_usuarioFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_LogAcessos_tipo_usuario[] | ListEnumenum_LogAcessos_tipo_usuarioFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_LogAcessos_tipo_usuarioNullableFilter<$PrismaModel> | $Enums.enum_LogAcessos_tipo_usuario | null
  }

  export type NestedEnumenum_LogAcessos_tipo_usuarioNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_LogAcessos_tipo_usuario | Enumenum_LogAcessos_tipo_usuarioFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_LogAcessos_tipo_usuario[] | ListEnumenum_LogAcessos_tipo_usuarioFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_LogAcessos_tipo_usuario[] | ListEnumenum_LogAcessos_tipo_usuarioFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_LogAcessos_tipo_usuarioNullableWithAggregatesFilter<$PrismaModel> | $Enums.enum_LogAcessos_tipo_usuario | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumenum_LogAcessos_tipo_usuarioNullableFilter<$PrismaModel>
    _max?: NestedEnumenum_LogAcessos_tipo_usuarioNullableFilter<$PrismaModel>
  }

  export type NestedEnumenum_MensagemSuportes_tipo_usuarioNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_MensagemSuportes_tipo_usuario | Enumenum_MensagemSuportes_tipo_usuarioFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_MensagemSuportes_tipo_usuario[] | ListEnumenum_MensagemSuportes_tipo_usuarioFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_MensagemSuportes_tipo_usuario[] | ListEnumenum_MensagemSuportes_tipo_usuarioFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_MensagemSuportes_tipo_usuarioNullableFilter<$PrismaModel> | $Enums.enum_MensagemSuportes_tipo_usuario | null
  }

  export type NestedEnumenum_MensagemSuportes_tipo_usuarioNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_MensagemSuportes_tipo_usuario | Enumenum_MensagemSuportes_tipo_usuarioFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_MensagemSuportes_tipo_usuario[] | ListEnumenum_MensagemSuportes_tipo_usuarioFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_MensagemSuportes_tipo_usuario[] | ListEnumenum_MensagemSuportes_tipo_usuarioFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_MensagemSuportes_tipo_usuarioNullableWithAggregatesFilter<$PrismaModel> | $Enums.enum_MensagemSuportes_tipo_usuario | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumenum_MensagemSuportes_tipo_usuarioNullableFilter<$PrismaModel>
    _max?: NestedEnumenum_MensagemSuportes_tipo_usuarioNullableFilter<$PrismaModel>
  }

  export type NestedEnumenum_Recompensas_statusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_Recompensas_status | Enumenum_Recompensas_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_Recompensas_status[] | ListEnumenum_Recompensas_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_Recompensas_status[] | ListEnumenum_Recompensas_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_Recompensas_statusNullableFilter<$PrismaModel> | $Enums.enum_Recompensas_status | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumenum_Recompensas_statusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_Recompensas_status | Enumenum_Recompensas_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_Recompensas_status[] | ListEnumenum_Recompensas_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_Recompensas_status[] | ListEnumenum_Recompensas_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_Recompensas_statusNullableWithAggregatesFilter<$PrismaModel> | $Enums.enum_Recompensas_status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumenum_Recompensas_statusNullableFilter<$PrismaModel>
    _max?: NestedEnumenum_Recompensas_statusNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumenum_Saques_statusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_Saques_status | Enumenum_Saques_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_Saques_status[] | ListEnumenum_Saques_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_Saques_status[] | ListEnumenum_Saques_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_Saques_statusNullableFilter<$PrismaModel> | $Enums.enum_Saques_status | null
  }

  export type NestedEnumenum_Saques_tipoFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_Saques_tipo | Enumenum_Saques_tipoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_Saques_tipo[] | ListEnumenum_Saques_tipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_Saques_tipo[] | ListEnumenum_Saques_tipoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_Saques_tipoFilter<$PrismaModel> | $Enums.enum_Saques_tipo
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumenum_Saques_statusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_Saques_status | Enumenum_Saques_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_Saques_status[] | ListEnumenum_Saques_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_Saques_status[] | ListEnumenum_Saques_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_Saques_statusNullableWithAggregatesFilter<$PrismaModel> | $Enums.enum_Saques_status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumenum_Saques_statusNullableFilter<$PrismaModel>
    _max?: NestedEnumenum_Saques_statusNullableFilter<$PrismaModel>
  }

  export type NestedEnumenum_Saques_tipoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_Saques_tipo | Enumenum_Saques_tipoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_Saques_tipo[] | ListEnumenum_Saques_tipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_Saques_tipo[] | ListEnumenum_Saques_tipoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_Saques_tipoWithAggregatesFilter<$PrismaModel> | $Enums.enum_Saques_tipo
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumenum_Saques_tipoFilter<$PrismaModel>
    _max?: NestedEnumenum_Saques_tipoFilter<$PrismaModel>
  }

  export type NestedEnumenum_Transacaos_tipoFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_Transacaos_tipo | Enumenum_Transacaos_tipoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_Transacaos_tipo[] | ListEnumenum_Transacaos_tipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_Transacaos_tipo[] | ListEnumenum_Transacaos_tipoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_Transacaos_tipoFilter<$PrismaModel> | $Enums.enum_Transacaos_tipo
  }

  export type NestedEnumenum_Transacaos_tipoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_Transacaos_tipo | Enumenum_Transacaos_tipoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_Transacaos_tipo[] | ListEnumenum_Transacaos_tipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_Transacaos_tipo[] | ListEnumenum_Transacaos_tipoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_Transacaos_tipoWithAggregatesFilter<$PrismaModel> | $Enums.enum_Transacaos_tipo
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumenum_Transacaos_tipoFilter<$PrismaModel>
    _max?: NestedEnumenum_Transacaos_tipoFilter<$PrismaModel>
  }

  export type NestedEnumenum_Veiculos_categoriaNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_Veiculos_categoria | Enumenum_Veiculos_categoriaFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_Veiculos_categoria[] | ListEnumenum_Veiculos_categoriaFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_Veiculos_categoria[] | ListEnumenum_Veiculos_categoriaFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_Veiculos_categoriaNullableFilter<$PrismaModel> | $Enums.enum_Veiculos_categoria | null
  }

  export type NestedEnumenum_Veiculos_categoriaNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_Veiculos_categoria | Enumenum_Veiculos_categoriaFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_Veiculos_categoria[] | ListEnumenum_Veiculos_categoriaFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_Veiculos_categoria[] | ListEnumenum_Veiculos_categoriaFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_Veiculos_categoriaNullableWithAggregatesFilter<$PrismaModel> | $Enums.enum_Veiculos_categoria | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumenum_Veiculos_categoriaNullableFilter<$PrismaModel>
    _max?: NestedEnumenum_Veiculos_categoriaNullableFilter<$PrismaModel>
  }

  export type NestedEnumenum_agenda_corridas_categoriaFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_agenda_corridas_categoria | Enumenum_agenda_corridas_categoriaFieldRefInput<$PrismaModel>
    in?: $Enums.enum_agenda_corridas_categoria[] | ListEnumenum_agenda_corridas_categoriaFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_agenda_corridas_categoria[] | ListEnumenum_agenda_corridas_categoriaFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_agenda_corridas_categoriaFilter<$PrismaModel> | $Enums.enum_agenda_corridas_categoria
  }

  export type NestedEnumenum_agenda_corridas_statusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_agenda_corridas_status | Enumenum_agenda_corridas_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_agenda_corridas_status[] | ListEnumenum_agenda_corridas_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_agenda_corridas_status[] | ListEnumenum_agenda_corridas_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_agenda_corridas_statusNullableFilter<$PrismaModel> | $Enums.enum_agenda_corridas_status | null
  }

  export type NestedEnumenum_agenda_corridas_categoriaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_agenda_corridas_categoria | Enumenum_agenda_corridas_categoriaFieldRefInput<$PrismaModel>
    in?: $Enums.enum_agenda_corridas_categoria[] | ListEnumenum_agenda_corridas_categoriaFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_agenda_corridas_categoria[] | ListEnumenum_agenda_corridas_categoriaFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_agenda_corridas_categoriaWithAggregatesFilter<$PrismaModel> | $Enums.enum_agenda_corridas_categoria
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumenum_agenda_corridas_categoriaFilter<$PrismaModel>
    _max?: NestedEnumenum_agenda_corridas_categoriaFilter<$PrismaModel>
  }

  export type NestedEnumenum_agenda_corridas_statusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_agenda_corridas_status | Enumenum_agenda_corridas_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_agenda_corridas_status[] | ListEnumenum_agenda_corridas_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_agenda_corridas_status[] | ListEnumenum_agenda_corridas_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_agenda_corridas_statusNullableWithAggregatesFilter<$PrismaModel> | $Enums.enum_agenda_corridas_status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumenum_agenda_corridas_statusNullableFilter<$PrismaModel>
    _max?: NestedEnumenum_agenda_corridas_statusNullableFilter<$PrismaModel>
  }

  export type NestedEnumenum_avaliacoes_tipoFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_avaliacoes_tipo | Enumenum_avaliacoes_tipoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_avaliacoes_tipo[] | ListEnumenum_avaliacoes_tipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_avaliacoes_tipo[] | ListEnumenum_avaliacoes_tipoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_avaliacoes_tipoFilter<$PrismaModel> | $Enums.enum_avaliacoes_tipo
  }

  export type NestedEnumenum_avaliacoes_tipoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_avaliacoes_tipo | Enumenum_avaliacoes_tipoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_avaliacoes_tipo[] | ListEnumenum_avaliacoes_tipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_avaliacoes_tipo[] | ListEnumenum_avaliacoes_tipoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_avaliacoes_tipoWithAggregatesFilter<$PrismaModel> | $Enums.enum_avaliacoes_tipo
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumenum_avaliacoes_tipoFilter<$PrismaModel>
    _max?: NestedEnumenum_avaliacoes_tipoFilter<$PrismaModel>
  }

  export type NestedEnumenum_bairros_prioridade_tipo_prioridadeFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_bairros_prioridade_tipo_prioridade | Enumenum_bairros_prioridade_tipo_prioridadeFieldRefInput<$PrismaModel>
    in?: $Enums.enum_bairros_prioridade_tipo_prioridade[] | ListEnumenum_bairros_prioridade_tipo_prioridadeFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_bairros_prioridade_tipo_prioridade[] | ListEnumenum_bairros_prioridade_tipo_prioridadeFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_bairros_prioridade_tipo_prioridadeFilter<$PrismaModel> | $Enums.enum_bairros_prioridade_tipo_prioridade
  }

  export type NestedEnumenum_bairros_prioridade_tipo_prioridadeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_bairros_prioridade_tipo_prioridade | Enumenum_bairros_prioridade_tipo_prioridadeFieldRefInput<$PrismaModel>
    in?: $Enums.enum_bairros_prioridade_tipo_prioridade[] | ListEnumenum_bairros_prioridade_tipo_prioridadeFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_bairros_prioridade_tipo_prioridade[] | ListEnumenum_bairros_prioridade_tipo_prioridadeFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_bairros_prioridade_tipo_prioridadeWithAggregatesFilter<$PrismaModel> | $Enums.enum_bairros_prioridade_tipo_prioridade
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumenum_bairros_prioridade_tipo_prioridadeFilter<$PrismaModel>
    _max?: NestedEnumenum_bairros_prioridade_tipo_prioridadeFilter<$PrismaModel>
  }

  export type NestedEnumenum_carteiras_tipoFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_carteiras_tipo | Enumenum_carteiras_tipoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_carteiras_tipo[] | ListEnumenum_carteiras_tipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_carteiras_tipo[] | ListEnumenum_carteiras_tipoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_carteiras_tipoFilter<$PrismaModel> | $Enums.enum_carteiras_tipo
  }

  export type NestedEnumenum_carteiras_tipoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_carteiras_tipo | Enumenum_carteiras_tipoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_carteiras_tipo[] | ListEnumenum_carteiras_tipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_carteiras_tipo[] | ListEnumenum_carteiras_tipoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_carteiras_tipoWithAggregatesFilter<$PrismaModel> | $Enums.enum_carteiras_tipo
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumenum_carteiras_tipoFilter<$PrismaModel>
    _max?: NestedEnumenum_carteiras_tipoFilter<$PrismaModel>
  }

  export type NestedEnumenum_corridas_statusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_corridas_status | Enumenum_corridas_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_corridas_status[] | ListEnumenum_corridas_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_corridas_status[] | ListEnumenum_corridas_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_corridas_statusNullableFilter<$PrismaModel> | $Enums.enum_corridas_status | null
  }

  export type NestedEnumenum_corridas_forma_pagamentoFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_corridas_forma_pagamento | Enumenum_corridas_forma_pagamentoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_corridas_forma_pagamento[] | ListEnumenum_corridas_forma_pagamentoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_corridas_forma_pagamento[] | ListEnumenum_corridas_forma_pagamentoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_corridas_forma_pagamentoFilter<$PrismaModel> | $Enums.enum_corridas_forma_pagamento
  }

  export type NestedEnumenum_corridas_statusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_corridas_status | Enumenum_corridas_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_corridas_status[] | ListEnumenum_corridas_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_corridas_status[] | ListEnumenum_corridas_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_corridas_statusNullableWithAggregatesFilter<$PrismaModel> | $Enums.enum_corridas_status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumenum_corridas_statusNullableFilter<$PrismaModel>
    _max?: NestedEnumenum_corridas_statusNullableFilter<$PrismaModel>
  }

  export type NestedEnumenum_corridas_forma_pagamentoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_corridas_forma_pagamento | Enumenum_corridas_forma_pagamentoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_corridas_forma_pagamento[] | ListEnumenum_corridas_forma_pagamentoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_corridas_forma_pagamento[] | ListEnumenum_corridas_forma_pagamentoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_corridas_forma_pagamentoWithAggregatesFilter<$PrismaModel> | $Enums.enum_corridas_forma_pagamento
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumenum_corridas_forma_pagamentoFilter<$PrismaModel>
    _max?: NestedEnumenum_corridas_forma_pagamentoFilter<$PrismaModel>
  }

  export type NestedEnumenum_denuncias_tipo_alvoFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_denuncias_tipo_alvo | Enumenum_denuncias_tipo_alvoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_denuncias_tipo_alvo[] | ListEnumenum_denuncias_tipo_alvoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_denuncias_tipo_alvo[] | ListEnumenum_denuncias_tipo_alvoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_denuncias_tipo_alvoFilter<$PrismaModel> | $Enums.enum_denuncias_tipo_alvo
  }

  export type NestedEnumenum_denuncias_statusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_denuncias_status | Enumenum_denuncias_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_denuncias_status[] | ListEnumenum_denuncias_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_denuncias_status[] | ListEnumenum_denuncias_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_denuncias_statusNullableFilter<$PrismaModel> | $Enums.enum_denuncias_status | null
  }

  export type NestedEnumenum_denuncias_tipo_alvoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_denuncias_tipo_alvo | Enumenum_denuncias_tipo_alvoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_denuncias_tipo_alvo[] | ListEnumenum_denuncias_tipo_alvoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_denuncias_tipo_alvo[] | ListEnumenum_denuncias_tipo_alvoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_denuncias_tipo_alvoWithAggregatesFilter<$PrismaModel> | $Enums.enum_denuncias_tipo_alvo
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumenum_denuncias_tipo_alvoFilter<$PrismaModel>
    _max?: NestedEnumenum_denuncias_tipo_alvoFilter<$PrismaModel>
  }

  export type NestedEnumenum_denuncias_statusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_denuncias_status | Enumenum_denuncias_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_denuncias_status[] | ListEnumenum_denuncias_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_denuncias_status[] | ListEnumenum_denuncias_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_denuncias_statusNullableWithAggregatesFilter<$PrismaModel> | $Enums.enum_denuncias_status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumenum_denuncias_statusNullableFilter<$PrismaModel>
    _max?: NestedEnumenum_denuncias_statusNullableFilter<$PrismaModel>
  }

  export type NestedEnumenum_documentos_tipo_documentoFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_documentos_tipo_documento | Enumenum_documentos_tipo_documentoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_documentos_tipo_documento[] | ListEnumenum_documentos_tipo_documentoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_documentos_tipo_documento[] | ListEnumenum_documentos_tipo_documentoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_documentos_tipo_documentoFilter<$PrismaModel> | $Enums.enum_documentos_tipo_documento
  }

  export type NestedEnumenum_documentos_statusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_documentos_status | Enumenum_documentos_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_documentos_status[] | ListEnumenum_documentos_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_documentos_status[] | ListEnumenum_documentos_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_documentos_statusNullableFilter<$PrismaModel> | $Enums.enum_documentos_status | null
  }

  export type NestedEnumenum_documentos_tipo_documentoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_documentos_tipo_documento | Enumenum_documentos_tipo_documentoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_documentos_tipo_documento[] | ListEnumenum_documentos_tipo_documentoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_documentos_tipo_documento[] | ListEnumenum_documentos_tipo_documentoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_documentos_tipo_documentoWithAggregatesFilter<$PrismaModel> | $Enums.enum_documentos_tipo_documento
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumenum_documentos_tipo_documentoFilter<$PrismaModel>
    _max?: NestedEnumenum_documentos_tipo_documentoFilter<$PrismaModel>
  }

  export type NestedEnumenum_documentos_statusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_documentos_status | Enumenum_documentos_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_documentos_status[] | ListEnumenum_documentos_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_documentos_status[] | ListEnumenum_documentos_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_documentos_statusNullableWithAggregatesFilter<$PrismaModel> | $Enums.enum_documentos_status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumenum_documentos_statusNullableFilter<$PrismaModel>
    _max?: NestedEnumenum_documentos_statusNullableFilter<$PrismaModel>
  }

  export type NestedEnumenum_emails_enviados_tipoFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_emails_enviados_tipo | Enumenum_emails_enviados_tipoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_emails_enviados_tipo[] | ListEnumenum_emails_enviados_tipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_emails_enviados_tipo[] | ListEnumenum_emails_enviados_tipoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_emails_enviados_tipoFilter<$PrismaModel> | $Enums.enum_emails_enviados_tipo
  }

  export type NestedEnumenum_emails_enviados_status_envioNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_emails_enviados_status_envio | Enumenum_emails_enviados_status_envioFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_emails_enviados_status_envio[] | ListEnumenum_emails_enviados_status_envioFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_emails_enviados_status_envio[] | ListEnumenum_emails_enviados_status_envioFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_emails_enviados_status_envioNullableFilter<$PrismaModel> | $Enums.enum_emails_enviados_status_envio | null
  }

  export type NestedEnumenum_emails_enviados_tipoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_emails_enviados_tipo | Enumenum_emails_enviados_tipoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_emails_enviados_tipo[] | ListEnumenum_emails_enviados_tipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_emails_enviados_tipo[] | ListEnumenum_emails_enviados_tipoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_emails_enviados_tipoWithAggregatesFilter<$PrismaModel> | $Enums.enum_emails_enviados_tipo
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumenum_emails_enviados_tipoFilter<$PrismaModel>
    _max?: NestedEnumenum_emails_enviados_tipoFilter<$PrismaModel>
  }

  export type NestedEnumenum_emails_enviados_status_envioNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_emails_enviados_status_envio | Enumenum_emails_enviados_status_envioFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_emails_enviados_status_envio[] | ListEnumenum_emails_enviados_status_envioFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_emails_enviados_status_envio[] | ListEnumenum_emails_enviados_status_envioFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_emails_enviados_status_envioNullableWithAggregatesFilter<$PrismaModel> | $Enums.enum_emails_enviados_status_envio | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumenum_emails_enviados_status_envioNullableFilter<$PrismaModel>
    _max?: NestedEnumenum_emails_enviados_status_envioNullableFilter<$PrismaModel>
  }

  export type NestedEnumenum_historico_indicacoes_tipoFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_historico_indicacoes_tipo | Enumenum_historico_indicacoes_tipoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_historico_indicacoes_tipo[] | ListEnumenum_historico_indicacoes_tipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_historico_indicacoes_tipo[] | ListEnumenum_historico_indicacoes_tipoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_historico_indicacoes_tipoFilter<$PrismaModel> | $Enums.enum_historico_indicacoes_tipo
  }

  export type NestedEnumenum_historico_indicacoes_tipoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_historico_indicacoes_tipo | Enumenum_historico_indicacoes_tipoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_historico_indicacoes_tipo[] | ListEnumenum_historico_indicacoes_tipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_historico_indicacoes_tipo[] | ListEnumenum_historico_indicacoes_tipoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_historico_indicacoes_tipoWithAggregatesFilter<$PrismaModel> | $Enums.enum_historico_indicacoes_tipo
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumenum_historico_indicacoes_tipoFilter<$PrismaModel>
    _max?: NestedEnumenum_historico_indicacoes_tipoFilter<$PrismaModel>
  }

  export type NestedEnumenum_historico_selfies_tipoFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_historico_selfies_tipo | Enumenum_historico_selfies_tipoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_historico_selfies_tipo[] | ListEnumenum_historico_selfies_tipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_historico_selfies_tipo[] | ListEnumenum_historico_selfies_tipoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_historico_selfies_tipoFilter<$PrismaModel> | $Enums.enum_historico_selfies_tipo
  }

  export type NestedEnumenum_historico_selfies_resultadoNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_historico_selfies_resultado | Enumenum_historico_selfies_resultadoFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_historico_selfies_resultado[] | ListEnumenum_historico_selfies_resultadoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_historico_selfies_resultado[] | ListEnumenum_historico_selfies_resultadoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_historico_selfies_resultadoNullableFilter<$PrismaModel> | $Enums.enum_historico_selfies_resultado | null
  }

  export type NestedEnumenum_historico_selfies_tipoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_historico_selfies_tipo | Enumenum_historico_selfies_tipoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_historico_selfies_tipo[] | ListEnumenum_historico_selfies_tipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_historico_selfies_tipo[] | ListEnumenum_historico_selfies_tipoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_historico_selfies_tipoWithAggregatesFilter<$PrismaModel> | $Enums.enum_historico_selfies_tipo
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumenum_historico_selfies_tipoFilter<$PrismaModel>
    _max?: NestedEnumenum_historico_selfies_tipoFilter<$PrismaModel>
  }

  export type NestedEnumenum_historico_selfies_resultadoNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_historico_selfies_resultado | Enumenum_historico_selfies_resultadoFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_historico_selfies_resultado[] | ListEnumenum_historico_selfies_resultadoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_historico_selfies_resultado[] | ListEnumenum_historico_selfies_resultadoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_historico_selfies_resultadoNullableWithAggregatesFilter<$PrismaModel> | $Enums.enum_historico_selfies_resultado | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumenum_historico_selfies_resultadoNullableFilter<$PrismaModel>
    _max?: NestedEnumenum_historico_selfies_resultadoNullableFilter<$PrismaModel>
  }

  export type NestedEnumenum_logs_acesso_tipo_usuarioFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_logs_acesso_tipo_usuario | Enumenum_logs_acesso_tipo_usuarioFieldRefInput<$PrismaModel>
    in?: $Enums.enum_logs_acesso_tipo_usuario[] | ListEnumenum_logs_acesso_tipo_usuarioFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_logs_acesso_tipo_usuario[] | ListEnumenum_logs_acesso_tipo_usuarioFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_logs_acesso_tipo_usuarioFilter<$PrismaModel> | $Enums.enum_logs_acesso_tipo_usuario
  }

  export type NestedEnumenum_logs_acesso_tipo_usuarioWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_logs_acesso_tipo_usuario | Enumenum_logs_acesso_tipo_usuarioFieldRefInput<$PrismaModel>
    in?: $Enums.enum_logs_acesso_tipo_usuario[] | ListEnumenum_logs_acesso_tipo_usuarioFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_logs_acesso_tipo_usuario[] | ListEnumenum_logs_acesso_tipo_usuarioFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_logs_acesso_tipo_usuarioWithAggregatesFilter<$PrismaModel> | $Enums.enum_logs_acesso_tipo_usuario
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumenum_logs_acesso_tipo_usuarioFilter<$PrismaModel>
    _max?: NestedEnumenum_logs_acesso_tipo_usuarioFilter<$PrismaModel>
  }

  export type NestedEnumenum_mensagens_suporte_tipo_usuarioFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_mensagens_suporte_tipo_usuario | Enumenum_mensagens_suporte_tipo_usuarioFieldRefInput<$PrismaModel>
    in?: $Enums.enum_mensagens_suporte_tipo_usuario[] | ListEnumenum_mensagens_suporte_tipo_usuarioFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_mensagens_suporte_tipo_usuario[] | ListEnumenum_mensagens_suporte_tipo_usuarioFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_mensagens_suporte_tipo_usuarioFilter<$PrismaModel> | $Enums.enum_mensagens_suporte_tipo_usuario
  }

  export type NestedEnumenum_mensagens_suporte_statusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_mensagens_suporte_status | Enumenum_mensagens_suporte_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_mensagens_suporte_status[] | ListEnumenum_mensagens_suporte_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_mensagens_suporte_status[] | ListEnumenum_mensagens_suporte_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_mensagens_suporte_statusNullableFilter<$PrismaModel> | $Enums.enum_mensagens_suporte_status | null
  }

  export type NestedEnumenum_mensagens_suporte_tipo_usuarioWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_mensagens_suporte_tipo_usuario | Enumenum_mensagens_suporte_tipo_usuarioFieldRefInput<$PrismaModel>
    in?: $Enums.enum_mensagens_suporte_tipo_usuario[] | ListEnumenum_mensagens_suporte_tipo_usuarioFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_mensagens_suporte_tipo_usuario[] | ListEnumenum_mensagens_suporte_tipo_usuarioFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_mensagens_suporte_tipo_usuarioWithAggregatesFilter<$PrismaModel> | $Enums.enum_mensagens_suporte_tipo_usuario
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumenum_mensagens_suporte_tipo_usuarioFilter<$PrismaModel>
    _max?: NestedEnumenum_mensagens_suporte_tipo_usuarioFilter<$PrismaModel>
  }

  export type NestedEnumenum_mensagens_suporte_statusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_mensagens_suporte_status | Enumenum_mensagens_suporte_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_mensagens_suporte_status[] | ListEnumenum_mensagens_suporte_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_mensagens_suporte_status[] | ListEnumenum_mensagens_suporte_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_mensagens_suporte_statusNullableWithAggregatesFilter<$PrismaModel> | $Enums.enum_mensagens_suporte_status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumenum_mensagens_suporte_statusNullableFilter<$PrismaModel>
    _max?: NestedEnumenum_mensagens_suporte_statusNullableFilter<$PrismaModel>
  }

  export type NestedEnumenum_recompensas_tipoFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_recompensas_tipo | Enumenum_recompensas_tipoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_recompensas_tipo[] | ListEnumenum_recompensas_tipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_recompensas_tipo[] | ListEnumenum_recompensas_tipoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_recompensas_tipoFilter<$PrismaModel> | $Enums.enum_recompensas_tipo
  }

  export type NestedEnumenum_recompensas_statusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_recompensas_status | Enumenum_recompensas_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_recompensas_status[] | ListEnumenum_recompensas_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_recompensas_status[] | ListEnumenum_recompensas_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_recompensas_statusNullableFilter<$PrismaModel> | $Enums.enum_recompensas_status | null
  }

  export type NestedEnumenum_recompensas_tipoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_recompensas_tipo | Enumenum_recompensas_tipoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_recompensas_tipo[] | ListEnumenum_recompensas_tipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_recompensas_tipo[] | ListEnumenum_recompensas_tipoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_recompensas_tipoWithAggregatesFilter<$PrismaModel> | $Enums.enum_recompensas_tipo
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumenum_recompensas_tipoFilter<$PrismaModel>
    _max?: NestedEnumenum_recompensas_tipoFilter<$PrismaModel>
  }

  export type NestedEnumenum_recompensas_statusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_recompensas_status | Enumenum_recompensas_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_recompensas_status[] | ListEnumenum_recompensas_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_recompensas_status[] | ListEnumenum_recompensas_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_recompensas_statusNullableWithAggregatesFilter<$PrismaModel> | $Enums.enum_recompensas_status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumenum_recompensas_statusNullableFilter<$PrismaModel>
    _max?: NestedEnumenum_recompensas_statusNullableFilter<$PrismaModel>
  }

  export type NestedEnumenum_saques_statusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_saques_status | Enumenum_saques_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_saques_status[] | ListEnumenum_saques_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_saques_status[] | ListEnumenum_saques_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_saques_statusNullableFilter<$PrismaModel> | $Enums.enum_saques_status | null
  }

  export type NestedEnumenum_saques_tipoFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_saques_tipo | Enumenum_saques_tipoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_saques_tipo[] | ListEnumenum_saques_tipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_saques_tipo[] | ListEnumenum_saques_tipoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_saques_tipoFilter<$PrismaModel> | $Enums.enum_saques_tipo
  }

  export type NestedEnumenum_saques_statusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_saques_status | Enumenum_saques_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_saques_status[] | ListEnumenum_saques_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_saques_status[] | ListEnumenum_saques_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_saques_statusNullableWithAggregatesFilter<$PrismaModel> | $Enums.enum_saques_status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumenum_saques_statusNullableFilter<$PrismaModel>
    _max?: NestedEnumenum_saques_statusNullableFilter<$PrismaModel>
  }

  export type NestedEnumenum_saques_tipoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_saques_tipo | Enumenum_saques_tipoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_saques_tipo[] | ListEnumenum_saques_tipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_saques_tipo[] | ListEnumenum_saques_tipoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_saques_tipoWithAggregatesFilter<$PrismaModel> | $Enums.enum_saques_tipo
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumenum_saques_tipoFilter<$PrismaModel>
    _max?: NestedEnumenum_saques_tipoFilter<$PrismaModel>
  }

  export type NestedEnumenum_transacoes_tipoFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_transacoes_tipo | Enumenum_transacoes_tipoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_transacoes_tipo[] | ListEnumenum_transacoes_tipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_transacoes_tipo[] | ListEnumenum_transacoes_tipoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_transacoes_tipoFilter<$PrismaModel> | $Enums.enum_transacoes_tipo
  }

  export type NestedEnumenum_transacoes_origemFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_transacoes_origem | Enumenum_transacoes_origemFieldRefInput<$PrismaModel>
    in?: $Enums.enum_transacoes_origem[] | ListEnumenum_transacoes_origemFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_transacoes_origem[] | ListEnumenum_transacoes_origemFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_transacoes_origemFilter<$PrismaModel> | $Enums.enum_transacoes_origem
  }

  export type NestedEnumenum_transacoes_tipoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_transacoes_tipo | Enumenum_transacoes_tipoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_transacoes_tipo[] | ListEnumenum_transacoes_tipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_transacoes_tipo[] | ListEnumenum_transacoes_tipoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_transacoes_tipoWithAggregatesFilter<$PrismaModel> | $Enums.enum_transacoes_tipo
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumenum_transacoes_tipoFilter<$PrismaModel>
    _max?: NestedEnumenum_transacoes_tipoFilter<$PrismaModel>
  }

  export type NestedEnumenum_transacoes_origemWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_transacoes_origem | Enumenum_transacoes_origemFieldRefInput<$PrismaModel>
    in?: $Enums.enum_transacoes_origem[] | ListEnumenum_transacoes_origemFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_transacoes_origem[] | ListEnumenum_transacoes_origemFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_transacoes_origemWithAggregatesFilter<$PrismaModel> | $Enums.enum_transacoes_origem
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumenum_transacoes_origemFilter<$PrismaModel>
    _max?: NestedEnumenum_transacoes_origemFilter<$PrismaModel>
  }

  export type NestedEnumenum_usuarios_tipoFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_usuarios_tipo | Enumenum_usuarios_tipoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_usuarios_tipo[] | ListEnumenum_usuarios_tipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_usuarios_tipo[] | ListEnumenum_usuarios_tipoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_usuarios_tipoFilter<$PrismaModel> | $Enums.enum_usuarios_tipo
  }

  export type NestedEnumenum_usuarios_tipoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_usuarios_tipo | Enumenum_usuarios_tipoFieldRefInput<$PrismaModel>
    in?: $Enums.enum_usuarios_tipo[] | ListEnumenum_usuarios_tipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_usuarios_tipo[] | ListEnumenum_usuarios_tipoFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_usuarios_tipoWithAggregatesFilter<$PrismaModel> | $Enums.enum_usuarios_tipo
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumenum_usuarios_tipoFilter<$PrismaModel>
    _max?: NestedEnumenum_usuarios_tipoFilter<$PrismaModel>
  }

  export type NestedEnumenum_veiculos_categoriaFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_veiculos_categoria | Enumenum_veiculos_categoriaFieldRefInput<$PrismaModel>
    in?: $Enums.enum_veiculos_categoria[] | ListEnumenum_veiculos_categoriaFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_veiculos_categoria[] | ListEnumenum_veiculos_categoriaFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_veiculos_categoriaFilter<$PrismaModel> | $Enums.enum_veiculos_categoria
  }

  export type NestedEnumenum_veiculos_statusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_veiculos_status | Enumenum_veiculos_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_veiculos_status[] | ListEnumenum_veiculos_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_veiculos_status[] | ListEnumenum_veiculos_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_veiculos_statusNullableFilter<$PrismaModel> | $Enums.enum_veiculos_status | null
  }

  export type NestedEnumenum_veiculos_categoriaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_veiculos_categoria | Enumenum_veiculos_categoriaFieldRefInput<$PrismaModel>
    in?: $Enums.enum_veiculos_categoria[] | ListEnumenum_veiculos_categoriaFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_veiculos_categoria[] | ListEnumenum_veiculos_categoriaFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_veiculos_categoriaWithAggregatesFilter<$PrismaModel> | $Enums.enum_veiculos_categoria
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumenum_veiculos_categoriaFilter<$PrismaModel>
    _max?: NestedEnumenum_veiculos_categoriaFilter<$PrismaModel>
  }

  export type NestedEnumenum_veiculos_statusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_veiculos_status | Enumenum_veiculos_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_veiculos_status[] | ListEnumenum_veiculos_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_veiculos_status[] | ListEnumenum_veiculos_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_veiculos_statusNullableWithAggregatesFilter<$PrismaModel> | $Enums.enum_veiculos_status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumenum_veiculos_statusNullableFilter<$PrismaModel>
    _max?: NestedEnumenum_veiculos_statusNullableFilter<$PrismaModel>
  }

  export type UsuariosCreateWithoutIndicacaos_Indicacaos_indicadoIdToUsuariosInput = {
    nome: string
    email: string
    cpf?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    Indicacaos_Indicacaos_indicanteIdToUsuarios?: IndicacaosCreateNestedManyWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput
    Recompensas?: RecompensasCreateNestedManyWithoutUsuariosInput
    Saques?: SaquesCreateNestedManyWithoutUsuariosInput
    Transacaos?: TransacaosCreateNestedManyWithoutUsuariosInput
  }

  export type UsuariosUncheckedCreateWithoutIndicacaos_Indicacaos_indicadoIdToUsuariosInput = {
    id?: number
    nome: string
    email: string
    cpf?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    Indicacaos_Indicacaos_indicanteIdToUsuarios?: IndicacaosUncheckedCreateNestedManyWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput
    Recompensas?: RecompensasUncheckedCreateNestedManyWithoutUsuariosInput
    Saques?: SaquesUncheckedCreateNestedManyWithoutUsuariosInput
    Transacaos?: TransacaosUncheckedCreateNestedManyWithoutUsuariosInput
  }

  export type UsuariosCreateOrConnectWithoutIndicacaos_Indicacaos_indicadoIdToUsuariosInput = {
    where: UsuariosWhereUniqueInput
    create: XOR<UsuariosCreateWithoutIndicacaos_Indicacaos_indicadoIdToUsuariosInput, UsuariosUncheckedCreateWithoutIndicacaos_Indicacaos_indicadoIdToUsuariosInput>
  }

  export type UsuariosCreateWithoutIndicacaos_Indicacaos_indicanteIdToUsuariosInput = {
    nome: string
    email: string
    cpf?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    Indicacaos_Indicacaos_indicadoIdToUsuarios?: IndicacaosCreateNestedManyWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput
    Recompensas?: RecompensasCreateNestedManyWithoutUsuariosInput
    Saques?: SaquesCreateNestedManyWithoutUsuariosInput
    Transacaos?: TransacaosCreateNestedManyWithoutUsuariosInput
  }

  export type UsuariosUncheckedCreateWithoutIndicacaos_Indicacaos_indicanteIdToUsuariosInput = {
    id?: number
    nome: string
    email: string
    cpf?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    Indicacaos_Indicacaos_indicadoIdToUsuarios?: IndicacaosUncheckedCreateNestedManyWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput
    Recompensas?: RecompensasUncheckedCreateNestedManyWithoutUsuariosInput
    Saques?: SaquesUncheckedCreateNestedManyWithoutUsuariosInput
    Transacaos?: TransacaosUncheckedCreateNestedManyWithoutUsuariosInput
  }

  export type UsuariosCreateOrConnectWithoutIndicacaos_Indicacaos_indicanteIdToUsuariosInput = {
    where: UsuariosWhereUniqueInput
    create: XOR<UsuariosCreateWithoutIndicacaos_Indicacaos_indicanteIdToUsuariosInput, UsuariosUncheckedCreateWithoutIndicacaos_Indicacaos_indicanteIdToUsuariosInput>
  }

  export type UsuariosUpsertWithoutIndicacaos_Indicacaos_indicadoIdToUsuariosInput = {
    update: XOR<UsuariosUpdateWithoutIndicacaos_Indicacaos_indicadoIdToUsuariosInput, UsuariosUncheckedUpdateWithoutIndicacaos_Indicacaos_indicadoIdToUsuariosInput>
    create: XOR<UsuariosCreateWithoutIndicacaos_Indicacaos_indicadoIdToUsuariosInput, UsuariosUncheckedCreateWithoutIndicacaos_Indicacaos_indicadoIdToUsuariosInput>
    where?: UsuariosWhereInput
  }

  export type UsuariosUpdateToOneWithWhereWithoutIndicacaos_Indicacaos_indicadoIdToUsuariosInput = {
    where?: UsuariosWhereInput
    data: XOR<UsuariosUpdateWithoutIndicacaos_Indicacaos_indicadoIdToUsuariosInput, UsuariosUncheckedUpdateWithoutIndicacaos_Indicacaos_indicadoIdToUsuariosInput>
  }

  export type UsuariosUpdateWithoutIndicacaos_Indicacaos_indicadoIdToUsuariosInput = {
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Indicacaos_Indicacaos_indicanteIdToUsuarios?: IndicacaosUpdateManyWithoutUsuarios_Indicacaos_indicanteIdToUsuariosNestedInput
    Recompensas?: RecompensasUpdateManyWithoutUsuariosNestedInput
    Saques?: SaquesUpdateManyWithoutUsuariosNestedInput
    Transacaos?: TransacaosUpdateManyWithoutUsuariosNestedInput
  }

  export type UsuariosUncheckedUpdateWithoutIndicacaos_Indicacaos_indicadoIdToUsuariosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Indicacaos_Indicacaos_indicanteIdToUsuarios?: IndicacaosUncheckedUpdateManyWithoutUsuarios_Indicacaos_indicanteIdToUsuariosNestedInput
    Recompensas?: RecompensasUncheckedUpdateManyWithoutUsuariosNestedInput
    Saques?: SaquesUncheckedUpdateManyWithoutUsuariosNestedInput
    Transacaos?: TransacaosUncheckedUpdateManyWithoutUsuariosNestedInput
  }

  export type UsuariosUpsertWithoutIndicacaos_Indicacaos_indicanteIdToUsuariosInput = {
    update: XOR<UsuariosUpdateWithoutIndicacaos_Indicacaos_indicanteIdToUsuariosInput, UsuariosUncheckedUpdateWithoutIndicacaos_Indicacaos_indicanteIdToUsuariosInput>
    create: XOR<UsuariosCreateWithoutIndicacaos_Indicacaos_indicanteIdToUsuariosInput, UsuariosUncheckedCreateWithoutIndicacaos_Indicacaos_indicanteIdToUsuariosInput>
    where?: UsuariosWhereInput
  }

  export type UsuariosUpdateToOneWithWhereWithoutIndicacaos_Indicacaos_indicanteIdToUsuariosInput = {
    where?: UsuariosWhereInput
    data: XOR<UsuariosUpdateWithoutIndicacaos_Indicacaos_indicanteIdToUsuariosInput, UsuariosUncheckedUpdateWithoutIndicacaos_Indicacaos_indicanteIdToUsuariosInput>
  }

  export type UsuariosUpdateWithoutIndicacaos_Indicacaos_indicanteIdToUsuariosInput = {
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Indicacaos_Indicacaos_indicadoIdToUsuarios?: IndicacaosUpdateManyWithoutUsuarios_Indicacaos_indicadoIdToUsuariosNestedInput
    Recompensas?: RecompensasUpdateManyWithoutUsuariosNestedInput
    Saques?: SaquesUpdateManyWithoutUsuariosNestedInput
    Transacaos?: TransacaosUpdateManyWithoutUsuariosNestedInput
  }

  export type UsuariosUncheckedUpdateWithoutIndicacaos_Indicacaos_indicanteIdToUsuariosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Indicacaos_Indicacaos_indicadoIdToUsuarios?: IndicacaosUncheckedUpdateManyWithoutUsuarios_Indicacaos_indicadoIdToUsuariosNestedInput
    Recompensas?: RecompensasUncheckedUpdateManyWithoutUsuariosNestedInput
    Saques?: SaquesUncheckedUpdateManyWithoutUsuariosNestedInput
    Transacaos?: TransacaosUncheckedUpdateManyWithoutUsuariosNestedInput
  }

  export type UsuariosCreateWithoutRecompensasInput = {
    nome: string
    email: string
    cpf?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    Indicacaos_Indicacaos_indicadoIdToUsuarios?: IndicacaosCreateNestedManyWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput
    Indicacaos_Indicacaos_indicanteIdToUsuarios?: IndicacaosCreateNestedManyWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput
    Saques?: SaquesCreateNestedManyWithoutUsuariosInput
    Transacaos?: TransacaosCreateNestedManyWithoutUsuariosInput
  }

  export type UsuariosUncheckedCreateWithoutRecompensasInput = {
    id?: number
    nome: string
    email: string
    cpf?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    Indicacaos_Indicacaos_indicadoIdToUsuarios?: IndicacaosUncheckedCreateNestedManyWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput
    Indicacaos_Indicacaos_indicanteIdToUsuarios?: IndicacaosUncheckedCreateNestedManyWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput
    Saques?: SaquesUncheckedCreateNestedManyWithoutUsuariosInput
    Transacaos?: TransacaosUncheckedCreateNestedManyWithoutUsuariosInput
  }

  export type UsuariosCreateOrConnectWithoutRecompensasInput = {
    where: UsuariosWhereUniqueInput
    create: XOR<UsuariosCreateWithoutRecompensasInput, UsuariosUncheckedCreateWithoutRecompensasInput>
  }

  export type UsuariosUpsertWithoutRecompensasInput = {
    update: XOR<UsuariosUpdateWithoutRecompensasInput, UsuariosUncheckedUpdateWithoutRecompensasInput>
    create: XOR<UsuariosCreateWithoutRecompensasInput, UsuariosUncheckedCreateWithoutRecompensasInput>
    where?: UsuariosWhereInput
  }

  export type UsuariosUpdateToOneWithWhereWithoutRecompensasInput = {
    where?: UsuariosWhereInput
    data: XOR<UsuariosUpdateWithoutRecompensasInput, UsuariosUncheckedUpdateWithoutRecompensasInput>
  }

  export type UsuariosUpdateWithoutRecompensasInput = {
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Indicacaos_Indicacaos_indicadoIdToUsuarios?: IndicacaosUpdateManyWithoutUsuarios_Indicacaos_indicadoIdToUsuariosNestedInput
    Indicacaos_Indicacaos_indicanteIdToUsuarios?: IndicacaosUpdateManyWithoutUsuarios_Indicacaos_indicanteIdToUsuariosNestedInput
    Saques?: SaquesUpdateManyWithoutUsuariosNestedInput
    Transacaos?: TransacaosUpdateManyWithoutUsuariosNestedInput
  }

  export type UsuariosUncheckedUpdateWithoutRecompensasInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Indicacaos_Indicacaos_indicadoIdToUsuarios?: IndicacaosUncheckedUpdateManyWithoutUsuarios_Indicacaos_indicadoIdToUsuariosNestedInput
    Indicacaos_Indicacaos_indicanteIdToUsuarios?: IndicacaosUncheckedUpdateManyWithoutUsuarios_Indicacaos_indicanteIdToUsuariosNestedInput
    Saques?: SaquesUncheckedUpdateManyWithoutUsuariosNestedInput
    Transacaos?: TransacaosUncheckedUpdateManyWithoutUsuariosNestedInput
  }

  export type UsuariosCreateWithoutSaquesInput = {
    nome: string
    email: string
    cpf?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    Indicacaos_Indicacaos_indicadoIdToUsuarios?: IndicacaosCreateNestedManyWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput
    Indicacaos_Indicacaos_indicanteIdToUsuarios?: IndicacaosCreateNestedManyWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput
    Recompensas?: RecompensasCreateNestedManyWithoutUsuariosInput
    Transacaos?: TransacaosCreateNestedManyWithoutUsuariosInput
  }

  export type UsuariosUncheckedCreateWithoutSaquesInput = {
    id?: number
    nome: string
    email: string
    cpf?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    Indicacaos_Indicacaos_indicadoIdToUsuarios?: IndicacaosUncheckedCreateNestedManyWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput
    Indicacaos_Indicacaos_indicanteIdToUsuarios?: IndicacaosUncheckedCreateNestedManyWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput
    Recompensas?: RecompensasUncheckedCreateNestedManyWithoutUsuariosInput
    Transacaos?: TransacaosUncheckedCreateNestedManyWithoutUsuariosInput
  }

  export type UsuariosCreateOrConnectWithoutSaquesInput = {
    where: UsuariosWhereUniqueInput
    create: XOR<UsuariosCreateWithoutSaquesInput, UsuariosUncheckedCreateWithoutSaquesInput>
  }

  export type UsuariosUpsertWithoutSaquesInput = {
    update: XOR<UsuariosUpdateWithoutSaquesInput, UsuariosUncheckedUpdateWithoutSaquesInput>
    create: XOR<UsuariosCreateWithoutSaquesInput, UsuariosUncheckedCreateWithoutSaquesInput>
    where?: UsuariosWhereInput
  }

  export type UsuariosUpdateToOneWithWhereWithoutSaquesInput = {
    where?: UsuariosWhereInput
    data: XOR<UsuariosUpdateWithoutSaquesInput, UsuariosUncheckedUpdateWithoutSaquesInput>
  }

  export type UsuariosUpdateWithoutSaquesInput = {
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Indicacaos_Indicacaos_indicadoIdToUsuarios?: IndicacaosUpdateManyWithoutUsuarios_Indicacaos_indicadoIdToUsuariosNestedInput
    Indicacaos_Indicacaos_indicanteIdToUsuarios?: IndicacaosUpdateManyWithoutUsuarios_Indicacaos_indicanteIdToUsuariosNestedInput
    Recompensas?: RecompensasUpdateManyWithoutUsuariosNestedInput
    Transacaos?: TransacaosUpdateManyWithoutUsuariosNestedInput
  }

  export type UsuariosUncheckedUpdateWithoutSaquesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Indicacaos_Indicacaos_indicadoIdToUsuarios?: IndicacaosUncheckedUpdateManyWithoutUsuarios_Indicacaos_indicadoIdToUsuariosNestedInput
    Indicacaos_Indicacaos_indicanteIdToUsuarios?: IndicacaosUncheckedUpdateManyWithoutUsuarios_Indicacaos_indicanteIdToUsuariosNestedInput
    Recompensas?: RecompensasUncheckedUpdateManyWithoutUsuariosNestedInput
    Transacaos?: TransacaosUncheckedUpdateManyWithoutUsuariosNestedInput
  }

  export type UsuariosCreateWithoutTransacaosInput = {
    nome: string
    email: string
    cpf?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    Indicacaos_Indicacaos_indicadoIdToUsuarios?: IndicacaosCreateNestedManyWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput
    Indicacaos_Indicacaos_indicanteIdToUsuarios?: IndicacaosCreateNestedManyWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput
    Recompensas?: RecompensasCreateNestedManyWithoutUsuariosInput
    Saques?: SaquesCreateNestedManyWithoutUsuariosInput
  }

  export type UsuariosUncheckedCreateWithoutTransacaosInput = {
    id?: number
    nome: string
    email: string
    cpf?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    Indicacaos_Indicacaos_indicadoIdToUsuarios?: IndicacaosUncheckedCreateNestedManyWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput
    Indicacaos_Indicacaos_indicanteIdToUsuarios?: IndicacaosUncheckedCreateNestedManyWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput
    Recompensas?: RecompensasUncheckedCreateNestedManyWithoutUsuariosInput
    Saques?: SaquesUncheckedCreateNestedManyWithoutUsuariosInput
  }

  export type UsuariosCreateOrConnectWithoutTransacaosInput = {
    where: UsuariosWhereUniqueInput
    create: XOR<UsuariosCreateWithoutTransacaosInput, UsuariosUncheckedCreateWithoutTransacaosInput>
  }

  export type UsuariosUpsertWithoutTransacaosInput = {
    update: XOR<UsuariosUpdateWithoutTransacaosInput, UsuariosUncheckedUpdateWithoutTransacaosInput>
    create: XOR<UsuariosCreateWithoutTransacaosInput, UsuariosUncheckedCreateWithoutTransacaosInput>
    where?: UsuariosWhereInput
  }

  export type UsuariosUpdateToOneWithWhereWithoutTransacaosInput = {
    where?: UsuariosWhereInput
    data: XOR<UsuariosUpdateWithoutTransacaosInput, UsuariosUncheckedUpdateWithoutTransacaosInput>
  }

  export type UsuariosUpdateWithoutTransacaosInput = {
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Indicacaos_Indicacaos_indicadoIdToUsuarios?: IndicacaosUpdateManyWithoutUsuarios_Indicacaos_indicadoIdToUsuariosNestedInput
    Indicacaos_Indicacaos_indicanteIdToUsuarios?: IndicacaosUpdateManyWithoutUsuarios_Indicacaos_indicanteIdToUsuariosNestedInput
    Recompensas?: RecompensasUpdateManyWithoutUsuariosNestedInput
    Saques?: SaquesUpdateManyWithoutUsuariosNestedInput
  }

  export type UsuariosUncheckedUpdateWithoutTransacaosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Indicacaos_Indicacaos_indicadoIdToUsuarios?: IndicacaosUncheckedUpdateManyWithoutUsuarios_Indicacaos_indicadoIdToUsuariosNestedInput
    Indicacaos_Indicacaos_indicanteIdToUsuarios?: IndicacaosUncheckedUpdateManyWithoutUsuarios_Indicacaos_indicanteIdToUsuariosNestedInput
    Recompensas?: RecompensasUncheckedUpdateManyWithoutUsuariosNestedInput
    Saques?: SaquesUncheckedUpdateManyWithoutUsuariosNestedInput
  }

  export type IndicacaosCreateWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput = {
    createdAt: Date | string
    updatedAt: Date | string
    Usuarios_Indicacaos_indicanteIdToUsuarios: UsuariosCreateNestedOneWithoutIndicacaos_Indicacaos_indicanteIdToUsuariosInput
  }

  export type IndicacaosUncheckedCreateWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput = {
    id?: number
    indicanteId: number
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type IndicacaosCreateOrConnectWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput = {
    where: IndicacaosWhereUniqueInput
    create: XOR<IndicacaosCreateWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput, IndicacaosUncheckedCreateWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput>
  }

  export type IndicacaosCreateManyUsuarios_Indicacaos_indicadoIdToUsuariosInputEnvelope = {
    data: IndicacaosCreateManyUsuarios_Indicacaos_indicadoIdToUsuariosInput | IndicacaosCreateManyUsuarios_Indicacaos_indicadoIdToUsuariosInput[]
    skipDuplicates?: boolean
  }

  export type IndicacaosCreateWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput = {
    createdAt: Date | string
    updatedAt: Date | string
    Usuarios_Indicacaos_indicadoIdToUsuarios: UsuariosCreateNestedOneWithoutIndicacaos_Indicacaos_indicadoIdToUsuariosInput
  }

  export type IndicacaosUncheckedCreateWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput = {
    id?: number
    indicadoId: number
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type IndicacaosCreateOrConnectWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput = {
    where: IndicacaosWhereUniqueInput
    create: XOR<IndicacaosCreateWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput, IndicacaosUncheckedCreateWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput>
  }

  export type IndicacaosCreateManyUsuarios_Indicacaos_indicanteIdToUsuariosInputEnvelope = {
    data: IndicacaosCreateManyUsuarios_Indicacaos_indicanteIdToUsuariosInput | IndicacaosCreateManyUsuarios_Indicacaos_indicanteIdToUsuariosInput[]
    skipDuplicates?: boolean
  }

  export type RecompensasCreateWithoutUsuariosInput = {
    descricao: string
    valor: number
    status?: $Enums.enum_Recompensas_status | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type RecompensasUncheckedCreateWithoutUsuariosInput = {
    id?: number
    descricao: string
    valor: number
    status?: $Enums.enum_Recompensas_status | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type RecompensasCreateOrConnectWithoutUsuariosInput = {
    where: RecompensasWhereUniqueInput
    create: XOR<RecompensasCreateWithoutUsuariosInput, RecompensasUncheckedCreateWithoutUsuariosInput>
  }

  export type RecompensasCreateManyUsuariosInputEnvelope = {
    data: RecompensasCreateManyUsuariosInput | RecompensasCreateManyUsuariosInput[]
    skipDuplicates?: boolean
  }

  export type SaquesCreateWithoutUsuariosInput = {
    valor: Decimal | DecimalJsLike | number | string
    status?: $Enums.enum_Saques_status | null
    tipo: $Enums.enum_Saques_tipo
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type SaquesUncheckedCreateWithoutUsuariosInput = {
    id?: number
    valor: Decimal | DecimalJsLike | number | string
    status?: $Enums.enum_Saques_status | null
    tipo: $Enums.enum_Saques_tipo
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type SaquesCreateOrConnectWithoutUsuariosInput = {
    where: SaquesWhereUniqueInput
    create: XOR<SaquesCreateWithoutUsuariosInput, SaquesUncheckedCreateWithoutUsuariosInput>
  }

  export type SaquesCreateManyUsuariosInputEnvelope = {
    data: SaquesCreateManyUsuariosInput | SaquesCreateManyUsuariosInput[]
    skipDuplicates?: boolean
  }

  export type TransacaosCreateWithoutUsuariosInput = {
    tipo: $Enums.enum_Transacaos_tipo
    valor: number
    data: Date | string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TransacaosUncheckedCreateWithoutUsuariosInput = {
    id?: number
    tipo: $Enums.enum_Transacaos_tipo
    valor: number
    data: Date | string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TransacaosCreateOrConnectWithoutUsuariosInput = {
    where: TransacaosWhereUniqueInput
    create: XOR<TransacaosCreateWithoutUsuariosInput, TransacaosUncheckedCreateWithoutUsuariosInput>
  }

  export type TransacaosCreateManyUsuariosInputEnvelope = {
    data: TransacaosCreateManyUsuariosInput | TransacaosCreateManyUsuariosInput[]
    skipDuplicates?: boolean
  }

  export type IndicacaosUpsertWithWhereUniqueWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput = {
    where: IndicacaosWhereUniqueInput
    update: XOR<IndicacaosUpdateWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput, IndicacaosUncheckedUpdateWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput>
    create: XOR<IndicacaosCreateWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput, IndicacaosUncheckedCreateWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput>
  }

  export type IndicacaosUpdateWithWhereUniqueWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput = {
    where: IndicacaosWhereUniqueInput
    data: XOR<IndicacaosUpdateWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput, IndicacaosUncheckedUpdateWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput>
  }

  export type IndicacaosUpdateManyWithWhereWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput = {
    where: IndicacaosScalarWhereInput
    data: XOR<IndicacaosUpdateManyMutationInput, IndicacaosUncheckedUpdateManyWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput>
  }

  export type IndicacaosScalarWhereInput = {
    AND?: IndicacaosScalarWhereInput | IndicacaosScalarWhereInput[]
    OR?: IndicacaosScalarWhereInput[]
    NOT?: IndicacaosScalarWhereInput | IndicacaosScalarWhereInput[]
    id?: IntFilter<"Indicacaos"> | number
    indicanteId?: IntFilter<"Indicacaos"> | number
    indicadoId?: IntFilter<"Indicacaos"> | number
    createdAt?: DateTimeFilter<"Indicacaos"> | Date | string
    updatedAt?: DateTimeFilter<"Indicacaos"> | Date | string
  }

  export type IndicacaosUpsertWithWhereUniqueWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput = {
    where: IndicacaosWhereUniqueInput
    update: XOR<IndicacaosUpdateWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput, IndicacaosUncheckedUpdateWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput>
    create: XOR<IndicacaosCreateWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput, IndicacaosUncheckedCreateWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput>
  }

  export type IndicacaosUpdateWithWhereUniqueWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput = {
    where: IndicacaosWhereUniqueInput
    data: XOR<IndicacaosUpdateWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput, IndicacaosUncheckedUpdateWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput>
  }

  export type IndicacaosUpdateManyWithWhereWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput = {
    where: IndicacaosScalarWhereInput
    data: XOR<IndicacaosUpdateManyMutationInput, IndicacaosUncheckedUpdateManyWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput>
  }

  export type RecompensasUpsertWithWhereUniqueWithoutUsuariosInput = {
    where: RecompensasWhereUniqueInput
    update: XOR<RecompensasUpdateWithoutUsuariosInput, RecompensasUncheckedUpdateWithoutUsuariosInput>
    create: XOR<RecompensasCreateWithoutUsuariosInput, RecompensasUncheckedCreateWithoutUsuariosInput>
  }

  export type RecompensasUpdateWithWhereUniqueWithoutUsuariosInput = {
    where: RecompensasWhereUniqueInput
    data: XOR<RecompensasUpdateWithoutUsuariosInput, RecompensasUncheckedUpdateWithoutUsuariosInput>
  }

  export type RecompensasUpdateManyWithWhereWithoutUsuariosInput = {
    where: RecompensasScalarWhereInput
    data: XOR<RecompensasUpdateManyMutationInput, RecompensasUncheckedUpdateManyWithoutUsuariosInput>
  }

  export type RecompensasScalarWhereInput = {
    AND?: RecompensasScalarWhereInput | RecompensasScalarWhereInput[]
    OR?: RecompensasScalarWhereInput[]
    NOT?: RecompensasScalarWhereInput | RecompensasScalarWhereInput[]
    id?: IntFilter<"Recompensas"> | number
    usuarioId?: IntFilter<"Recompensas"> | number
    descricao?: StringFilter<"Recompensas"> | string
    valor?: FloatFilter<"Recompensas"> | number
    status?: Enumenum_Recompensas_statusNullableFilter<"Recompensas"> | $Enums.enum_Recompensas_status | null
    createdAt?: DateTimeFilter<"Recompensas"> | Date | string
    updatedAt?: DateTimeFilter<"Recompensas"> | Date | string
  }

  export type SaquesUpsertWithWhereUniqueWithoutUsuariosInput = {
    where: SaquesWhereUniqueInput
    update: XOR<SaquesUpdateWithoutUsuariosInput, SaquesUncheckedUpdateWithoutUsuariosInput>
    create: XOR<SaquesCreateWithoutUsuariosInput, SaquesUncheckedCreateWithoutUsuariosInput>
  }

  export type SaquesUpdateWithWhereUniqueWithoutUsuariosInput = {
    where: SaquesWhereUniqueInput
    data: XOR<SaquesUpdateWithoutUsuariosInput, SaquesUncheckedUpdateWithoutUsuariosInput>
  }

  export type SaquesUpdateManyWithWhereWithoutUsuariosInput = {
    where: SaquesScalarWhereInput
    data: XOR<SaquesUpdateManyMutationInput, SaquesUncheckedUpdateManyWithoutUsuariosInput>
  }

  export type SaquesScalarWhereInput = {
    AND?: SaquesScalarWhereInput | SaquesScalarWhereInput[]
    OR?: SaquesScalarWhereInput[]
    NOT?: SaquesScalarWhereInput | SaquesScalarWhereInput[]
    id?: IntFilter<"Saques"> | number
    usuarioId?: IntFilter<"Saques"> | number
    valor?: DecimalFilter<"Saques"> | Decimal | DecimalJsLike | number | string
    status?: Enumenum_Saques_statusNullableFilter<"Saques"> | $Enums.enum_Saques_status | null
    tipo?: Enumenum_Saques_tipoFilter<"Saques"> | $Enums.enum_Saques_tipo
    createdAt?: DateTimeFilter<"Saques"> | Date | string
    updatedAt?: DateTimeFilter<"Saques"> | Date | string
  }

  export type TransacaosUpsertWithWhereUniqueWithoutUsuariosInput = {
    where: TransacaosWhereUniqueInput
    update: XOR<TransacaosUpdateWithoutUsuariosInput, TransacaosUncheckedUpdateWithoutUsuariosInput>
    create: XOR<TransacaosCreateWithoutUsuariosInput, TransacaosUncheckedCreateWithoutUsuariosInput>
  }

  export type TransacaosUpdateWithWhereUniqueWithoutUsuariosInput = {
    where: TransacaosWhereUniqueInput
    data: XOR<TransacaosUpdateWithoutUsuariosInput, TransacaosUncheckedUpdateWithoutUsuariosInput>
  }

  export type TransacaosUpdateManyWithWhereWithoutUsuariosInput = {
    where: TransacaosScalarWhereInput
    data: XOR<TransacaosUpdateManyMutationInput, TransacaosUncheckedUpdateManyWithoutUsuariosInput>
  }

  export type TransacaosScalarWhereInput = {
    AND?: TransacaosScalarWhereInput | TransacaosScalarWhereInput[]
    OR?: TransacaosScalarWhereInput[]
    NOT?: TransacaosScalarWhereInput | TransacaosScalarWhereInput[]
    id?: IntFilter<"Transacaos"> | number
    usuario_id?: IntFilter<"Transacaos"> | number
    tipo?: Enumenum_Transacaos_tipoFilter<"Transacaos"> | $Enums.enum_Transacaos_tipo
    valor?: FloatFilter<"Transacaos"> | number
    data?: DateTimeFilter<"Transacaos"> | Date | string
    createdAt?: DateTimeFilter<"Transacaos"> | Date | string
    updatedAt?: DateTimeFilter<"Transacaos"> | Date | string
  }

  export type IndicacaosCreateManyUsuarios_Indicacaos_indicadoIdToUsuariosInput = {
    id?: number
    indicanteId: number
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type IndicacaosCreateManyUsuarios_Indicacaos_indicanteIdToUsuariosInput = {
    id?: number
    indicadoId: number
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type RecompensasCreateManyUsuariosInput = {
    id?: number
    descricao: string
    valor: number
    status?: $Enums.enum_Recompensas_status | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type SaquesCreateManyUsuariosInput = {
    id?: number
    valor: Decimal | DecimalJsLike | number | string
    status?: $Enums.enum_Saques_status | null
    tipo: $Enums.enum_Saques_tipo
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TransacaosCreateManyUsuariosInput = {
    id?: number
    tipo: $Enums.enum_Transacaos_tipo
    valor: number
    data: Date | string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type IndicacaosUpdateWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Usuarios_Indicacaos_indicanteIdToUsuarios?: UsuariosUpdateOneRequiredWithoutIndicacaos_Indicacaos_indicanteIdToUsuariosNestedInput
  }

  export type IndicacaosUncheckedUpdateWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput = {
    id?: IntFieldUpdateOperationsInput | number
    indicanteId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndicacaosUncheckedUpdateManyWithoutUsuarios_Indicacaos_indicadoIdToUsuariosInput = {
    id?: IntFieldUpdateOperationsInput | number
    indicanteId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndicacaosUpdateWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Usuarios_Indicacaos_indicadoIdToUsuarios?: UsuariosUpdateOneRequiredWithoutIndicacaos_Indicacaos_indicadoIdToUsuariosNestedInput
  }

  export type IndicacaosUncheckedUpdateWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput = {
    id?: IntFieldUpdateOperationsInput | number
    indicadoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndicacaosUncheckedUpdateManyWithoutUsuarios_Indicacaos_indicanteIdToUsuariosInput = {
    id?: IntFieldUpdateOperationsInput | number
    indicadoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecompensasUpdateWithoutUsuariosInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    status?: NullableEnumenum_Recompensas_statusFieldUpdateOperationsInput | $Enums.enum_Recompensas_status | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecompensasUncheckedUpdateWithoutUsuariosInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    status?: NullableEnumenum_Recompensas_statusFieldUpdateOperationsInput | $Enums.enum_Recompensas_status | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecompensasUncheckedUpdateManyWithoutUsuariosInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    status?: NullableEnumenum_Recompensas_statusFieldUpdateOperationsInput | $Enums.enum_Recompensas_status | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaquesUpdateWithoutUsuariosInput = {
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: NullableEnumenum_Saques_statusFieldUpdateOperationsInput | $Enums.enum_Saques_status | null
    tipo?: Enumenum_Saques_tipoFieldUpdateOperationsInput | $Enums.enum_Saques_tipo
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaquesUncheckedUpdateWithoutUsuariosInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: NullableEnumenum_Saques_statusFieldUpdateOperationsInput | $Enums.enum_Saques_status | null
    tipo?: Enumenum_Saques_tipoFieldUpdateOperationsInput | $Enums.enum_Saques_tipo
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaquesUncheckedUpdateManyWithoutUsuariosInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: NullableEnumenum_Saques_statusFieldUpdateOperationsInput | $Enums.enum_Saques_status | null
    tipo?: Enumenum_Saques_tipoFieldUpdateOperationsInput | $Enums.enum_Saques_tipo
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransacaosUpdateWithoutUsuariosInput = {
    tipo?: Enumenum_Transacaos_tipoFieldUpdateOperationsInput | $Enums.enum_Transacaos_tipo
    valor?: FloatFieldUpdateOperationsInput | number
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransacaosUncheckedUpdateWithoutUsuariosInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: Enumenum_Transacaos_tipoFieldUpdateOperationsInput | $Enums.enum_Transacaos_tipo
    valor?: FloatFieldUpdateOperationsInput | number
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransacaosUncheckedUpdateManyWithoutUsuariosInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: Enumenum_Transacaos_tipoFieldUpdateOperationsInput | $Enums.enum_Transacaos_tipo
    valor?: FloatFieldUpdateOperationsInput | number
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}